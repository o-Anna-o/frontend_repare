{"version":3,"file":"src-D-LZ3PGk.js","names":["content","path","name","usageName: string | null","packageJson.version","SCHEMA_TYPES","CONSTANTS.PROJECT_VERSION","description","CONSTANTS","componentSchema: SchemaComponent","SCHEMA_TYPES","description","SCHEMA_TYPES","description","SCHEMA_TYPES","SCHEMA_TYPES","enumNames","SCHEMA_TYPES","formatted: string | undefined","SCHEMA_TYPES","name","interfaceKeysContent: any","recordKeysContent: any","recordValuesContent: any","SCHEMA_TYPES","description","SCHEMA_TYPES","name","SCHEMA_TYPES","resultType: string","pathParams","fixedRoute","schema","name","name","path","requestOptions: Partial<RequestInit>","url","url","__dirname","path","url","name","configuration","name","path","__dirname","url","name","modularApiFileInfos: TranslatorIO[]"],"sources":["../src/code-formatter.ts","../src/util/name-resolver.ts","../src/util/random.ts","../src/component-type-name-resolver.ts","../package.json","../src/constants.ts","../src/util/object-assign.ts","../src/configuration.ts","../src/schema-components-map.ts","../src/schema-parser/schema-formatters.ts","../src/util/sort-by-property.ts","../src/schema-parser/mono-schema-parser.ts","../src/schema-parser/base-schema-parsers/array.ts","../src/schema-parser/base-schema-parsers/complex.ts","../src/schema-parser/base-schema-parsers/discriminator.ts","../src/schema-parser/util/enum-key-resolver.ts","../src/schema-parser/base-schema-parsers/enum.ts","../src/schema-parser/base-schema-parsers/object.ts","../src/schema-parser/base-schema-parsers/primitive.ts","../src/schema-parser/complex-schema-parsers/all-of.ts","../src/schema-parser/complex-schema-parsers/any-of.ts","../src/schema-parser/complex-schema-parsers/not.ts","../src/schema-parser/complex-schema-parsers/one-of.ts","../src/schema-parser/schema-parser.ts","../src/util/internal-case.ts","../src/util/pascal-case.ts","../src/schema-parser/schema-utils.ts","../src/schema-parser/schema-parser-fabric.ts","../src/util/id.ts","../src/schema-routes/util/specific-arg-name-resolver.ts","../src/schema-routes/schema-routes.ts","../src/schema-walker.ts","../src/util/request.ts","../src/swagger-schema-resolver.ts","../src/templates-worker.ts","../src/translators/translator.ts","../src/translators/javascript.ts","../src/type-name-formatter.ts","../src/util/file-system.ts","../src/code-gen-process.ts","../types/index.ts","../src/commands/generate-templates/configuration.ts","../src/commands/generate-templates/templates-gen-process.ts","../src/commands/generate-templates/index.ts","../src/index.ts"],"sourcesContent":["import * as path from \"node:path\";\nimport { Biome, Distribution } from \"@biomejs/js-api\";\nimport * as nanoid from \"nanoid\";\nimport * as typescript from \"typescript\";\nimport type { CodeGenConfig } from \"./configuration.js\";\n\nexport class CodeFormatter {\n  config: CodeGenConfig;\n\n  constructor(config: CodeGenConfig) {\n    this.config = config;\n  }\n\n  removeUnusedImports = (content: string) => {\n    const tempFileName = \"file.ts\";\n\n    const host = new TsLanguageServiceHost(tempFileName, content);\n    const languageService = typescript.createLanguageService(host);\n\n    const fileTextChanges = languageService.organizeImports(\n      { type: \"file\", fileName: tempFileName },\n      { newLineCharacter: typescript.sys.newLine },\n      undefined,\n    )[0];\n\n    if (fileTextChanges?.textChanges.length) {\n      return fileTextChanges.textChanges.reduceRight(\n        (content, { span, newText }) =>\n          `${content.slice(0, span.start)}${newText}${content.slice(\n            span.start + span.length,\n          )}`,\n        content,\n      );\n    }\n\n    return content;\n  };\n\n  format = async (content: string) => {\n    const biome = await Biome.create({ distribution: Distribution.NODE });\n    const biomeProject = biome.openProject();\n    biome.applyConfiguration(biomeProject.projectKey, {\n      files: { maxSize: Number.MAX_SAFE_INTEGER },\n      formatter: { indentStyle: \"space\" },\n    });\n    const formatted = biome.formatContent(biomeProject.projectKey, content, {\n      filePath: path.format({ name: nanoid.nanoid(), ext: \"ts\" }),\n    });\n    return formatted.content;\n  };\n\n  formatCode = async (\n    code: string,\n    { removeUnusedImports = true, format = true } = {},\n  ) => {\n    if (removeUnusedImports) {\n      code = this.removeUnusedImports(code);\n    }\n    if (format) {\n      code = await this.format(code);\n    }\n    return code;\n  };\n}\n\nclass TsLanguageServiceHost {\n  fileName: string;\n  content: string;\n  compilerOptions: typescript.CompilerOptions;\n\n  constructor(fileName: string, content: string) {\n    this.fileName = fileName;\n    this.content = content;\n    const tsconfig = typescript.findConfigFile(\n      fileName,\n      typescript.sys.fileExists,\n    );\n    this.compilerOptions = tsconfig\n      ? typescript.convertCompilerOptionsFromJson(\n          typescript.readConfigFile(tsconfig, typescript.sys.readFile).config\n            .compilerOptions,\n          \"\",\n        ).options\n      : typescript.getDefaultCompilerOptions();\n  }\n\n  getNewLine() {\n    return \"newLine\" in typescript.sys ? typescript.sys.newLine : \"\\n\";\n  }\n  getScriptFileNames() {\n    return [this.fileName];\n  }\n  getCompilationSettings() {\n    return this.compilerOptions;\n  }\n  getDefaultLibFileName() {\n    return typescript.getDefaultLibFileName(this.getCompilationSettings());\n  }\n  getCurrentDirectory() {\n    return process.cwd();\n  }\n  getScriptVersion() {\n    return typescript.version;\n  }\n  getScriptSnapshot() {\n    return typescript.ScriptSnapshot.fromString(this.content);\n  }\n  readFile(fileName: string, encoding: string) {\n    if (fileName === this.fileName) {\n      return this.content;\n    }\n\n    return typescript.sys.readFile(fileName, encoding);\n  }\n  fileExists(path: string) {\n    return typescript.sys.fileExists(path);\n  }\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport type { CodeGenConfig } from \"../configuration.js\";\n\ntype Resolver = (reserved: string[], extras?: string[]) => string;\n\nexport class NameResolver {\n  reservedNames: string[] = [];\n  getFallbackName: Resolver;\n\n  config: CodeGenConfig;\n\n  constructor(\n    config: CodeGenConfig,\n    reservedNames: string[],\n    getFallbackName: Resolver,\n  ) {\n    this.config = config;\n    this.getFallbackName = getFallbackName;\n    this.reserve(reservedNames);\n  }\n\n  reserve(names: string[]) {\n    const fixedNames = lodash.uniq(lodash.compact(names));\n    for (const name of fixedNames) {\n      if (this.reservedNames.indexOf(name) === -1) {\n        this.reservedNames.push(name);\n      }\n    }\n  }\n\n  unreserve(names: string[]) {\n    this.reservedNames = this.reservedNames.filter(\n      (reservedName) => !names.some((name) => name === reservedName),\n    );\n  }\n\n  isReserved(name: string) {\n    return this.reservedNames.some((reservedName) => reservedName === name);\n  }\n\n  resolve(\n    variants: string[],\n    resolver?: Resolver,\n    extras?: string[],\n    shouldReserve = true,\n  ): string | null {\n    if (typeof resolver === \"function\") {\n      let usageName: string | null = null;\n      while (usageName === null) {\n        const variant = resolver(variants, extras);\n\n        if (variant === undefined) {\n          consola.warn(\n            \"unable to resolve name. current reserved names: \",\n            ...this.reservedNames,\n          );\n          return null;\n        }\n        if (!shouldReserve || !this.isReserved(variant)) {\n          usageName = variant;\n        }\n      }\n\n      shouldReserve && this.reserve([usageName]);\n      return usageName;\n    }\n\n    if (Array.isArray(variants)) {\n      let usageName: string | null = null;\n      const uniqVariants = lodash.uniq(lodash.compact(variants));\n\n      for (const variant of uniqVariants) {\n        if (!usageName && (!shouldReserve || !this.isReserved(variant))) {\n          usageName = variant;\n        }\n      }\n\n      if (usageName) {\n        shouldReserve && this.reserve([usageName]);\n        return usageName;\n      }\n\n      consola.debug(\n        \"trying to resolve name with using fallback name generator using variants\",\n        ...variants,\n      );\n      return this.resolve(variants, this.getFallbackName, extras);\n    }\n\n    consola.debug(\n      \"problem with reserving names. current reserved names: \",\n      ...this.reservedNames,\n    );\n    return null;\n  }\n}\n","export const getRandomFloat = (min = 0, max = 1) => {\n  return Math.random() * (max - min) + min;\n};\n\nexport const getRandomInt = (min = 0, max = 1) => {\n  if (min === max) return min;\n\n  return Math.round(getRandomFloat(min, max));\n};\n","import { consola } from \"consola\";\nimport type { CodeGenConfig } from \"./configuration.js\";\nimport { NameResolver } from \"./util/name-resolver.js\";\nimport { getRandomInt } from \"./util/random.js\";\n\nexport class ComponentTypeNameResolver extends NameResolver {\n  counter = 1;\n  fallbackNameCounter = 1;\n  countersByVariant = new Map<string, number>();\n\n  constructor(config: CodeGenConfig, reservedNames: string[]) {\n    super(config, reservedNames, (variants) => {\n      const randomVariant = variants[getRandomInt(0, variants.length - 1)];\n      if (randomVariant) {\n        if (!this.countersByVariant.has(randomVariant)) {\n          this.countersByVariant.set(randomVariant, 0);\n        }\n        const variantCounter =\n          (this.countersByVariant.get(randomVariant) as number) + 1;\n        this.countersByVariant.set(randomVariant, variantCounter);\n        const dirtyResolvedName = `${randomVariant}${variantCounter}`;\n        consola.debug(\n          \"generated dirty resolved type name for component - \",\n          dirtyResolvedName,\n        );\n        return dirtyResolvedName;\n      }\n\n      const fallbackName = `${this.config.componentTypeNameResolver}${this\n        .fallbackNameCounter++}`;\n      consola.debug(\n        \"generated fallback type name for component - \",\n        fallbackName,\n      );\n      return fallbackName;\n    });\n  }\n}\n","{\n  \"name\": \"swagger-typescript-api\",\n  \"version\": \"13.2.16\",\n  \"description\": \"Generate the API client for Fetch or Axios from an OpenAPI Specification\",\n  \"homepage\": \"https://github.com/acacode/swagger-typescript-api\",\n  \"bugs\": \"https://github.com/acacode/swagger-typescript-api/issues\",\n  \"repository\": \"github:acacode/swagger-typescript-api\",\n  \"license\": \"MIT\",\n  \"author\": \"Sergey Volkov <js2me@outlook.com>\",\n  \"maintainers\": [\n    \"Sora Morimoto <sora@morimoto.io>\"\n  ],\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\"\n    },\n    \"./cli\": {\n      \"import\": \"./dist/cli.js\",\n      \"require\": \"./dist/cli.cjs\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.cts\",\n  \"bin\": {\n    \"sta\": \"./dist/cli.js\",\n    \"swagger-typescript-api\": \"./dist/cli.js\"\n  },\n  \"files\": [\n    \"dist\",\n    \"templates\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsdown\",\n    \"cli:help\": \"node index.js -h\",\n    \"cli:json\": \"node index.js -r -d -p ./swagger-test-cli.json -n swagger-test-cli.ts\",\n    \"cli:yaml\": \"node index.js -r -d -p ./swagger-test-cli.yaml -n swagger-test-cli.ts\",\n    \"format\": \"biome format --write .\",\n    \"format:check\": \"biome format .\",\n    \"lint\": \"biome check\",\n    \"prepack\": \"tsdown\",\n    \"test\": \"vitest run\",\n    \"typedoc\": \"typedoc\"\n  },\n  \"dependencies\": {\n    \"@biomejs/js-api\": \"3.0.0\",\n    \"@biomejs/wasm-nodejs\": \"2.2.6\",\n    \"@types/lodash\": \"^4.17.20\",\n    \"@types/swagger-schema-official\": \"^2.0.25\",\n    \"c12\": \"^3.3.0\",\n    \"citty\": \"^0.1.6\",\n    \"consola\": \"^3.4.2\",\n    \"eta\": \"^3.5.0\",\n    \"lodash\": \"^4.17.21\",\n    \"nanoid\": \"^5.1.6\",\n    \"openapi-types\": \"^12.1.3\",\n    \"swagger-schema-official\": \"2.0.0-bab6bed\",\n    \"swagger2openapi\": \"^7.0.8\",\n    \"typescript\": \"~5.9.3\",\n    \"yaml\": \"^2.8.1\"\n  },\n  \"devDependencies\": {\n    \"@biomejs/biome\": \"2.2.6\",\n    \"@changesets/changelog-github\": \"0.5.1\",\n    \"@changesets/cli\": \"2.29.7\",\n    \"@tsconfig/node20\": \"20.1.6\",\n    \"@tsconfig/strictest\": \"2.0.6\",\n    \"@types/node\": \"24.9.1\",\n    \"@types/swagger2openapi\": \"7.0.4\",\n    \"axios\": \"1.12.2\",\n    \"tsdown\": \"0.15.9\",\n    \"typedoc\": \"0.28.14\",\n    \"vitest\": \"3.2.4\"\n  },\n  \"packageManager\": \"yarn@4.10.3\",\n  \"engines\": {\n    \"node\": \">=20\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\",\n    \"provenance\": true,\n    \"registry\": \"https://registry.npmjs.org\"\n  },\n  \"typedocOptions\": {\n    \"entryPoints\": [\n      \"src/index.ts\"\n    ],\n    \"skipErrorChecking\": true\n  }\n}\n","import packageJson from \"../package.json\" with { type: \"json\" };\n\nexport const DEFAULT_BODY_ARG_NAME = \"data\";\n\nexport const FILE_PREFIX = `/* eslint-disable */\n/* tslint:disable */\n// @ts-nocheck\n/*\n * ---------------------------------------------------------------\n * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##\n * ##                                                           ##\n * ## AUTHOR: acacode                                           ##\n * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##\n * ---------------------------------------------------------------\n */\n\n`;\n\nexport const HTTP_CLIENT = {\n  FETCH: \"fetch\",\n  AXIOS: \"axios\",\n} as const;\n\nexport const PROJECT_VERSION = packageJson.version;\n\nexport const RESERVED_BODY_ARG_NAMES = [\"data\", \"body\", \"reqBody\"];\n\nexport const RESERVED_HEADER_ARG_NAMES = [\"headers\", \"headersParams\"];\n\nexport const RESERVED_PATH_ARG_NAMES = [\"path\", \"pathParams\"];\n\nexport const RESERVED_QUERY_ARG_NAMES = [\"query\", \"queryParams\", \"queryArg\"];\n\nexport const RESERVED_REQ_PARAMS_ARG_NAMES = [\n  \"params\",\n  \"requestParams\",\n  \"reqParams\",\n  \"httpParams\",\n];\n\nexport const SCHEMA_TYPES = {\n  ARRAY: \"array\",\n  OBJECT: \"object\",\n  ENUM: \"enum\",\n  REF: \"$ref\",\n  PRIMITIVE: \"primitive\",\n  COMPLEX: \"complex\",\n  DISCRIMINATOR: \"discriminator\",\n  COMPLEX_ONE_OF: \"oneOf\",\n  COMPLEX_ANY_OF: \"anyOf\",\n  COMPLEX_ALL_OF: \"allOf\",\n  COMPLEX_NOT: \"not\",\n  COMPLEX_UNKNOWN: \"__unknown\",\n} as const;\n","import lodash from \"lodash\";\n\ntype Updater = (target: unknown) => unknown;\n\nexport const objectAssign = (target: object, updater: Updater | unknown) => {\n  if (!updater) return;\n  const update = typeof updater === \"function\" ? updater(target) : updater;\n  const undefinedKeys = lodash\n    .map(update, (value, key) => value === undefined && key)\n    .filter((key) => typeof key === \"string\");\n  Object.assign(target, lodash.merge(target, update));\n  for (const key of undefinedKeys) {\n    target[key] = undefined;\n  }\n};\n","import lodash from \"lodash\";\nimport type { OpenAPI } from \"openapi-types\";\nimport * as typescript from \"typescript\";\nimport type {\n  ExtractingOptions,\n  GenerateApiConfiguration,\n  Hooks,\n  SchemaComponent,\n} from \"../types/index.js\";\nimport { ComponentTypeNameResolver } from \"./component-type-name-resolver.js\";\nimport * as CONSTANTS from \"./constants.js\";\nimport type { MonoSchemaParser } from \"./schema-parser/mono-schema-parser.js\";\nimport type { SchemaParser } from \"./schema-parser/schema-parser.js\";\nimport type { Translator } from \"./translators/translator.js\";\nimport { objectAssign } from \"./util/object-assign.js\";\n\nconst TsKeyword = {\n  Number: \"number\",\n  String: \"string\",\n  Boolean: \"boolean\",\n  Any: \"any\",\n  Void: \"void\",\n  Unknown: \"unknown\",\n  Null: \"null\",\n  Undefined: \"undefined\",\n  Object: \"object\",\n  File: \"File\",\n  Date: \"Date\",\n  Type: \"type\",\n  Enum: \"enum\",\n  Interface: \"interface\",\n  Array: \"Array\",\n  Record: \"Record\",\n  Intersection: \"&\",\n  Union: \"|\",\n};\n\nconst TsCodeGenKeyword = {\n  UtilRequiredKeys: \"UtilRequiredKeys\",\n};\n\nexport class CodeGenConfig {\n  version = CONSTANTS.PROJECT_VERSION;\n  /** CLI flag */\n  templates = \"\";\n  /** CLI flag */\n  generateResponses = false;\n  /** CLI flag */\n  defaultResponseAsSuccess = false;\n  /** CLI flag */\n  generateRouteTypes = false;\n  /** CLI flag */\n  generateClient = true;\n  /** CLI flag */\n  generateUnionEnums = false;\n  /** CLI flag */\n  addReadonly = false;\n  enumNamesAsValues = false;\n  /** parsed swagger schema from getSwaggerObject() */\n\n  /** parsed swagger schema ref */\n  swaggerSchema = null;\n  /** original (converted to json) swagger schema ref */\n  originalSchema = null;\n\n  /** { \"#/components/schemas/Foo\": @TypeInfo, ... } */\n  componentsMap = {};\n  /** flag for catching conversion from swagger 2.0 */\n  convertedFromSwagger2 = false;\n\n  /** url index from paths used for merging into modules */\n  moduleNameIndex = 0;\n\n  /** use the first tag for the module name */\n  moduleNameFirstTag = false;\n  extractRequestParams = false;\n  extractRequestBody = false;\n  extractResponseBody = false;\n  extractResponseError = false;\n  extractResponses = false;\n  extractEnums = false;\n  fileNames = {\n    dataContracts: \"data-contracts\",\n    routeTypes: \"route-types\",\n    httpClient: \"http-client\",\n    outOfModuleApi: \"Common\",\n  };\n  routeNameDuplicatesMap = new Map();\n  hooks: Hooks = {\n    onPreBuildRoutePath: (_routePath: unknown) => void 0,\n    onBuildRoutePath: (_routeData: unknown) => void 0,\n    onInsertPathParam: (_pathParam: unknown) => void 0,\n    onCreateComponent: (schema: SchemaComponent) => schema,\n    onPreParseSchema: (\n      _originalSchema: unknown,\n      _typeName: unknown,\n      _schemaType: unknown,\n    ) => void 0,\n    onParseSchema: (_originalSchema: unknown, parsedSchema: unknown) =>\n      parsedSchema,\n    onCreateRoute: (routeData: unknown) => routeData,\n    onInit: (config: unknown, _codeGenProcess: unknown) => config,\n    onPrepareConfig: (apiConfig: unknown) => apiConfig,\n    onCreateRequestParams: (_rawType: unknown) => {},\n    onCreateRouteName: () => {},\n    onFormatTypeName: (\n      _typeName: unknown,\n      _rawTypeName: unknown,\n      _schemaType: unknown,\n    ) => {},\n    onFormatRouteName: (_routeInfo: unknown, _templateRouteName: unknown) => {},\n  };\n  defaultResponseType;\n  singleHttpClient = false;\n  httpClientType = CONSTANTS.HTTP_CLIENT.FETCH;\n  unwrapResponseData = false;\n  disableThrowOnError = false;\n  sortTypes = false;\n  sortRoutes = false;\n  templatePaths = {\n    /** `templates/base` */\n    base: \"\",\n    /** `templates/default` */\n    default: \"\",\n    /** `templates/modular` */\n    modular: \"\",\n    /** usage path if `--templates` option is not set */\n    original: \"\",\n    /** custom path to templates (`--templates`) */\n    custom: \"\",\n  };\n  /** Record<templateName, templateContent> */\n  templatesToRender = {\n    api: \"\",\n    dataContracts: \"\",\n    dataContractJsDoc: \"\",\n    interfaceDataContract: \"\",\n    typeDataContract: \"\",\n    enumDataContract: \"\",\n    objectFieldJsDoc: \"\",\n    httpClient: \"\",\n    routeTypes: \"\",\n    routeName: \"\",\n  };\n  schemaParsers: Record<string, (...args: unknown[]) => MonoSchemaParser> = {};\n  toJS = false;\n  silent = false;\n  typePrefix = \"\";\n  typeSuffix = \"\";\n  enumKeyPrefix = \"\";\n  enumKeySuffix = \"\";\n  patch = false;\n  componentTypeNameResolver: ComponentTypeNameResolver;\n  /** name of the main exported class */\n  apiClassName = \"Api\";\n  debug = false;\n  anotherArrayType = false;\n  internalTemplateOptions = {\n    addUtilRequiredKeysType: false,\n  };\n  extraTemplates = [];\n  input = \"\";\n  modular = false;\n  output = \"\";\n  url = \"\";\n  cleanOutput = false;\n  spec: OpenAPI.Document | null = null;\n  fileName = \"Api.ts\";\n  authorizationToken: string | undefined;\n  requestOptions = null;\n\n  jsPrimitiveTypes: string[] = [];\n  jsEmptyTypes: string[] = [];\n  fixInvalidTypeNamePrefix = \"Type\";\n  fixInvalidEnumKeyPrefix = \"Value\";\n\n  enumKeyResolverName = \"Value\";\n  typeNameResolverName = \"ComponentType\";\n  specificArgNameResolverName = \"arg\";\n\n  successResponseStatusRange = [200, 299];\n\n  extractingOptions: Partial<ExtractingOptions> = {\n    requestBodySuffix: [\"Payload\", \"Body\", \"Input\"],\n    requestParamsSuffix: [\"Params\"],\n    responseBodySuffix: [\"Data\", \"Result\", \"Output\"],\n    responseErrorSuffix: [\n      \"Error\",\n      \"Fail\",\n      \"Fails\",\n      \"ErrorData\",\n      \"HttpError\",\n      \"BadResponse\",\n    ],\n    enumSuffix: [\"Enum\"],\n    discriminatorMappingSuffix: [\"Mapping\", \"Mapper\", \"MapType\"],\n    discriminatorAbstractPrefix: [\n      \"Base\",\n      \"Abstract\",\n      \"Discriminator\",\n      \"Internal\",\n      \"Polymorph\",\n    ],\n  };\n\n  compilerTsConfig = {\n    module: typescript.ModuleKind.ESNext,\n    noImplicitReturns: true,\n    alwaysStrict: true,\n    target: typescript.ScriptTarget.ESNext,\n    declaration: true,\n    noImplicitAny: false,\n    sourceMap: false,\n    removeComments: false,\n    disableSizeLimit: true,\n    esModuleInterop: true,\n    emitDecoratorMetadata: true,\n    skipLibCheck: true,\n  };\n  customTranslator?: new () => Translator;\n\n  Ts = {\n    Keyword: structuredClone(TsKeyword),\n    CodeGenKeyword: structuredClone(TsCodeGenKeyword),\n    /**\n     * $A[] or Array<$A>\n     */\n    ArrayType: (content: unknown) => {\n      if (this.anotherArrayType) {\n        return this.Ts.TypeWithGeneric(this.Ts.Keyword.Array, [content]);\n      }\n\n      return `${this.Ts.ExpressionGroup(content)}[]`;\n    },\n    /**\n     * \"$A\"\n     */\n    StringValue: (content: unknown) => `\"${content}\"`,\n    /**\n     * $A\n     */\n    BooleanValue: (content: unknown) => `${content}`,\n    /**\n     * $A\n     */\n    NumberValue: (content: unknown) => `${content}`,\n    /**\n     * $A\n     */\n    NullValue: () => \"null\",\n    /**\n     * $A1 | $A2\n     */\n    UnionType: (contents: unknown[]) =>\n      lodash.join(lodash.uniq(contents), ` ${this.Ts.Keyword.Union} `),\n    /**\n     * ($A1)\n     */\n    ExpressionGroup: (content: unknown) => (content ? `(${content})` : \"\"),\n    /**\n     * $A1 & $A2\n     */\n    IntersectionType: (contents: unknown[]) =>\n      lodash.join(lodash.uniq(contents), ` ${this.Ts.Keyword.Intersection} `),\n    /**\n     * Record<$A1, $A2>\n     */\n    RecordType: (key: unknown, value: unknown) =>\n      this.Ts.TypeWithGeneric(this.Ts.Keyword.Record, [key, value]),\n    /**\n     * readonly $key?:$value\n     */\n    TypeField: ({ readonly, key, optional, value }: Record<string, unknown>) =>\n      lodash\n        .compact([readonly && \"readonly \", key, optional && \"?\", \": \", value])\n        .join(\"\"),\n    /**\n     * [key: $A1]: $A2\n     */\n    InterfaceDynamicField: (key: unknown, value: unknown) =>\n      `[key: ${key}]: ${value}`,\n\n    /**\n     * EnumName.EnumKey\n     */\n    EnumUsageKey: (enumStruct: unknown, key: unknown) => `${enumStruct}.${key}`,\n    /**\n     * $A1 = $A2\n     */\n    EnumField: (key: unknown, value: unknown) => `${key} = ${value}`,\n    /**\n     * /\\** description \\*\\/\n     */\n    EnumFieldDescription: (description: any) => {\n      if (description) {\n        return `  /** ${description} */`;\n      } else {\n        return \"\";\n      }\n    },\n    /**\n     * /\\** $A0.description \\*\\/\n     * $A0.key = $A0.value,\n     * /\\** $A1.description \\*\\/\n     * $A1.key = $A1.value,\n     * /\\** $AN.description \\*\\/\n     * $AN.key = $AN.value,\n     */\n    EnumFieldsWrapper: (contents: Record<string, unknown>[]) =>\n      lodash\n        .map(contents, ({ key, value, description }) => {\n          return [\n            this.Ts.EnumFieldDescription(description),\n            `  ${this.Ts.EnumField(key, value)}`,\n          ]\n            .filter(Boolean)\n            .join(\"\\n\");\n        })\n        .join(\",\\n\"),\n    /**\n     * {\\n $A \\n}\n     */\n    ObjectWrapper: (content: unknown) => `{\\n${content}\\n}`,\n    /**\n     * /** $A *\\/\n     */\n    MultilineComment: (\n      contents: unknown[],\n      formatFn: (arg: unknown) => unknown,\n    ) =>\n      [\n        ...(contents.length === 1\n          ? [`/** ${contents[0]} */`]\n          : [\"/**\", ...contents.map((content) => ` * ${content}`), \" */\"]),\n      ].map((part) => `${formatFn ? formatFn(part) : part}\\n`),\n    /**\n     * $A1<...$A2.join(,)>\n     */\n    TypeWithGeneric: (typeName: unknown, genericArgs: unknown[]) => {\n      return `${typeName}${\n        genericArgs.length ? `<${genericArgs.join(\",\")}>` : \"\"\n      }`;\n    },\n    /**\n     * [$A1, $A2, ...$AN]\n     */\n    Tuple: (values: unknown[]) => {\n      return `[${values.join(\", \")}]`;\n    },\n  };\n\n  /**\n   * swagger schema type -> typescript type\n   * https://json-schema.org/understanding-json-schema/reference/string.html#dates-and-times\n   */\n  primitiveTypes: Record<\n    string,\n    | string\n    | ((schema: OpenAPI.Document, parser: SchemaParser) => string)\n    | ({ $default: string } & Record<\n        string,\n        string | ((schema: OpenAPI.Document, parser: SchemaParser) => string)\n      >)\n  > = {\n    integer: () => this.Ts.Keyword.Number,\n    number: () => this.Ts.Keyword.Number,\n    boolean: () => this.Ts.Keyword.Boolean,\n    object: () => this.Ts.Keyword.Object,\n    file: () => this.Ts.Keyword.File,\n    string: {\n      $default: this.Ts.Keyword.String,\n\n      /** formats */\n      binary: () => this.Ts.Keyword.File,\n      file: () => this.Ts.Keyword.File,\n      \"date-time\": () => this.Ts.Keyword.String,\n      time: () => this.Ts.Keyword.String,\n      date: () => this.Ts.Keyword.String,\n      duration: () => this.Ts.Keyword.String,\n      email: () => this.Ts.Keyword.String,\n      \"idn-email\": () => this.Ts.Keyword.String,\n      \"idn-hostname\": () => this.Ts.Keyword.String,\n      ipv4: () => this.Ts.Keyword.String,\n      ipv6: () => this.Ts.Keyword.String,\n      uuid: () => this.Ts.Keyword.String,\n      uri: () => this.Ts.Keyword.String,\n      \"uri-reference\": () => this.Ts.Keyword.String,\n      \"uri-template\": () => this.Ts.Keyword.String,\n      \"json-pointer\": () => this.Ts.Keyword.String,\n      \"relative-json-pointer\": () => this.Ts.Keyword.String,\n      regex: () => this.Ts.Keyword.String,\n    },\n  };\n\n  templateInfos = [\n    { name: \"api\", fileName: \"api\" },\n    { name: \"dataContracts\", fileName: \"data-contracts\" },\n    { name: \"dataContractJsDoc\", fileName: \"data-contract-jsdoc\" },\n    { name: \"interfaceDataContract\", fileName: \"interface-data-contract\" },\n    { name: \"typeDataContract\", fileName: \"type-data-contract\" },\n    { name: \"enumDataContract\", fileName: \"enum-data-contract\" },\n    { name: \"objectFieldJsDoc\", fileName: \"object-field-jsdoc\" },\n    { name: \"httpClient\", fileName: \"http-client\" },\n    { name: \"routeTypes\", fileName: \"route-types\" },\n    { name: \"routeName\", fileName: \"route-name\" },\n  ];\n\n  templateExtensions = [\".eta\", \".ejs\"];\n\n  constructor({\n    codeGenConstructs,\n    primitiveTypeConstructs,\n    constants,\n    templateInfos,\n    hooks,\n    ...otherConfig\n  }: Partial<GenerateApiConfiguration[\"config\"]>) {\n    objectAssign(this.Ts, codeGenConstructs);\n    objectAssign(this.primitiveTypes, primitiveTypeConstructs);\n\n    this.defaultResponseType = this.Ts.Keyword.Void;\n\n    this.update({\n      ...otherConfig,\n      hooks: lodash.merge(this.hooks, hooks || {}),\n      constants: {\n        ...CONSTANTS,\n        ...constants,\n      },\n      templateInfos: templateInfos || this.templateInfos,\n    });\n\n    this.jsPrimitiveTypes = [\n      this.Ts.Keyword.Number,\n      this.Ts.Keyword.String,\n      this.Ts.Keyword.Boolean,\n    ];\n    this.jsEmptyTypes = [this.Ts.Keyword.Null, this.Ts.Keyword.Undefined];\n    this.componentTypeNameResolver = new ComponentTypeNameResolver(this, []);\n  }\n\n  update = (update: Partial<GenerateApiConfiguration[\"config\"]>) => {\n    objectAssign(this, update);\n    if (this.enumNamesAsValues) {\n      this.extractEnums = true;\n    }\n  };\n}\n","import type { SchemaComponent } from \"../types/index.js\";\nimport type { CodeGenConfig } from \"./configuration.js\";\n\nexport class SchemaComponentsMap {\n  _data: SchemaComponent[] = [];\n  config: CodeGenConfig;\n\n  constructor(config: CodeGenConfig) {\n    this.config = config;\n  }\n\n  clear() {\n    this._data = [];\n  }\n\n  createRef = (paths: string[]) => {\n    return [\"#\", ...paths].join(\"/\");\n  };\n\n  parseRef = (ref: string) => {\n    return ref.split(\"/\");\n  };\n\n  createComponent(\n    $ref: string,\n    rawTypeData: SchemaComponent[\"rawTypeData\"],\n  ): SchemaComponent {\n    const parsed = this.parseRef($ref);\n    const typeName = parsed[parsed.length - 1]!;\n    const componentName = parsed[\n      parsed.length - 2\n    ] as SchemaComponent[\"componentName\"];\n    const componentSchema: SchemaComponent = {\n      $ref,\n      typeName,\n      rawTypeData,\n      componentName,\n      /** result from schema parser */\n      typeData: null,\n    };\n\n    const usageComponent =\n      this.config.hooks.onCreateComponent(componentSchema) || componentSchema;\n\n    const refIndex = this._data.findIndex((c) => c.$ref === $ref);\n\n    if (refIndex === -1) {\n      this._data.push(usageComponent);\n    } else {\n      this._data[refIndex] = usageComponent;\n    }\n\n    return usageComponent;\n  }\n\n  getComponents() {\n    return this._data;\n  }\n\n  filter(...componentNames: (string[] | string)[]) {\n    return this._data.filter((it) =>\n      componentNames.some((componentName) =>\n        it.$ref.startsWith(`#/components/${componentName}`),\n      ),\n    );\n  }\n\n  get = ($ref: string) => {\n    return this._data.find((c) => c.$ref === $ref) || null;\n  };\n\n  // Ensure enums are at the top of components list\n  enumsFirst() {\n    this._data.sort((a, b) => {\n      if (Object.keys(a.rawTypeData || {}).includes(\"enum\")) return -1;\n      if (Object.keys(b.rawTypeData || {}).includes(\"enum\")) return 1;\n      return 0;\n    });\n  }\n\n  // Ensure discriminators are at the top of components list\n  discriminatorsFirst() {\n    this._data.sort((a, b) => {\n      if (Object.keys(a.rawTypeData || {}).includes(\"discriminator\")) return -1;\n      if (Object.keys(b.rawTypeData || {}).includes(\"discriminator\")) return 1;\n      return 0;\n    });\n  }\n}\n","import lodash from \"lodash\";\nimport type { CodeGenConfig } from \"../configuration.js\";\nimport { SCHEMA_TYPES } from \"../constants.js\";\nimport type { TemplatesWorker } from \"../templates-worker.js\";\nimport type { SchemaParser } from \"./schema-parser.js\";\nimport type { SchemaParserFabric } from \"./schema-parser-fabric.js\";\nimport type { SchemaUtils } from \"./schema-utils.js\";\n\nexport class SchemaFormatters {\n  config: CodeGenConfig;\n  templatesWorker: TemplatesWorker;\n  schemaUtils: SchemaUtils;\n\n  constructor(schemaParser: SchemaParser | SchemaParserFabric) {\n    this.config = schemaParser.config;\n    this.schemaUtils = schemaParser.schemaUtils;\n    this.templatesWorker = schemaParser.templatesWorker;\n  }\n\n  base = {\n    [SCHEMA_TYPES.ENUM]: (parsedSchema) => {\n      if (this.config.generateUnionEnums) {\n        return {\n          ...parsedSchema,\n          $content: parsedSchema.content,\n          content: this.config.Ts.UnionType(\n            parsedSchema.content.map(({ value }) => value),\n          ),\n        };\n      }\n\n      return {\n        ...parsedSchema,\n        $content: parsedSchema.content,\n        content: this.config.Ts.EnumFieldsWrapper(parsedSchema.content),\n      };\n    },\n    [SCHEMA_TYPES.OBJECT]: (parsedSchema) => {\n      if (parsedSchema.nullable)\n        return this.inline[SCHEMA_TYPES.OBJECT](parsedSchema);\n      return {\n        ...parsedSchema,\n        $content: parsedSchema.content,\n        content: this.formatObjectContent(parsedSchema.content),\n      };\n    },\n    [SCHEMA_TYPES.PRIMITIVE]: (parsedSchema) => {\n      return {\n        ...parsedSchema,\n        $content: parsedSchema.content,\n      };\n    },\n  };\n  inline = {\n    [SCHEMA_TYPES.ENUM]: (parsedSchema) => {\n      return {\n        ...parsedSchema,\n        content: parsedSchema.$ref\n          ? parsedSchema.typeName\n          : this.config.Ts.UnionType(\n              lodash.compact([\n                ...parsedSchema.content.map(({ value }) => `${value}`),\n                parsedSchema.nullable && this.config.Ts.Keyword.Null,\n              ]),\n            ) || this.config.Ts.Keyword.Any,\n      };\n    },\n    [SCHEMA_TYPES.OBJECT]: (parsedSchema) => {\n      if (typeof parsedSchema.content === \"string\")\n        return {\n          ...parsedSchema,\n          typeIdentifier: this.config.Ts.Keyword.Type,\n          content: this.schemaUtils.safeAddNullToType(parsedSchema.content),\n        };\n\n      return {\n        ...parsedSchema,\n        typeIdentifier: this.config.Ts.Keyword.Type,\n        content: this.schemaUtils.safeAddNullToType(\n          parsedSchema,\n          parsedSchema.content.length\n            ? this.config.Ts.ObjectWrapper(\n                this.formatObjectContent(parsedSchema.content),\n              )\n            : this.config.Ts.RecordType(\n                this.config.Ts.Keyword.String,\n                this.config.Ts.Keyword.Any,\n              ),\n        ),\n      };\n    },\n  };\n\n  formatSchema = (\n    parsedSchema: Record<string, any>,\n    formatType: \"base\" | \"inline\" = \"base\",\n  ) => {\n    const schemaType =\n      lodash.get(parsedSchema, [\"schemaType\"]) ||\n      lodash.get(parsedSchema, [\"$parsed\", \"schemaType\"]);\n    const formatterFn = lodash.get(this, [formatType, schemaType]);\n    return formatterFn?.(parsedSchema) || parsedSchema;\n  };\n\n  formatDescription = (description, inline) => {\n    if (!description) return \"\";\n\n    const hasMultipleLines = description.includes(\"\\n\");\n\n    if (!hasMultipleLines) return description;\n\n    if (inline) {\n      return (\n        lodash\n          // @ts-expect-error TS(2339) FIXME: Property '_' does not exist on type 'LoDashStatic'... Remove this comment to see the full error message\n          ._(description)\n          .split(/\\n/g)\n          .map((part) => part.trim())\n          .compact()\n          .join(\" \")\n          .valueOf()\n      );\n    }\n\n    return description.replace(/\\n$/g, \"\");\n  };\n\n  formatObjectContent = (content) => {\n    const fields = [];\n\n    for (const part of content) {\n      const extraSpace = \"  \";\n      const result = `${extraSpace}${part.field},\\n`;\n\n      const renderedJsDoc = this.templatesWorker.renderTemplate(\n        this.config.templatesToRender.dataContractJsDoc,\n        {\n          data: part,\n        },\n      );\n\n      const routeNameFromTemplate = renderedJsDoc\n        .split(\"\\n\")\n        .map((c) => `${extraSpace}${c}`)\n        .join(\"\\n\");\n\n      if (routeNameFromTemplate) {\n        fields.push(`${routeNameFromTemplate}${result}`);\n      } else {\n        fields.push(`${result}`);\n      }\n    }\n\n    return fields.join(\"\");\n  };\n}\n","export const sortByProperty =\n  (propertyName: string) =>\n  (o1: Record<string, any>, o2: Record<string, any>): 1 | -1 | 0 => {\n    if (o1[propertyName] > o2[propertyName]) {\n      return 1;\n    }\n    if (o1[propertyName] < o2[propertyName]) {\n      return -1;\n    }\n    return 0;\n  };\n","import type { CodeGenConfig } from \"../configuration.js\";\nimport type { SchemaComponentsMap } from \"../schema-components-map.js\";\nimport type { TypeNameFormatter } from \"../type-name-formatter.js\";\nimport type { SchemaFormatters } from \"./schema-formatters.js\";\nimport type { SchemaParser } from \"./schema-parser.js\";\nimport type { SchemaParserFabric } from \"./schema-parser-fabric.js\";\nimport type { SchemaUtils } from \"./schema-utils.js\";\n\nexport class MonoSchemaParser {\n  schema;\n  typeName;\n  schemaPath;\n\n  schemaParser: SchemaParser;\n  schemaParserFabric: SchemaParserFabric;\n  typeNameFormatter: TypeNameFormatter;\n  schemaComponentsMap: SchemaComponentsMap;\n  schemaUtils: SchemaUtils;\n  config: CodeGenConfig;\n  schemaFormatters: SchemaFormatters;\n\n  constructor(\n    schemaParser: SchemaParser,\n    schema,\n    typeName = null,\n    schemaPath = [],\n  ) {\n    this.schemaParser = schemaParser;\n    this.schemaParserFabric = schemaParser.schemaParserFabric;\n    this.schema = schema;\n    this.typeName = typeName;\n    this.typeNameFormatter = schemaParser.typeNameFormatter;\n    this.schemaPath = schemaPath;\n    this.schemaComponentsMap = this.schemaParser.schemaComponentsMap;\n    this.schemaUtils = this.schemaParser.schemaUtils;\n    this.config = this.schemaParser.config;\n    this.schemaFormatters = this.schemaParser.schemaFormatters;\n  }\n\n  parse() {\n    throw new Error(\"not implemented\");\n  }\n\n  buildTypeNameFromPath = () => {\n    return this.schemaUtils.buildTypeNameFromPath(this.schemaPath);\n  };\n}\n","import { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class ArraySchemaParser extends MonoSchemaParser {\n  override parse() {\n    let contentType;\n    const { type, description, items } = this.schema || {};\n\n    if (Array.isArray(items) && type === SCHEMA_TYPES.ARRAY) {\n      const tupleContent = [];\n      for (const item of items) {\n        tupleContent.push(\n          this.schemaParserFabric\n            .createSchemaParser({ schema: item, schemaPath: this.schemaPath })\n            .getInlineParseContent(),\n        );\n      }\n      contentType = this.config.Ts.Tuple(tupleContent);\n    } else {\n      const content = this.schemaParserFabric\n        .createSchemaParser({ schema: items, schemaPath: this.schemaPath })\n        .getInlineParseContent();\n      contentType = this.config.Ts.ArrayType(content);\n    }\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $schemaPath: this.schemaPath.slice(),\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.PRIMITIVE,\n      type: SCHEMA_TYPES.PRIMITIVE,\n      typeIdentifier: this.config.Ts.Keyword.Type,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(description),\n      content: this.schemaUtils.safeAddNullToType(this.schema, contentType),\n    };\n  }\n}\n","import lodash from \"lodash\";\nimport { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class ComplexSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const complexType = this.schemaUtils.getComplexType(this.schema);\n    const simpleSchema = lodash.omit(\n      lodash.clone(this.schema),\n      lodash.keys(this.schemaParser._complexSchemaParsers),\n    );\n    const complexSchemaContent = this.schemaParser._complexSchemaParsers[\n      complexType\n    ](this.schema);\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $schemaPath: this.schemaPath.slice(),\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.COMPLEX,\n      type: SCHEMA_TYPES.PRIMITIVE,\n      typeIdentifier: this.config.Ts.Keyword.Type,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(\n        this.schema.description ||\n          lodash.compact(\n            lodash.map(this.schema[complexType], \"description\"),\n          )[0] ||\n          \"\",\n      ),\n      content:\n        this.config.Ts.IntersectionType(\n          lodash.compact([\n            this.config.Ts.ExpressionGroup(complexSchemaContent),\n            this.schemaUtils.getInternalSchemaType(simpleSchema) ===\n              SCHEMA_TYPES.OBJECT &&\n              this.config.Ts.ExpressionGroup(\n                this.schemaParserFabric\n                  .createSchemaParser({\n                    schema: simpleSchema,\n                    schemaPath: this.schemaPath,\n                  })\n                  .getInlineParseContent(),\n              ),\n          ]),\n        ) || this.config.Ts.Keyword.Any,\n    };\n  }\n}\n","import lodash from \"lodash\";\nimport { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class DiscriminatorSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const ts = this.config.Ts;\n    const { discriminator, ...noDiscriminatorSchema } = this.schema;\n\n    if (!discriminator.mapping) {\n      return this.schemaParserFabric\n        .createSchemaParser({\n          schema: noDiscriminatorSchema,\n          typeName: this.typeName,\n          schemaPath: this.schemaPath,\n        })\n        .parseSchema();\n    }\n\n    // https://github.com/acacode/swagger-typescript-api/issues/456\n    // const skipMappingType = !!noDiscriminatorSchema.oneOf;\n    const skipMappingType = false;\n\n    const abstractSchemaStruct = this.createAbstractSchemaStruct();\n    // const complexSchemaStruct = this.createComplexSchemaStruct();\n    const discriminatorSchemaStruct = this.createDiscriminatorSchema({\n      skipMappingType,\n      abstractSchemaStruct,\n    });\n\n    const schemaContent = ts.IntersectionType(\n      [\n        abstractSchemaStruct?.content,\n        discriminatorSchemaStruct?.content,\n      ].filter(Boolean),\n    );\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $schemaPath: this.schemaPath.slice(),\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.COMPLEX,\n      type: SCHEMA_TYPES.PRIMITIVE,\n      typeIdentifier: ts.Keyword.Type,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(\n        this.schema.description,\n      ),\n      content: schemaContent,\n    };\n  }\n\n  createDiscriminatorSchema = ({ skipMappingType, abstractSchemaStruct }) => {\n    const ts = this.config.Ts;\n\n    const refPath = this.schemaComponentsMap.createRef([\n      \"components\",\n      \"schemas\",\n      this.typeName,\n    ]);\n    const { discriminator } = this.schema;\n    const mappingEntries = lodash.entries(discriminator.mapping);\n    const ableToCreateMappingType =\n      !skipMappingType &&\n      !!(abstractSchemaStruct?.typeName && mappingEntries.length);\n    const mappingContents = [];\n    let mappingTypeName;\n\n    /** { mapping_key: SchemaEnum.MappingKey, ... } */\n    const mappingPropertySchemaEnumKeysMap =\n      this.createMappingPropertySchemaEnumKeys({\n        abstractSchemaStruct,\n        discPropertyName: discriminator.propertyName,\n      });\n\n    if (ableToCreateMappingType) {\n      const rawTypeName = `${abstractSchemaStruct.typeName}_${discriminator.propertyName}`;\n      const generatedTypeName = this.schemaUtils.resolveTypeName(rawTypeName, {\n        suffixes: this.config.extractingOptions.discriminatorMappingSuffix,\n        resolver:\n          this.config.extractingOptions.discriminatorMappingNameResolver,\n      });\n\n      const content = ts.IntersectionType([\n        ts.ObjectWrapper(\n          ts.TypeField({\n            key: ts.StringValue(discriminator.propertyName),\n            value: \"Key\",\n          }),\n        ),\n        \"Type\",\n      ]);\n\n      const component = this.schemaParserFabric.createParsedComponent({\n        typeName: generatedTypeName,\n        schema: {\n          type: \"object\",\n          properties: {},\n          genericArgs: [{ name: \"Key\" }, { name: \"Type\" }],\n          internal: true,\n        },\n      });\n\n      component.typeData.content = content;\n\n      mappingTypeName = this.typeNameFormatter.format(component.typeName);\n    }\n\n    /** returns (GenericType<\"mapping_key\", MappingType>) or ({ discriminatorProperty: \"mapping_key\" } & MappingType) */\n    const createMappingContent = (mappingSchema, mappingKey) => {\n      const content = this.schemaParserFabric\n        .createSchemaParser({\n          schema: mappingSchema,\n          schemaPath: this.schemaPath,\n        })\n        .getInlineParseContent();\n\n      const mappingUsageKey =\n        mappingPropertySchemaEnumKeysMap[mappingKey] ||\n        ts.StringValue(mappingKey);\n\n      if (ableToCreateMappingType) {\n        return ts.TypeWithGeneric(mappingTypeName, [mappingUsageKey, content]);\n      }\n\n      return ts.ExpressionGroup(\n        ts.IntersectionType([\n          ts.ObjectWrapper(\n            ts.TypeField({\n              key: discriminator.propertyName,\n              value: mappingUsageKey,\n            }),\n          ),\n          content,\n        ]),\n      );\n    };\n\n    for (const [mappingKey, schema] of mappingEntries) {\n      const mappingSchema =\n        typeof schema === \"string\" ? { $ref: schema } : schema;\n\n      this.mutateMappingDependentSchema({\n        discPropertyName: discriminator.propertyName,\n        abstractSchemaStruct,\n        mappingSchema,\n        refPath,\n        mappingPropertySchemaEnumKeysMap,\n      });\n\n      mappingContents.push(createMappingContent(mappingSchema, mappingKey));\n    }\n\n    if (skipMappingType) return null;\n\n    const content = ts.ExpressionGroup(ts.UnionType(mappingContents));\n\n    return {\n      content,\n    };\n  };\n\n  createMappingPropertySchemaEnumKeys = ({\n    abstractSchemaStruct,\n    discPropertyName,\n  }) => {\n    const ts = this.config.Ts;\n\n    let mappingPropertySchemaEnumKeysMap = {};\n    let mappingPropertySchema = lodash.get(\n      abstractSchemaStruct?.component?.rawTypeData,\n      [\"properties\", discPropertyName],\n    );\n    if (this.schemaUtils.isRefSchema(mappingPropertySchema)) {\n      mappingPropertySchema = this.schemaUtils.getSchemaRefType(\n        mappingPropertySchema,\n      );\n    }\n\n    const parsedEnum = mappingPropertySchema?.rawTypeData?.$parsed;\n    if (parsedEnum?.type === SCHEMA_TYPES.ENUM) {\n      mappingPropertySchemaEnumKeysMap = lodash.reduce(\n        parsedEnum.enum,\n        (acc, key, index) => {\n          const enumContent = parsedEnum.content?.[index];\n          if (this.config.generateUnionEnums) {\n            const literalValue =\n              enumContent?.value ??\n              (key !== undefined ? ts.StringValue(key) : undefined);\n            if (literalValue !== undefined) {\n              acc[key] = literalValue;\n            }\n          } else if (parsedEnum.typeName && enumContent?.key) {\n            acc[key] = ts.EnumUsageKey(parsedEnum.typeName, enumContent.key);\n          }\n          return acc;\n        },\n        {},\n      );\n    }\n\n    return mappingPropertySchemaEnumKeysMap;\n  };\n\n  mutateMappingDependentSchema = ({\n    discPropertyName,\n    abstractSchemaStruct,\n    mappingSchema,\n    refPath,\n    mappingPropertySchemaEnumKeysMap,\n  }) => {\n    const complexSchemaKeys = lodash.keys(\n      this.schemaParser._complexSchemaParsers,\n    );\n    // override parent dependencies\n    if (mappingSchema.$ref && abstractSchemaStruct?.component?.$ref) {\n      const mappingRefSchema =\n        this.schemaUtils.getSchemaRefType(mappingSchema)?.rawTypeData;\n      if (mappingRefSchema) {\n        for (const schemaKey of complexSchemaKeys) {\n          if (Array.isArray(mappingRefSchema[schemaKey])) {\n            mappingRefSchema[schemaKey] = mappingRefSchema[schemaKey].map(\n              (schema) => {\n                if (schema.$ref === refPath) {\n                  return {\n                    ...schema,\n                    $ref: abstractSchemaStruct.component.$ref,\n                  };\n                }\n                if (\n                  this.schemaUtils.getInternalSchemaType(schema) ===\n                  SCHEMA_TYPES.OBJECT\n                ) {\n                  for (const schemaPropertyName in schema.properties) {\n                    const schemaProperty =\n                      schema.properties[schemaPropertyName];\n                    if (\n                      schemaPropertyName === discPropertyName &&\n                      this.schemaUtils.getInternalSchemaType(schemaProperty) ===\n                        SCHEMA_TYPES.ENUM &&\n                      schemaProperty.enum.length === 1 &&\n                      mappingPropertySchemaEnumKeysMap[schemaProperty.enum[0]]\n                    ) {\n                      schema.properties[schemaPropertyName] =\n                        this.schemaParserFabric.createSchema({\n                          content:\n                            mappingPropertySchemaEnumKeysMap[\n                              schemaProperty.enum[0]\n                            ],\n                        });\n                    }\n                  }\n                }\n                return schema;\n              },\n            );\n          }\n        }\n      }\n    }\n  };\n\n  createAbstractSchemaStruct = () => {\n    const { discriminator, ...noDiscriminatorSchema } = this.schema;\n    const complexSchemaKeys = lodash.keys(\n      this.schemaParser._complexSchemaParsers,\n    );\n    const schema = lodash.omit(\n      structuredClone(noDiscriminatorSchema),\n      complexSchemaKeys,\n    );\n    const schemaIsAny =\n      this.schemaParserFabric.getInlineParseContent(structuredClone(schema)) ===\n      this.config.Ts.Keyword.Any;\n    const schemaIsEmpty = !lodash.keys(schema).length;\n\n    if (schemaIsEmpty || schemaIsAny) return null;\n\n    const typeName = this.schemaUtils.resolveTypeName(this.typeName, {\n      prefixes: this.config.extractingOptions.discriminatorAbstractPrefix,\n      resolver: this.config.extractingOptions.discriminatorAbstractResolver,\n    });\n    const component = this.schemaComponentsMap.createComponent(\n      this.schemaComponentsMap.createRef([\"components\", \"schemas\", typeName]),\n      {\n        ...schema,\n        internal: true,\n      },\n    );\n    const content = this.schemaParserFabric\n      .createSchemaParser({ schema: component, schemaPath: this.schemaPath })\n      .getInlineParseContent();\n\n    return {\n      typeName,\n      component,\n      content,\n    };\n  };\n\n  createComplexSchemaStruct = () => {\n    const ts = this.config.Ts;\n    const complexType = this.schemaUtils.getComplexType(this.schema);\n\n    if (complexType === SCHEMA_TYPES.COMPLEX_UNKNOWN) return null;\n\n    return {\n      content: ts.ExpressionGroup(\n        this.schemaParser._complexSchemaParsers[complexType](this.schema),\n      ),\n    };\n  };\n}\n","import { consola } from \"consola\";\nimport type { CodeGenConfig } from \"../../configuration.js\";\nimport { NameResolver } from \"../../util/name-resolver.js\";\n\nexport class EnumKeyResolver extends NameResolver {\n  counter = 1;\n  constructor(config: CodeGenConfig, reservedNames: string[]) {\n    super(config, reservedNames, (variants) => {\n      const generatedVariant =\n        (variants[0] && `${variants[0]}${this.counter++}`) ||\n        `${this.config.enumKeyResolverName}${this.counter++}`;\n      consola.debug(\n        \"generated fallback type name for enum key - \",\n        generatedVariant,\n      );\n      return generatedVariant;\n    });\n  }\n}\n","import lodash from \"lodash\";\nimport { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\nimport { EnumKeyResolver } from \"../util/enum-key-resolver.js\";\n\nexport class EnumSchemaParser extends MonoSchemaParser {\n  enumKeyResolver: EnumKeyResolver;\n\n  constructor(...args) {\n    // @ts-expect-error TS(2556) FIXME: A spread argument must either have a tuple type or... Remove this comment to see the full error message\n    super(...args);\n    this.enumKeyResolver = new EnumKeyResolver(this.config, []);\n  }\n\n  extractEnum = (pathTypeName) => {\n    const generatedTypeName = this.schemaUtils.resolveTypeName(pathTypeName, {\n      suffixes: this.config.extractingOptions.enumSuffix,\n      resolver: this.config.extractingOptions.enumNameResolver,\n    });\n    const customComponent = this.schemaComponentsMap.createComponent(\n      this.schemaComponentsMap.createRef([\n        \"components\",\n        \"schemas\",\n        generatedTypeName,\n      ]),\n      {\n        ...this.schema,\n      },\n    );\n    return this.schemaParserFabric.parseSchema(customComponent);\n  };\n\n  override parse() {\n    const pathTypeName = this.buildTypeNameFromPath();\n\n    if (this.config.extractEnums && !this.typeName && pathTypeName != null) {\n      return this.extractEnum(pathTypeName);\n    }\n\n    const refType = this.schemaUtils.getSchemaRefType(this.schema);\n    const $ref = refType?.$ref || null;\n\n    // fix schema when enum has length 1+ but value is []\n    if (Array.isArray(this.schema.enum)) {\n      this.schema.enum = this.schema.enum.filter((key) => key != null);\n    }\n\n    if (Array.isArray(this.schema.enum) && Array.isArray(this.schema.enum[0])) {\n      return this.schemaParserFabric.parseSchema(\n        {\n          oneOf: this.schema.enum.map((enumNames) => ({\n            type: \"array\",\n            items: enumNames.map((enumName) => ({\n              type: \"string\",\n              enum: [enumName],\n            })),\n          })),\n        },\n        this.typeName,\n        this.schemaPath,\n      );\n    }\n\n    const keyType = this.schemaUtils.getSchemaType(this.schema);\n    const enumNames = this.schemaUtils.getEnumNames(this.schema);\n    const enumDescriptions = this.schemaUtils.getEnumDescriptions(this.schema);\n\n    let content = null;\n\n    const formatValue = (value) => {\n      if (value === null) {\n        return this.config.Ts.NullValue(value);\n      }\n\n      if (\n        keyType.includes(this.schemaUtils.getSchemaType({ type: \"number\" }))\n      ) {\n        const maybeNumber = typeof value === \"number\" ? value : Number(value);\n        if (!Number.isNaN(maybeNumber)) {\n          return this.config.Ts.NumberValue(maybeNumber);\n        }\n      }\n\n      if (\n        keyType.includes(this.schemaUtils.getSchemaType({ type: \"boolean\" }))\n      ) {\n        if (typeof value === \"boolean\") {\n          return this.config.Ts.BooleanValue(value);\n        }\n        if (value === \"true\" || value === \"false\") {\n          return this.config.Ts.BooleanValue(value === \"true\");\n        }\n      }\n\n      switch (typeof value) {\n        case \"number\":\n          return this.config.Ts.NumberValue(value);\n        case \"boolean\":\n          return this.config.Ts.BooleanValue(value);\n        default:\n          return this.config.Ts.StringValue(value);\n      }\n    };\n\n    if (Array.isArray(enumNames) && lodash.size(enumNames)) {\n      content = enumNames.map((enumName, index) => {\n        const enumValue = lodash.get(this.schema.enum, index);\n        const formattedKey = this.formatEnumKey({\n          key: enumName,\n          value: enumValue,\n        });\n\n        if (this.config.enumNamesAsValues || enumValue === undefined) {\n          return {\n            key: formattedKey,\n            type: this.config.Ts.Keyword.String,\n            value: this.config.Ts.StringValue(enumName),\n            description: enumDescriptions?.[index],\n          };\n        }\n\n        return {\n          key: formattedKey,\n          type: keyType,\n          value: formatValue(enumValue),\n          description: enumDescriptions?.[index],\n        };\n      });\n    } else {\n      content = this.schema.enum.map((value, index) => {\n        return {\n          // @ts-expect-error TS(2345) FIXME: Argument of type '{ value: any; }' is not assignab... Remove this comment to see the full error message\n          key: this.formatEnumKey({ value }),\n          type: keyType,\n          value: formatValue(value),\n          description: enumDescriptions?.[index],\n        };\n      });\n    }\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $ref: $ref,\n      typeName: this.typeName || ($ref && refType.typeName) || null,\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.ENUM,\n      type: SCHEMA_TYPES.ENUM,\n      keyType: keyType,\n      typeIdentifier: this.config.generateUnionEnums\n        ? this.config.Ts.Keyword.Type\n        : this.config.Ts.Keyword.Enum,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(\n        this.schema.description,\n      ),\n      content,\n    };\n  }\n\n  formatEnumKey = ({ key, value }) => {\n    let formatted: string | undefined;\n\n    if (key) {\n      formatted = this.typeNameFormatter.format(key, {\n        type: \"enum-key\",\n      });\n    }\n\n    if (!formatted) {\n      formatted = this.typeNameFormatter.format(`${value}`, {\n        type: \"enum-key\",\n      });\n    }\n\n    return this.enumKeyResolver.resolve([formatted]);\n  };\n}\n","import lodash from \"lodash\";\nimport { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class ObjectSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const contentProperties = this.getObjectSchemaContent(this.schema);\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $schemaPath: this.schemaPath.slice(),\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.OBJECT,\n      type: SCHEMA_TYPES.OBJECT,\n      typeIdentifier: this.config.Ts.Keyword.Interface,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(\n        this.schema.description,\n      ),\n      allFieldsAreOptional: !contentProperties.some((part) => part.isRequired),\n      content: contentProperties,\n    };\n  }\n\n  getObjectSchemaContent = (schema) => {\n    const { properties, additionalProperties } = schema || {};\n\n    const propertiesContent = lodash.map(properties, (property, name) => {\n      const required = this.schemaUtils.isPropertyRequired(\n        name,\n        property,\n        schema,\n      );\n      const rawTypeData = lodash.get(\n        this.schemaUtils.getSchemaRefType(property),\n        \"rawTypeData\",\n        {},\n      );\n      const nullable = !!(rawTypeData.nullable || property.nullable);\n      const fieldName = this.typeNameFormatter.isValidName(name)\n        ? name\n        : this.config.Ts.StringValue(name);\n      const fieldValue = this.schemaParserFabric\n        .createSchemaParser({\n          schema: property,\n          schemaPath: [...this.schemaPath, name],\n        })\n        .getInlineParseContent();\n      const readOnly = property.readOnly;\n\n      return {\n        ...property,\n        $$raw: property,\n        title: property.title,\n        description:\n          property.description ||\n          lodash.compact(\n            lodash.map(\n              property[this.schemaUtils.getComplexType(property)],\n              \"description\",\n            ),\n          )[0] ||\n          rawTypeData.description ||\n          lodash.compact(\n            lodash.map(\n              rawTypeData[this.schemaUtils.getComplexType(rawTypeData)],\n              \"description\",\n            ),\n          )[0] ||\n          \"\",\n        isRequired: required,\n        isNullable: nullable,\n        name: fieldName,\n        value: fieldValue,\n        field: this.config.Ts.TypeField({\n          readonly: readOnly && this.config.addReadonly,\n          optional: !required,\n          key: fieldName,\n          value: fieldValue,\n        }),\n      };\n    });\n\n    if (additionalProperties) {\n      const propertyNamesSchema =\n        this.schemaUtils.getSchemaPropertyNamesSchema(schema);\n      let interfaceKeysContent: any;\n\n      if (propertyNamesSchema) {\n        interfaceKeysContent = this.schemaParserFabric\n          .createSchemaParser({\n            schema: propertyNamesSchema,\n            schemaPath: this.schemaPath,\n          })\n          .getInlineParseContent();\n      } else {\n        interfaceKeysContent = this.config.Ts.Keyword.String;\n      }\n\n      propertiesContent.push({\n        $$raw: { additionalProperties },\n        description: \"\",\n        isRequired: false,\n        field: this.config.Ts.InterfaceDynamicField(\n          interfaceKeysContent,\n          this.config.Ts.Keyword.Any,\n        ),\n      });\n    }\n\n    return propertiesContent;\n  };\n}\n","import { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class PrimitiveSchemaParser extends MonoSchemaParser {\n  override parse() {\n    let contentType = null;\n    const { additionalProperties, type, description, items } =\n      this.schema || {};\n\n    if (type === this.config.Ts.Keyword.Object && additionalProperties) {\n      const propertyNamesSchema = this.schemaUtils.getSchemaPropertyNamesSchema(\n        this.schema,\n      );\n\n      let recordKeysContent: any;\n      let recordValuesContent: any;\n\n      if (propertyNamesSchema) {\n        recordKeysContent = this.schemaParserFabric\n          .createSchemaParser({\n            schema: propertyNamesSchema,\n            schemaPath: this.schemaPath,\n          })\n          .getInlineParseContent();\n      } else {\n        recordKeysContent = this.config.Ts.Keyword.String;\n      }\n\n      if (typeof additionalProperties === \"object\") {\n        recordValuesContent = this.schemaParserFabric\n          .createSchemaParser({\n            schema: additionalProperties,\n            schemaPath: this.schemaPath,\n          })\n          .getInlineParseContent();\n      } else {\n        recordValuesContent = this.config.Ts.Keyword.Any;\n      }\n\n      contentType = this.config.Ts.RecordType(\n        recordKeysContent,\n        recordValuesContent,\n      );\n    }\n\n    if (Array.isArray(type) && type.length) {\n      contentType = this.schemaParser._complexSchemaParsers.oneOf({\n        ...(typeof this.schema === \"object\" ? this.schema : {}),\n        oneOf: type.map((type) => ({ type })),\n      });\n    }\n\n    if (Array.isArray(items) && type === SCHEMA_TYPES.ARRAY) {\n      contentType = this.config.Ts.Tuple(\n        items.map((item) =>\n          this.schemaParserFabric\n            .createSchemaParser({ schema: item, schemaPath: this.schemaPath })\n            .getInlineParseContent(),\n        ),\n      );\n    }\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $schemaPath: this.schemaPath.slice(),\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.PRIMITIVE,\n      type: SCHEMA_TYPES.PRIMITIVE,\n      typeIdentifier: this.config.Ts.Keyword.Type,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(description),\n      // TODO: probably it should be refactored. `type === 'null'` is not flexible\n      content:\n        type === this.config.Ts.Keyword.Null\n          ? type\n          : contentType || this.schemaUtils.getSchemaType(this.schema),\n    };\n  }\n}\n","import { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\n// T1 & T2\nexport class AllOfSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const ignoreTypes = [this.config.Ts.Keyword.Any];\n    const combined = this.schema.allOf.map((childSchema) =>\n      this.schemaParserFabric.getInlineParseContent(\n        this.schemaUtils.makeAddRequiredToChildSchema(this.schema, childSchema),\n        null,\n        this.schemaPath,\n      ),\n    );\n    const filtered = this.schemaUtils.filterSchemaContents(\n      combined,\n      (content) => !ignoreTypes.includes(content),\n    );\n\n    const type = this.config.Ts.IntersectionType(filtered);\n\n    return this.schemaUtils.safeAddNullToType(this.schema, type);\n  }\n}\n","import { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\n// T1 | T2\nexport class AnyOfSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const ignoreTypes = [this.config.Ts.Keyword.Any];\n    const combined = this.schema.anyOf.map((childSchema) =>\n      this.schemaParserFabric.getInlineParseContent(\n        this.schemaUtils.makeAddRequiredToChildSchema(this.schema, childSchema),\n        null,\n        this.schemaPath,\n      ),\n    );\n\n    const filtered = this.schemaUtils.filterSchemaContents(\n      combined,\n      (content) => !ignoreTypes.includes(content),\n    );\n\n    const type = this.config.Ts.UnionType(filtered);\n\n    return this.schemaUtils.safeAddNullToType(this.schema, type);\n  }\n}\n","import { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class NotSchemaParser extends MonoSchemaParser {\n  override parse() {\n    return this.config.Ts.Keyword.Any;\n  }\n}\n","import { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\n// T1 | T2\nexport class OneOfSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const ignoreTypes = [this.config.Ts.Keyword.Any];\n    const combined = this.schema.oneOf.map((childSchema) =>\n      this.schemaParserFabric.getInlineParseContent(\n        this.schemaUtils.makeAddRequiredToChildSchema(this.schema, childSchema),\n        null,\n        this.schemaPath,\n      ),\n    );\n\n    const filtered = this.schemaUtils.filterSchemaContents(\n      combined,\n      (content) => !ignoreTypes.includes(content),\n    );\n\n    const type = this.config.Ts.UnionType(filtered);\n\n    return this.schemaUtils.safeAddNullToType(this.schema, type);\n  }\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport type { CodeGenConfig } from \"../configuration.js\";\nimport { SCHEMA_TYPES } from \"../constants.js\";\nimport type { SchemaComponentsMap } from \"../schema-components-map.js\";\nimport type { SchemaWalker } from \"../schema-walker.js\";\nimport type { TemplatesWorker } from \"../templates-worker.js\";\nimport type { TypeNameFormatter } from \"../type-name-formatter.js\";\nimport { sortByProperty } from \"../util/sort-by-property.js\";\nimport { ArraySchemaParser } from \"./base-schema-parsers/array.js\";\nimport { ComplexSchemaParser } from \"./base-schema-parsers/complex.js\";\nimport { DiscriminatorSchemaParser } from \"./base-schema-parsers/discriminator.js\";\nimport { EnumSchemaParser } from \"./base-schema-parsers/enum.js\";\nimport { ObjectSchemaParser } from \"./base-schema-parsers/object.js\";\nimport { PrimitiveSchemaParser } from \"./base-schema-parsers/primitive.js\";\nimport { AllOfSchemaParser } from \"./complex-schema-parsers/all-of.js\";\nimport { AnyOfSchemaParser } from \"./complex-schema-parsers/any-of.js\";\nimport { NotSchemaParser } from \"./complex-schema-parsers/not.js\";\nimport { OneOfSchemaParser } from \"./complex-schema-parsers/one-of.js\";\nimport type { SchemaFormatters } from \"./schema-formatters.js\";\nimport type { SchemaParserFabric } from \"./schema-parser-fabric.js\";\nimport type { SchemaUtils } from \"./schema-utils.js\";\n\nexport class SchemaParser {\n  schemaParserFabric: SchemaParserFabric;\n  config: CodeGenConfig;\n  schemaComponentsMap: SchemaComponentsMap;\n  typeNameFormatter: TypeNameFormatter;\n  schemaFormatters: SchemaFormatters;\n  schemaUtils: SchemaUtils;\n  templatesWorker: TemplatesWorker;\n  schemaWalker: SchemaWalker;\n\n  typeName;\n  schema;\n  schemaPath = [];\n\n  // @ts-expect-error TS(2525) FIXME: Initializer provides no value for this binding ele... Remove this comment to see the full error message\n  constructor(schemaParserFabric, { typeName, schema, schemaPath } = {}) {\n    this.schemaParserFabric = schemaParserFabric;\n    this.config = schemaParserFabric.config;\n    this.templatesWorker = schemaParserFabric.templatesWorker;\n    this.schemaComponentsMap = schemaParserFabric.schemaComponentsMap;\n    this.typeNameFormatter = schemaParserFabric.typeNameFormatter;\n    this.schemaWalker = schemaParserFabric.schemaWalker;\n    this.schemaFormatters = schemaParserFabric.schemaFormatters;\n    this.schemaUtils = schemaParserFabric.schemaUtils;\n\n    this.typeName = typeName || null;\n    this.schema = schema;\n    this.schemaPath = [...(schemaPath || [])];\n  }\n\n  _complexSchemaParsers = {\n    [SCHEMA_TYPES.COMPLEX_ONE_OF]: (schema) => {\n      const SchemaParser =\n        this.config.schemaParsers.complexOneOf || OneOfSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        null,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.COMPLEX_ALL_OF]: (schema) => {\n      const SchemaParser =\n        this.config.schemaParsers.complexAllOf || AllOfSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        null,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.COMPLEX_ANY_OF]: (schema) => {\n      const SchemaParser =\n        this.config.schemaParsers.complexAnyOf || AnyOfSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        null,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.COMPLEX_NOT]: (schema) => {\n      const SchemaParser =\n        this.config.schemaParsers.complexNot || NotSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        null,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n  };\n\n  _baseSchemaParsers = {\n    [SCHEMA_TYPES.ENUM]: (schema, typeName) => {\n      const SchemaParser = this.config.schemaParsers.enum || EnumSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.OBJECT]: (schema, typeName) => {\n      const SchemaParser =\n        this.config.schemaParsers.object || ObjectSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.COMPLEX]: (schema, typeName) => {\n      const SchemaParser =\n        this.config.schemaParsers.complex || ComplexSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.PRIMITIVE]: (schema, typeName) => {\n      const SchemaParser =\n        this.config.schemaParsers.primitive || PrimitiveSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.DISCRIMINATOR]: (schema, typeName) => {\n      const SchemaParser =\n        this.config.schemaParsers.discriminator || DiscriminatorSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.ARRAY]: (schema, typeName) => {\n      const SchemaParser = this.config.schemaParsers.array || ArraySchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n  };\n\n  parseSchema = () => {\n    if (!this.schema)\n      return this._baseSchemaParsers[SCHEMA_TYPES.PRIMITIVE](\n        null,\n        this.typeName,\n      );\n\n    let schemaType = null;\n    let parsedSchema = null;\n\n    if (typeof this.schema === \"string\") {\n      return this.schema;\n    }\n\n    if (!this.schema.$parsed) {\n      if (!this.typeName && this.schemaUtils.isRefSchema(this.schema)) {\n        this.typeName = this.schemaUtils.getSchemaType(this.schema);\n      }\n\n      //#region swagger schemas fixes\n\n      // schema has items but don't have array type\n      if (\n        this.schema.items &&\n        !Array.isArray(this.schema.items) &&\n        !this.schema.type\n      ) {\n        this.schema.type = SCHEMA_TYPES.ARRAY;\n      }\n      // schema is enum with one null value\n      if (\n        Array.isArray(this.schema.enum) &&\n        this.schema.enum.length === 1 &&\n        this.schema.enum[0] == null\n      ) {\n        consola.debug(\"invalid enum schema\", this.schema);\n        this.schema = { type: this.config.Ts.Keyword.Null };\n      }\n      // schema is response schema\n      if (\"content\" in this.schema && typeof this.schema.content === \"object\") {\n        const schema = this.extractSchemaFromResponseStruct(this.schema);\n        const schemaParser = this.schemaParserFabric.createSchemaParser({\n          schema,\n          typeName: this.typeName,\n          schemaPath: this.schemaPath,\n        });\n        this.schema.$parsed = schemaParser.parseSchema();\n        return this.schema.$parsed;\n      }\n\n      //#endregion\n\n      schemaType = this.schemaUtils.getInternalSchemaType(this.schema);\n\n      this.schemaPath.push(this.typeName);\n\n      lodash.merge(\n        this.schema,\n        this.config.hooks.onPreParseSchema(\n          this.schema,\n          this.typeName,\n          schemaType,\n        ),\n      );\n      parsedSchema = this._baseSchemaParsers[schemaType](\n        this.schema,\n        this.typeName,\n      );\n      this.schema.$parsed =\n        this.config.hooks.onParseSchema(this.schema, parsedSchema) ||\n        parsedSchema;\n\n      if (\n        this.config.sortTypes &&\n        Array.isArray(this.schema.$parsed?.content)\n      ) {\n        this.schema.$parsed.content = this.schema.$parsed.content.sort(\n          sortByProperty(\"name\"),\n        );\n      }\n    }\n\n    this.schemaPath.pop();\n\n    return this.schema.$parsed;\n  };\n\n  getInlineParseContent = () => {\n    const parsedSchema = this.parseSchema();\n    const formattedSchema = this.schemaFormatters.formatSchema(\n      parsedSchema,\n      \"inline\",\n    );\n    return formattedSchema.content;\n  };\n\n  getParseContent = () => {\n    const parsedSchema = this.parseSchema();\n    const formattedSchema = this.schemaFormatters.formatSchema(\n      parsedSchema,\n      \"base\",\n    );\n    return formattedSchema.content;\n  };\n\n  extractSchemaFromResponseStruct = (responseStruct) => {\n    const { content, ...extras } = responseStruct;\n\n    const firstResponse = lodash.first(lodash.values(content));\n    const firstSchema = lodash.get(firstResponse, \"schema\");\n\n    if (!firstSchema) return;\n\n    return {\n      ...extras,\n      ...lodash.omit(firstResponse, \"schema\"),\n      ...firstSchema,\n    };\n  };\n}\n","import lodash from \"lodash\";\n\nexport function internalCase(value: string) {\n  return lodash.camelCase(lodash.lowerCase(value));\n}\n","import lodash from \"lodash\";\n\nexport function pascalCase(value: string) {\n  return lodash.upperFirst(lodash.camelCase(value));\n}\n","import lodash from \"lodash\";\nimport type { CodeGenConfig } from \"../configuration.js\";\nimport { SCHEMA_TYPES } from \"../constants.js\";\nimport type { SchemaComponentsMap } from \"../schema-components-map.js\";\nimport type { SchemaWalker } from \"../schema-walker.js\";\nimport type { TypeNameFormatter } from \"../type-name-formatter.js\";\nimport { internalCase } from \"../util/internal-case.js\";\nimport { pascalCase } from \"../util/pascal-case.js\";\n\nexport class SchemaUtils {\n  config: CodeGenConfig;\n  schemaComponentsMap: SchemaComponentsMap;\n  typeNameFormatter: TypeNameFormatter;\n  schemaWalker: SchemaWalker;\n\n  constructor({\n    config,\n    schemaComponentsMap,\n    typeNameFormatter,\n    schemaWalker,\n  }) {\n    this.config = config;\n    this.schemaComponentsMap = schemaComponentsMap;\n    this.typeNameFormatter = typeNameFormatter;\n    this.schemaWalker = schemaWalker;\n  }\n\n  getRequiredProperties = (schema) => {\n    return lodash.uniq(\n      (schema && Array.isArray(schema.required) && schema.required) || [],\n    );\n  };\n\n  isRefSchema = (schema) => {\n    return !!schema?.$ref;\n  };\n\n  getEnumNames = (schema) => {\n    return (\n      schema[\"x-enumNames\"] ||\n      schema.xEnumNames ||\n      schema[\"x-enumnames\"] ||\n      schema[\"x-enum-varnames\"]\n    );\n  };\n\n  getEnumDescriptions = (schema) => {\n    return (\n      schema[\"x-enumDescriptions\"] ||\n      schema.xEnumDescriptions ||\n      schema[\"x-enumdescriptions\"] ||\n      schema[\"x-enum-descriptions\"]\n    );\n  };\n\n  getSchemaPropertyNamesSchema = (schema) => {\n    if (!schema) return null;\n    return schema.propertyNames || schema[\"x-propertyNames\"] || null;\n  };\n\n  getSchemaRefType = (schema) => {\n    if (!this.isRefSchema(schema)) return null;\n    return this.schemaComponentsMap.get(schema.$ref);\n  };\n\n  isPropertyRequired = (name, propertySchema, rootSchema) => {\n    if (propertySchema[\"x-omitempty\"] === false) {\n      return true;\n    }\n\n    const isRequired =\n      typeof propertySchema.required === \"boolean\"\n        ? !!propertySchema.required\n        : Array.isArray(rootSchema.required)\n          ? rootSchema.required.includes(name)\n          : !!rootSchema.required;\n\n    if (this.config.convertedFromSwagger2) {\n      return typeof propertySchema.nullable === this.config.Ts.Keyword.Undefined\n        ? isRequired\n        : !propertySchema.nullable;\n    }\n    return isRequired;\n  };\n\n  isNullMissingInType = (schema, type) => {\n    const { nullable, type: schemaType } = schema || {};\n    return (\n      (nullable ||\n        !!lodash.get(schema, \"x-nullable\") ||\n        schemaType === this.config.Ts.Keyword.Null) &&\n      typeof type === \"string\" &&\n      !type.includes(` ${this.config.Ts.Keyword.Null}`) &&\n      !type.includes(`${this.config.Ts.Keyword.Null} `)\n    );\n  };\n\n  safeAddNullToType = (schema, type) => {\n    if (this.isNullMissingInType(schema, type)) {\n      return this.config.Ts.UnionType([type, this.config.Ts.Keyword.Null]);\n    }\n    return type;\n  };\n\n  getSchemaPrimitiveType = (rawSchema) => {\n    const schema = rawSchema || {};\n\n    if (schema.type) {\n      return internalCase(schema.type);\n    }\n    if (schema.enum) {\n      const enumFieldType = typeof schema.enum[0];\n      if (enumFieldType === this.config.Ts.Keyword.Undefined) return;\n\n      return internalCase(enumFieldType);\n    }\n    if (lodash.keys(schema.properties).length) {\n      return SCHEMA_TYPES.OBJECT;\n    }\n    if (schema.items) {\n      return SCHEMA_TYPES.ARRAY;\n    }\n\n    return null;\n  };\n\n  checkAndAddRequiredKeys = (schema, resultType) => {\n    if (\"$$requiredKeys\" in schema && schema.$$requiredKeys.length) {\n      this.config.update({\n        internalTemplateOptions: {\n          addUtilRequiredKeysType: true,\n        },\n      });\n      return this.config.Ts.TypeWithGeneric(\n        this.config.Ts.CodeGenKeyword.UtilRequiredKeys,\n        [\n          resultType,\n          this.config.Ts.UnionType(\n            schema.$$requiredKeys.map(this.config.Ts.StringValue),\n          ),\n        ],\n      );\n    }\n\n    return resultType;\n  };\n\n  makeAddRequiredToChildSchema = (parentSchema, childSchema) => {\n    if (!childSchema) return childSchema;\n\n    const required = lodash.uniq([\n      ...this.getRequiredProperties(parentSchema),\n      ...this.getRequiredProperties(childSchema),\n    ]);\n\n    const refData = this.getSchemaRefType(childSchema);\n\n    if (refData) {\n      const refObjectProperties = lodash.keys(\n        refData.rawTypeData?.properties || {},\n      );\n      const existedRequiredKeys = refObjectProperties.filter((key) =>\n        required.includes(key),\n      );\n\n      if (!existedRequiredKeys.length) return childSchema;\n\n      return {\n        ...childSchema,\n        $$requiredKeys: existedRequiredKeys,\n      };\n    }\n\n    if (childSchema.properties) {\n      const childSchemaProperties = lodash.keys(childSchema.properties);\n      const existedRequiredKeys = childSchemaProperties.filter((key) =>\n        required.includes(key),\n      );\n\n      if (!existedRequiredKeys.length) return childSchema;\n\n      return {\n        required: lodash.uniq([\n          ...this.getRequiredProperties(childSchema),\n          ...existedRequiredKeys,\n        ]),\n        ...childSchema,\n      };\n    }\n\n    return childSchema;\n  };\n\n  filterSchemaContents = (contents, filterFn) => {\n    return lodash.uniq(contents.filter((type) => filterFn(type)));\n  };\n\n  resolveTypeName = (\n    typeName,\n    { suffixes, resolver, prefixes, shouldReserve = true },\n  ) => {\n    if (resolver) {\n      return this.config.componentTypeNameResolver.resolve([], (reserved) => {\n        return resolver(pascalCase(typeName), reserved);\n      });\n    }\n\n    return this.config.componentTypeNameResolver.resolve(\n      [\n        ...(prefixes || []).map((prefix) =>\n          pascalCase(`${prefix} ${typeName}`),\n        ),\n        ...(suffixes || []).map((suffix) =>\n          pascalCase(`${typeName} ${suffix}`),\n        ),\n      ],\n      shouldReserve,\n    );\n  };\n\n  getComplexType = (schema) => {\n    if (schema.oneOf) return SCHEMA_TYPES.COMPLEX_ONE_OF;\n    if (schema.allOf) return SCHEMA_TYPES.COMPLEX_ALL_OF;\n    if (schema.anyOf) return SCHEMA_TYPES.COMPLEX_ANY_OF;\n    // TODO :(\n    if (schema.not) return SCHEMA_TYPES.COMPLEX_NOT;\n\n    return SCHEMA_TYPES.COMPLEX_UNKNOWN;\n  };\n\n  getInternalSchemaType = (schema) => {\n    if (\n      !lodash.isEmpty(schema.enum) ||\n      !lodash.isEmpty(this.getEnumNames(schema))\n    ) {\n      return SCHEMA_TYPES.ENUM;\n    }\n    if (schema.discriminator) {\n      return SCHEMA_TYPES.DISCRIMINATOR;\n    }\n    if (schema.allOf || schema.oneOf || schema.anyOf || schema.not) {\n      return SCHEMA_TYPES.COMPLEX;\n    }\n    if (!lodash.isEmpty(schema.properties)) {\n      return SCHEMA_TYPES.OBJECT;\n    }\n    if (schema.type === SCHEMA_TYPES.ARRAY) {\n      return SCHEMA_TYPES.ARRAY;\n    }\n\n    return SCHEMA_TYPES.PRIMITIVE;\n  };\n\n  getSchemaType = (schema) => {\n    if (!schema) return this.config.Ts.Keyword.Any;\n\n    const refTypeInfo = this.getSchemaRefType(schema);\n\n    if (refTypeInfo) {\n      return this.checkAndAddRequiredKeys(\n        schema,\n        this.safeAddNullToType(\n          schema,\n          this.typeNameFormatter.format(refTypeInfo.typeName),\n        ),\n      );\n    }\n\n    let resultType: string;\n\n    if (this.isConstantSchema(schema) && !schema.enum) {\n      resultType = this.formatJsValue(schema.const);\n    } else {\n      const primitiveType = this.getSchemaPrimitiveType(schema);\n\n      if (primitiveType == null) {\n        return this.config.Ts.Keyword.Any;\n      }\n\n      const typeAlias =\n        lodash.get(this.config.primitiveTypes, [\n          primitiveType,\n          schema.format,\n        ]) ||\n        lodash.get(this.config.primitiveTypes, [primitiveType, \"$default\"]) ||\n        this.config.primitiveTypes[primitiveType];\n\n      if (typeof typeAlias === \"function\") {\n        resultType = typeAlias(schema, this);\n      } else {\n        resultType = typeAlias || primitiveType;\n      }\n    }\n\n    if (!resultType) {\n      return this.config.Ts.Keyword.Any;\n    }\n\n    return this.checkAndAddRequiredKeys(\n      schema,\n      this.safeAddNullToType(schema, resultType),\n    );\n  };\n\n  buildTypeNameFromPath = (schemaPath) => {\n    schemaPath = lodash.uniq(lodash.compact(schemaPath));\n\n    if (!schemaPath || !schemaPath[0]) return null;\n\n    return pascalCase(\n      lodash.camelCase(\n        lodash\n          .uniq([schemaPath[0], schemaPath[schemaPath.length - 1]])\n          .join(\"_\"),\n      ),\n    );\n  };\n\n  isConstantSchema(schema) {\n    return \"const\" in schema;\n  }\n\n  formatJsValue = (value) => {\n    switch (typeof value) {\n      case \"string\": {\n        return this.config.Ts.StringValue(value);\n      }\n      case \"boolean\": {\n        return this.config.Ts.BooleanValue(value);\n      }\n      case \"number\": {\n        return this.config.Ts.NumberValue(value);\n      }\n      default: {\n        if (value === null) {\n          return this.config.Ts.NullValue(value);\n        }\n\n        return this.config.Ts.Keyword.Any;\n      }\n    }\n  };\n}\n","import type {\n  ParsedSchema,\n  SchemaComponent,\n  SchemaTypeEnumContent,\n  SchemaTypeObjectContent,\n  SchemaTypePrimitiveContent,\n} from \"../../types/index.js\";\nimport type { CodeGenConfig } from \"../configuration.js\";\nimport type { SchemaComponentsMap } from \"../schema-components-map.js\";\nimport type { SchemaWalker } from \"../schema-walker.js\";\nimport type { TemplatesWorker } from \"../templates-worker.js\";\nimport type { TypeNameFormatter } from \"../type-name-formatter.js\";\nimport { SchemaFormatters } from \"./schema-formatters.js\";\nimport { SchemaParser } from \"./schema-parser.js\";\nimport { SchemaUtils } from \"./schema-utils.js\";\n\nexport class SchemaParserFabric {\n  config: CodeGenConfig;\n  schemaComponentsMap: SchemaComponentsMap;\n  typeNameFormatter: TypeNameFormatter;\n  schemaFormatters: SchemaFormatters;\n  templatesWorker: TemplatesWorker;\n  schemaUtils: SchemaUtils;\n  schemaWalker: SchemaWalker;\n\n  constructor(\n    config: CodeGenConfig,\n    templatesWorker: TemplatesWorker,\n    schemaComponentsMap: SchemaComponentsMap,\n    typeNameFormatter: TypeNameFormatter,\n    schemaWalker: SchemaWalker,\n  ) {\n    this.config = config;\n    this.schemaComponentsMap = schemaComponentsMap;\n    this.typeNameFormatter = typeNameFormatter;\n    this.templatesWorker = templatesWorker;\n    this.schemaWalker = schemaWalker;\n    this.schemaUtils = new SchemaUtils(this);\n    this.schemaFormatters = new SchemaFormatters(this);\n  }\n\n  createSchemaParser = ({ schema, typeName, schemaPath }) => {\n    return new SchemaParser(this, { schema, typeName, schemaPath });\n  };\n\n  createSchema = ({\n    content,\n    linkedSchema = {},\n    linkedComponent,\n    schemaPath,\n    ...otherSchemaProps\n  }) => {\n    // @ts-expect-error TS(2345) FIXME: Argument of type '{ schema: any; schemaPath: any; ... Remove this comment to see the full error message\n    const parser = this.createSchemaParser({\n      schema: linkedComponent || linkedSchema,\n      schemaPath,\n    });\n    const parsed = parser.parseSchema();\n    parsed.content = content;\n    Object.assign(parsed, otherSchemaProps);\n    if (linkedComponent) {\n      linkedComponent.typeData = parsed;\n    }\n    return parser.schema;\n  };\n\n  createParsedComponent = ({\n    typeName,\n    schema,\n    schemaPath,\n  }): SchemaComponent => {\n    const schemaCopy = structuredClone(schema);\n    const customComponent = this.schemaComponentsMap.createComponent(\n      this.schemaComponentsMap.createRef([\"components\", \"schemas\", typeName]),\n      schemaCopy,\n    );\n    const parsed = this.parseSchema(schemaCopy, null, schemaPath);\n\n    parsed.name = typeName;\n    customComponent.typeData = parsed;\n\n    return customComponent;\n  };\n\n  parseSchema = (\n    schema: string,\n    typeName: string | null = null,\n    schemaPath: string[] = [],\n  ): ParsedSchema<\n    SchemaTypeObjectContent | SchemaTypeEnumContent | SchemaTypePrimitiveContent\n  > => {\n    const schemaParser = this.createSchemaParser({\n      schema,\n      typeName,\n      schemaPath,\n    });\n    return schemaParser.parseSchema();\n  };\n\n  getInlineParseContent = (\n    schema: string,\n    typeName: string | null,\n    schemaPath: string[],\n  ): Record<string, any> => {\n    const parser = this.createSchemaParser({ schema, typeName, schemaPath });\n    return parser.getInlineParseContent();\n  };\n\n  getParseContent = (\n    schema: string,\n    typeName: string | null,\n    schemaPath: string[],\n  ): Record<string, any> => {\n    const parser = this.createSchemaParser({ schema, typeName, schemaPath });\n    return parser.getParseContent();\n  };\n}\n","import * as nanoid from \"nanoid\";\n\nconst ALPHABET = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n\nexport const generateId = nanoid.customAlphabet(ALPHABET, 12);\n","import { consola } from \"consola\";\nimport type { CodeGenConfig } from \"../../configuration.js\";\nimport { NameResolver } from \"../../util/name-resolver.js\";\n\nexport class SpecificArgNameResolver extends NameResolver {\n  counter = 1;\n  constructor(config: CodeGenConfig, reservedNames: string[]) {\n    super(config, reservedNames, (variants) => {\n      const generatedVariant =\n        (variants[0] && `${variants[0]}${this.counter++}`) ||\n        `${this.config.specificArgNameResolverName}${this.counter++}`;\n      consola.debug(\n        \"generated fallback type name for specific arg - \",\n        generatedVariant,\n      );\n      return generatedVariant;\n    });\n  }\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport type {\n  GenerateApiConfiguration,\n  ParsedRoute,\n} from \"../../types/index.js\";\nimport type { CodeGenConfig } from \"../configuration.js\";\nimport {\n  DEFAULT_BODY_ARG_NAME,\n  RESERVED_BODY_ARG_NAMES,\n  RESERVED_HEADER_ARG_NAMES,\n  RESERVED_PATH_ARG_NAMES,\n  RESERVED_QUERY_ARG_NAMES,\n} from \"../constants.js\";\nimport type { SchemaComponentsMap } from \"../schema-components-map.js\";\nimport type { SchemaParserFabric } from \"../schema-parser/schema-parser-fabric.js\";\nimport type { SchemaUtils } from \"../schema-parser/schema-utils.js\";\nimport type { TemplatesWorker } from \"../templates-worker.js\";\nimport type { TypeNameFormatter } from \"../type-name-formatter.js\";\nimport { generateId } from \"../util/id.js\";\nimport { SpecificArgNameResolver } from \"./util/specific-arg-name-resolver.js\";\n\nconst CONTENT_KIND = {\n  JSON: \"JSON\",\n  JSON_API: \"JSON_API\",\n  URL_ENCODED: \"URL_ENCODED\",\n  FORM_DATA: \"FORM_DATA\",\n  IMAGE: \"IMAGE\",\n  OTHER: \"OTHER\",\n  TEXT: \"TEXT\",\n};\n\nexport class SchemaRoutes {\n  config: CodeGenConfig;\n  schemaParserFabric: SchemaParserFabric;\n  schemaUtils: SchemaUtils;\n  typeNameFormatter: TypeNameFormatter;\n  schemaComponentsMap: SchemaComponentsMap;\n  templatesWorker: TemplatesWorker;\n\n  FORM_DATA_TYPES: string[] = [];\n\n  routes: ParsedRoute[] = [];\n  hasSecurityRoutes = false;\n  hasQueryRoutes = false;\n  hasFormDataRoutes = false;\n\n  constructor(\n    config: CodeGenConfig,\n    schemaParserFabric: SchemaParserFabric,\n    schemaComponentsMap: SchemaComponentsMap,\n    templatesWorker: TemplatesWorker,\n    typeNameFormatter: TypeNameFormatter,\n  ) {\n    this.config = config;\n    this.schemaParserFabric = schemaParserFabric;\n    this.schemaUtils = this.schemaParserFabric.schemaUtils;\n    this.typeNameFormatter = typeNameFormatter;\n    this.schemaComponentsMap = schemaComponentsMap;\n    this.templatesWorker = templatesWorker;\n\n    this.FORM_DATA_TYPES = lodash.uniq([\n      this.schemaUtils.getSchemaType({ type: \"string\", format: \"file\" }),\n      this.schemaUtils.getSchemaType({ type: \"string\", format: \"binary\" }),\n    ]);\n  }\n\n  createRequestsMap = (routeInfoByMethodsMap) => {\n    const parameters = lodash.get(routeInfoByMethodsMap, \"parameters\");\n\n    return lodash.reduce(\n      routeInfoByMethodsMap,\n      (acc, requestInfo, method) => {\n        if (\n          method.startsWith(\"x-\") ||\n          [\"parameters\", \"$ref\"].includes(method)\n        ) {\n          return acc;\n        }\n\n        acc[method] = {\n          ...requestInfo,\n          parameters: lodash.compact(\n            lodash.concat(parameters, requestInfo.parameters),\n          ),\n        };\n\n        return acc;\n      },\n      {},\n    );\n  };\n\n  parseRouteName = (originalRouteName) => {\n    const routeName =\n      this.config.hooks.onPreBuildRoutePath(originalRouteName) ||\n      originalRouteName;\n\n    // TODO forbid leading symbols [\\]^` in a major release (allowed yet for backwards compatibility)\n    const pathParamMatches = (routeName || \"\").match(\n      /({[\\w[\\\\\\]^`][-_.\\w]*})|(:[\\w[\\\\\\]^`][-_.\\w]*:?)/g,\n    );\n\n    // used in case when path parameters is not declared in requestInfo.parameters (\"in\": \"path\")\n    const pathParams = lodash.reduce(\n      pathParamMatches,\n      (pathParams, match) => {\n        const paramName = match.replace(/\\{|\\}|:/g, \"\");\n\n        if (!paramName) return pathParams;\n\n        if (paramName.includes(\"-\")) {\n          consola.warn(\"wrong path param name\", paramName);\n        }\n\n        pathParams.push({\n          $match: match,\n          name: lodash.camelCase(paramName),\n          required: true,\n          type: \"string\",\n          description: \"\",\n          schema: {\n            type: \"string\",\n          },\n          in: \"path\",\n        });\n\n        return pathParams;\n      },\n      [],\n    );\n\n    let fixedRoute = pathParams.reduce((fixedRoute, pathParam, i, arr) => {\n      const insertion =\n        this.config.hooks.onInsertPathParam(\n          pathParam.name,\n          i,\n          arr,\n          fixedRoute,\n        ) || pathParam.name;\n      return fixedRoute.replace(pathParam.$match, `\\${${insertion}}`);\n    }, routeName || \"\");\n\n    const queryParamMatches = fixedRoute.match(/(\\{\\?.*\\})/g);\n    const queryParams = [];\n\n    if (queryParamMatches?.length) {\n      for (const match of queryParamMatches) {\n        fixedRoute = fixedRoute.replace(match, \"\");\n      }\n\n      const paramNames = lodash.uniq(\n        queryParamMatches\n          .join(\",\")\n          .replace(/(\\{\\?)|(\\})|\\s/g, \"\")\n          .split(\",\"),\n      );\n\n      for (const paramName of paramNames) {\n        // @ts-expect-error TS(2339) FIXME: Property 'includes' does not exist on type 'unknow... Remove this comment to see the full error message\n        if (paramName.includes(\"-\")) {\n          consola.warn(\"wrong query param name\", paramName);\n        }\n\n        queryParams.push({\n          $match: paramName,\n          // @ts-expect-error TS(2345) FIXME: Argument of type 'unknown' is not assignable to pa... Remove this comment to see the full error message\n          name: lodash.camelCase(paramName),\n          required: true,\n          type: \"string\",\n          description: \"\",\n          schema: {\n            type: \"string\",\n          },\n          in: \"query\",\n        });\n      }\n    }\n\n    const result = {\n      originalRoute: originalRouteName || \"\",\n      route: fixedRoute,\n      pathParams,\n      queryParams,\n    };\n\n    return this.config.hooks.onBuildRoutePath(result) || result;\n  };\n\n  getRouteParams = (\n    routeInfo,\n    pathParamsFromRouteName,\n    queryParamsFromRouteName,\n  ) => {\n    const { parameters } = routeInfo;\n\n    const routeParams = {\n      path: [],\n      header: [],\n      body: [],\n      query: [],\n      formData: [],\n      cookie: [],\n    };\n\n    lodash.each(parameters, (parameter) => {\n      const refTypeInfo =\n        this.schemaParserFabric.schemaUtils.getSchemaRefType(parameter);\n\n      let routeParam = null;\n\n      if (refTypeInfo?.rawTypeData.in && refTypeInfo.rawTypeData) {\n        if (!routeParams[refTypeInfo.rawTypeData.in]) {\n          routeParams[refTypeInfo.rawTypeData.in] = [];\n        }\n\n        routeParam = {\n          ...refTypeInfo.rawTypeData,\n          ...(refTypeInfo.rawTypeData.schema || {}),\n        };\n\n        if (parameter?.required && !routeParam.required) {\n          routeParam.required = parameter.required;\n        }\n      } else {\n        if (!parameter.in) return;\n\n        if (!routeParams[parameter.in]) {\n          routeParams[parameter.in] = [];\n        }\n\n        routeParam = {\n          ...parameter,\n          ...(parameter.schema || {}),\n        };\n      }\n\n      if (routeParam.in === \"path\") {\n        if (!routeParam.name) return;\n\n        routeParam.name = lodash.camelCase(routeParam.name);\n      }\n\n      if (routeParam) {\n        routeParams[routeParam.in].push(routeParam);\n      }\n    });\n\n    // used in case when path parameters is not declared in requestInfo.parameters (\"in\": \"path\")\n    for (const pathParam of pathParamsFromRouteName) {\n      const alreadyExist = routeParams.path.some(\n        (parameter) => parameter.name === pathParam.name,\n      );\n\n      if (!alreadyExist) {\n        routeParams.path.push(pathParam);\n      }\n    }\n\n    // used in case when path parameters is not declared in requestInfo.parameters (\"in\": \"path\")\n    for (const queryParam of queryParamsFromRouteName) {\n      const alreadyExist = routeParams.query.some(\n        (parameter) => parameter.name === queryParam.name,\n      );\n\n      if (!alreadyExist) {\n        routeParams.query.push(queryParam);\n      }\n    }\n\n    return routeParams;\n  };\n\n  getContentTypes = (requestInfo, extraContentTypes) =>\n    lodash.uniq(\n      lodash.compact([\n        ...(extraContentTypes || []),\n        ...lodash.flatten(\n          lodash.map(\n            requestInfo,\n            (requestInfoData) =>\n              requestInfoData && lodash.keys(requestInfoData.content),\n          ),\n        ),\n      ]),\n    );\n\n  getContentKind = (contentTypes) => {\n    if (contentTypes.includes(\"application/vnd.api+json\")) {\n      return CONTENT_KIND.JSON_API;\n    }\n\n    if (\n      contentTypes.some((contentType) =>\n        contentType.startsWith(\"application/json\"),\n      ) ||\n      contentTypes.some((contentType) => contentType.endsWith(\"+json\"))\n    ) {\n      return CONTENT_KIND.JSON;\n    }\n\n    if (contentTypes.includes(\"application/x-www-form-urlencoded\")) {\n      return CONTENT_KIND.URL_ENCODED;\n    }\n\n    if (contentTypes.includes(\"multipart/form-data\")) {\n      return CONTENT_KIND.FORM_DATA;\n    }\n\n    if (contentTypes.some((contentType) => contentType.includes(\"image/\"))) {\n      return CONTENT_KIND.IMAGE;\n    }\n\n    if (contentTypes.some((contentType) => contentType.startsWith(\"text/\"))) {\n      return CONTENT_KIND.TEXT;\n    }\n\n    return CONTENT_KIND.OTHER;\n  };\n\n  isSuccessStatus = (status) =>\n    (this.config.defaultResponseAsSuccess && status === \"default\") ||\n    (+status >= this.config.successResponseStatusRange[0] &&\n      +status <= this.config.successResponseStatusRange[1]) ||\n    status === \"2xx\";\n\n  getSchemaFromRequestType = (requestInfo) => {\n    const content = lodash.get(requestInfo, \"content\");\n\n    if (!content) return null;\n\n    /* content: { \"multipart/form-data\": { schema: {...} }, \"application/json\": { schema: {...} } } */\n\n    /* for example: dataType = \"multipart/form-data\" */\n    for (const dataType in content) {\n      if (content[dataType]?.schema) {\n        return {\n          ...content[dataType].schema,\n          dataType,\n        };\n      }\n    }\n\n    return null;\n  };\n\n  getTypeFromRequestInfo = ({\n    requestInfo,\n    parsedSchemas,\n    operationId,\n    defaultType,\n    typeName,\n  }) => {\n    // TODO: make more flexible pick schema without content type\n    const schema = this.getSchemaFromRequestType(requestInfo);\n    const refTypeInfo =\n      this.schemaParserFabric.schemaUtils.getSchemaRefType(requestInfo);\n\n    if (schema) {\n      const content = this.schemaParserFabric.getInlineParseContent(\n        schema,\n        typeName,\n        [operationId],\n      );\n      const foundedSchemaByName = parsedSchemas.find(\n        (parsedSchema) =>\n          this.typeNameFormatter.format(parsedSchema.name) === content,\n      );\n      const foundSchemaByContent = parsedSchemas.find((parsedSchema) =>\n        lodash.isEqual(parsedSchema.content, content),\n      );\n\n      const foundSchema = foundedSchemaByName || foundSchemaByContent;\n\n      return foundSchema\n        ? this.typeNameFormatter.format(foundSchema.name)\n        : content;\n    }\n\n    if (refTypeInfo) {\n      // const refTypeWithoutOpId = refType.replace(operationId, '');\n      // const foundedSchemaByName = _.find(parsedSchemas, ({ name }) => name === refType || name === refTypeWithoutOpId)\n\n      // TODO:HACK fix problem of swagger2openapi\n      const typeNameWithoutOpId = refTypeInfo.typeName.replace(operationId, \"\");\n      if (parsedSchemas.find((schema) => schema.name === typeNameWithoutOpId)) {\n        return this.typeNameFormatter.format(typeNameWithoutOpId);\n      }\n\n      switch (refTypeInfo.componentName) {\n        case \"schemas\":\n          return this.typeNameFormatter.format(refTypeInfo.typeName);\n        case \"responses\":\n        case \"requestBodies\":\n          return this.schemaParserFabric.getInlineParseContent(\n            this.getSchemaFromRequestType(refTypeInfo.rawTypeData),\n            refTypeInfo.typeName || null,\n            [operationId],\n          );\n        default:\n          return this.schemaParserFabric.getInlineParseContent(\n            refTypeInfo.rawTypeData,\n            refTypeInfo.typeName || null,\n            [operationId],\n          );\n      }\n    }\n\n    return defaultType || this.config.Ts.Keyword.Any;\n  };\n\n  getRequestInfoTypes = ({\n    requestInfos,\n    parsedSchemas,\n    operationId,\n    defaultType,\n  }) =>\n    lodash.reduce(\n      requestInfos,\n      (acc, requestInfo, status) => {\n        // @ts-expect-error TS(2554) FIXME: Expected 2 arguments, but got 1.\n        const contentTypes = this.getContentTypes([requestInfo]);\n\n        return [\n          ...acc,\n          {\n            ...(requestInfo || {}),\n            contentTypes: contentTypes,\n            contentKind: this.getContentKind(contentTypes),\n            type: this.schemaParserFabric.schemaUtils.safeAddNullToType(\n              requestInfo,\n              // @ts-expect-error TS(2345) FIXME: Argument of type '{ requestInfo: any; parsedSchema... Remove this comment to see the full error message\n              this.getTypeFromRequestInfo({\n                requestInfo,\n                parsedSchemas,\n                operationId,\n                defaultType,\n              }),\n            ),\n            description:\n              this.schemaParserFabric.schemaFormatters.formatDescription(\n                requestInfo.description || \"\",\n                true,\n              ),\n            status: Number.isNaN(+status) ? status : +status,\n            isSuccess: this.isSuccessStatus(status),\n          },\n        ];\n      },\n      [],\n    );\n\n  getResponseBodyInfo = (routeInfo, parsedSchemas) => {\n    const { produces, operationId, responses } = routeInfo;\n\n    const contentTypes = this.getContentTypes(responses, [\n      ...(produces || []),\n      routeInfo[\"x-accepts\"],\n    ]);\n\n    const responseInfos = this.getRequestInfoTypes({\n      requestInfos: responses,\n      parsedSchemas,\n      operationId,\n      defaultType: this.config.defaultResponseType,\n    });\n\n    const successResponse = responseInfos.find(\n      (response) => response.isSuccess,\n    );\n    const errorResponses = responseInfos.filter(\n      (response) =>\n        !response.isSuccess && response.type !== this.config.Ts.Keyword.Any,\n    );\n\n    const handleResponseHeaders = (src) => {\n      if (!src) {\n        return \"headers: {},\";\n      }\n      const headerTypes = Object.fromEntries(\n        Object.entries(src).map(([k, v]) => {\n          return [k, this.schemaUtils.getSchemaType(v)];\n        }),\n      );\n      const r = `headers: { ${Object.entries(headerTypes)\n        .map(([k, v]) => `\"${k}\": ${v}`)\n        .join(\",\")} },`;\n      return r;\n    };\n\n    return {\n      contentTypes,\n      responses: responseInfos,\n      success: {\n        schema: successResponse,\n        type: successResponse?.type || this.config.Ts.Keyword.Any,\n      },\n      error: {\n        schemas: errorResponses,\n        type:\n          this.config.Ts.UnionType(\n            errorResponses.map((response) => response.type),\n          ) || this.config.Ts.Keyword.Any,\n      },\n      full: {\n        types:\n          this.config.Ts.UnionType(\n            responseInfos.map(\n              (response) => `{\n      data: ${response.type}, status: ${response.status}, statusCode: ${\n        response.status\n      }, statusText: \"${response.description}\", ${handleResponseHeaders(\n        response.headers,\n      )} config: {} }`,\n            ),\n          ) || this.config.Ts.Keyword.Any,\n      },\n    };\n  };\n\n  convertRouteParamsIntoObject = (params) => {\n    return params.reduce(\n      (objectSchema, schemaPart) => {\n        if (!schemaPart || !schemaPart.name) return objectSchema;\n\n        return {\n          ...objectSchema,\n          properties: {\n            ...objectSchema.properties,\n            [schemaPart.name]: {\n              ...schemaPart,\n              ...(schemaPart.schema || {}),\n            },\n          },\n        };\n      },\n      {\n        properties: {},\n        type: \"object\",\n      },\n    );\n  };\n\n  getRequestBodyInfo = (routeInfo, routeParams, parsedSchemas, routeName) => {\n    const { requestBody, consumes, requestBodyName, operationId } = routeInfo;\n    let schema = null;\n    let content = null;\n\n    const contentTypes = this.getContentTypes(\n      [requestBody],\n      [...(consumes || []), routeInfo[\"x-contentType\"]],\n    );\n    let contentKind = this.getContentKind(contentTypes);\n\n    let typeName = null;\n\n    if (this.config.extractRequestBody) {\n      typeName = this.schemaUtils.resolveTypeName(routeName.usage, {\n        suffixes: this.config.extractingOptions.requestBodySuffix,\n        resolver: this.config.extractingOptions.requestBodyNameResolver,\n      });\n    }\n\n    if (routeParams.formData.length) {\n      contentKind = CONTENT_KIND.FORM_DATA;\n      schema = this.convertRouteParamsIntoObject(routeParams.formData);\n      content = this.schemaParserFabric.getInlineParseContent(\n        schema,\n        typeName,\n        [operationId],\n      );\n    } else if (contentKind === CONTENT_KIND.FORM_DATA) {\n      schema = this.getSchemaFromRequestType(requestBody);\n      content = this.schemaParserFabric.getInlineParseContent(\n        schema,\n        typeName,\n        [operationId],\n      );\n    } else if (requestBody) {\n      schema = this.getSchemaFromRequestType(requestBody);\n      content = this.schemaParserFabric.schemaUtils.safeAddNullToType(\n        requestBody,\n        // @ts-expect-error TS(2345) FIXME: Argument of type '{ requestInfo: any; parsedSchema... Remove this comment to see the full error message\n        this.getTypeFromRequestInfo({\n          requestInfo: requestBody,\n          parsedSchemas,\n          operationId,\n          typeName,\n        }),\n      );\n\n      // TODO: Refactor that.\n      // It needed for cases when swagger schema is not declared request body type as form data\n      // but request body data type contains form data types like File\n      if (\n        this.FORM_DATA_TYPES.some((dataType) =>\n          content.includes(`: ${dataType}`),\n        )\n      ) {\n        contentKind = CONTENT_KIND.FORM_DATA;\n      }\n    }\n\n    if (schema && !schema.$ref && this.config.extractRequestBody) {\n      schema = this.schemaParserFabric.createParsedComponent({\n        schema,\n        typeName,\n        schemaPath: [operationId],\n      });\n\n      if (schema?.typeData) {\n        schema.typeData.isExtractedRequestBody = true;\n      }\n      content = this.schemaParserFabric.getInlineParseContent({\n        $ref: schema.$ref,\n      });\n    }\n\n    if (\n      schema &&\n      schema.typeData &&\n      !schema.typeData.description &&\n      requestBody?.description\n    ) {\n      schema.typeData.description = requestBody.description;\n    }\n\n    return {\n      ...(requestBody || {}),\n      paramName: requestBodyName || requestBody?.name || DEFAULT_BODY_ARG_NAME,\n      contentTypes,\n      contentKind,\n      schema,\n      type: content,\n      required:\n        requestBody &&\n        (typeof requestBody.required === \"undefined\" || !!requestBody.required),\n    };\n  };\n\n  createRequestParamsSchema = ({\n    queryParams,\n    queryObjectSchema,\n    pathArgsSchemas,\n    extractRequestParams,\n    routeName,\n  }) => {\n    if (\n      (!queryParams || !queryParams.length) &&\n      (!pathArgsSchemas || !pathArgsSchemas.length)\n    )\n      return null;\n\n    const pathParams = pathArgsSchemas.reduce((acc, pathArgSchema) => {\n      if (pathArgSchema.name) {\n        acc[pathArgSchema.name] = {\n          ...pathArgSchema,\n          in: \"path\",\n        };\n      }\n\n      return acc;\n    }, {});\n\n    const fixedQueryParams = lodash.reduce(\n      lodash.get(queryObjectSchema, \"properties\", {}),\n      (acc, property, name) => {\n        if (name && typeof property === \"object\") {\n          acc[name] = {\n            ...property,\n            in: \"query\",\n          };\n        }\n\n        return acc;\n      },\n      {},\n    );\n\n    const schema = {\n      ...queryObjectSchema,\n      properties: {\n        ...fixedQueryParams,\n        ...pathParams,\n      },\n    };\n\n    const fixedSchema = this.config.hooks.onCreateRequestParams(schema);\n\n    if (fixedSchema) return fixedSchema;\n\n    if (extractRequestParams) {\n      const generatedTypeName = this.schemaUtils.resolveTypeName(\n        routeName.usage,\n        {\n          suffixes: this.config.extractingOptions.requestParamsSuffix,\n          resolver: this.config.extractingOptions.requestParamsNameResolver,\n        },\n      );\n\n      const component = this.schemaParserFabric.createParsedComponent({\n        typeName: generatedTypeName,\n        schema: schema,\n      });\n\n      if (component.typeData) {\n        component.typeData.isExtractedRequestParams = true;\n      }\n\n      return component;\n    }\n\n    return schema;\n  };\n\n  extractResponseBodyIfItNeeded = (routeInfo, responseBodyInfo, routeName) => {\n    if (\n      responseBodyInfo.responses.length &&\n      responseBodyInfo.success &&\n      responseBodyInfo.success.schema\n    ) {\n      const typeName = this.schemaUtils.resolveTypeName(routeName.usage, {\n        suffixes: this.config.extractingOptions.responseBodySuffix,\n        resolver: this.config.extractingOptions.responseBodyNameResolver,\n      });\n\n      const idx = responseBodyInfo.responses.indexOf(\n        responseBodyInfo.success.schema,\n      );\n\n      const successResponse = responseBodyInfo.success;\n\n      if (successResponse.schema && !successResponse.schema.$ref) {\n        const contentKind = successResponse.schema.contentKind;\n        const schema = this.getSchemaFromRequestType(successResponse.schema);\n        successResponse.schema = this.schemaParserFabric.createParsedComponent({\n          schema,\n          typeName,\n          schemaPath: [routeInfo.operationId],\n        });\n        successResponse.schema.contentKind = contentKind;\n        if (successResponse.schema.typeData) {\n          successResponse.schema.typeData.isExtractedResponseBody = true;\n        }\n        successResponse.type = this.schemaParserFabric.getInlineParseContent({\n          $ref: successResponse.schema.$ref,\n        });\n\n        if (idx > -1) {\n          lodash.assign(responseBodyInfo.responses[idx], {\n            ...successResponse.schema,\n            type: successResponse.type,\n          });\n        }\n      }\n    }\n  };\n\n  extractResponseErrorIfItNeeded = (routeInfo, responseBodyInfo, routeName) => {\n    if (\n      responseBodyInfo.responses.length &&\n      responseBodyInfo.error.schemas &&\n      responseBodyInfo.error.schemas.length\n    ) {\n      const typeName = this.schemaUtils.resolveTypeName(routeName.usage, {\n        suffixes: this.config.extractingOptions.responseErrorSuffix,\n        resolver: this.config.extractingOptions.responseErrorNameResolver,\n      });\n\n      const errorSchemas = responseBodyInfo.error.schemas\n        .map(this.getSchemaFromRequestType)\n        .filter(Boolean);\n\n      if (!errorSchemas.length) return;\n\n      const schema = this.schemaParserFabric.parseSchema(\n        {\n          oneOf: errorSchemas,\n          title: errorSchemas\n            .map((schema) => schema.title)\n            .filter(Boolean)\n            .join(\" \"),\n          description: errorSchemas\n            .map((schema) => schema.description)\n            .filter(Boolean)\n            .join(\"\\n\"),\n        },\n        null,\n        [routeInfo.operationId],\n      );\n      const component = this.schemaComponentsMap.createComponent(\n        this.schemaComponentsMap.createRef([\"components\", \"schemas\", typeName]),\n        { ...schema },\n      );\n      responseBodyInfo.error.schemas = [component];\n      if (component.typeData) {\n        component.typeData.isExtractedResponseError = true;\n      }\n      responseBodyInfo.error.type = this.typeNameFormatter.format(\n        component.typeName,\n      );\n    }\n  };\n\n  getRouteName = (rawRouteInfo) => {\n    const { moduleName } = rawRouteInfo;\n    const { routeNameDuplicatesMap, templatesToRender } = this.config;\n    const routeNameTemplate = templatesToRender.routeName;\n\n    const routeNameFromTemplate = this.templatesWorker.renderTemplate(\n      routeNameTemplate,\n      {\n        routeInfo: rawRouteInfo,\n      },\n    );\n\n    const routeName =\n      this.config.hooks.onFormatRouteName(\n        rawRouteInfo,\n        routeNameFromTemplate,\n      ) || routeNameFromTemplate;\n\n    const duplicateIdentifier = `${moduleName}|${routeName}`;\n\n    if (routeNameDuplicatesMap.has(duplicateIdentifier)) {\n      routeNameDuplicatesMap.set(\n        duplicateIdentifier,\n        routeNameDuplicatesMap.get(duplicateIdentifier) + 1,\n      );\n\n      consola.warn(\n        `Module \"${moduleName}\" already has method \"${routeName}()\".`,\n        `This method has been renamed to \"${\n          routeName + routeNameDuplicatesMap.get(duplicateIdentifier)\n        }()\" to solve conflict names.`,\n      );\n    } else {\n      routeNameDuplicatesMap.set(duplicateIdentifier, 1);\n    }\n\n    const duplicates = routeNameDuplicatesMap.get(duplicateIdentifier);\n\n    const routeNameInfo = {\n      usage: routeName + (duplicates > 1 ? duplicates : \"\"),\n      original: routeName,\n      duplicate: duplicates > 1,\n    };\n\n    return (\n      this.config.hooks.onCreateRouteName(routeNameInfo, rawRouteInfo) ||\n      routeNameInfo\n    );\n  };\n\n  parseRouteInfo = (\n    rawRouteName,\n    routeInfo,\n    method,\n    usageSchema,\n    parsedSchemas,\n  ): ParsedRoute => {\n    const { security: globalSecurity } = usageSchema;\n    const { moduleNameIndex, moduleNameFirstTag, extractRequestParams } =\n      this.config;\n    const {\n      operationId,\n      requestBody,\n      security,\n      parameters,\n      summary,\n      description,\n      tags,\n      responses,\n      requestBodyName,\n      produces,\n      consumes,\n      ...otherInfo\n    } = routeInfo;\n    const {\n      route,\n      pathParams: pathParamsFromRouteName,\n      queryParams: queryParamsFromRouteName,\n    } = this.parseRouteName(rawRouteName);\n\n    const routeId = generateId();\n    const firstTag = tags && tags.length > 0 ? tags[0] : null;\n    const moduleName =\n      moduleNameFirstTag && firstTag\n        ? lodash.camelCase(firstTag)\n        : // @ts-expect-error TS(2345) FIXME: Argument of type 'unknown' is not assignable to pa... Remove this comment to see the full error message\n          lodash.camelCase(lodash.compact(route.split(\"/\"))[moduleNameIndex]);\n    let hasSecurity = !!globalSecurity?.length;\n    if (security) {\n      hasSecurity = security.length > 0;\n    }\n\n    const routeParams = this.getRouteParams(\n      routeInfo,\n      pathParamsFromRouteName,\n      queryParamsFromRouteName,\n    );\n\n    const pathArgs = routeParams.path.map((pathArgSchema) => ({\n      name: pathArgSchema.name,\n      optional: !pathArgSchema.required,\n      // mark it as any for now, because \"getInlineParseContent\" breaks type names of extracted enums\n      type: this.config.Ts.Keyword.Any,\n      description: pathArgSchema.description,\n    }));\n    const pathArgsNames = pathArgs.map((arg) => arg.name);\n\n    const responseBodyInfo = this.getResponseBodyInfo(routeInfo, parsedSchemas);\n\n    const rawRouteInfo = {\n      ...otherInfo,\n      pathArgs,\n      operationId,\n      method,\n      route: rawRouteName,\n      moduleName,\n      responsesTypes: responseBodyInfo.responses,\n      description,\n      tags,\n      summary,\n      responses,\n      produces,\n      requestBody,\n      consumes,\n      security,\n    };\n\n    const queryObjectSchema = this.convertRouteParamsIntoObject(\n      routeParams.query,\n    );\n    const pathObjectSchema = this.convertRouteParamsIntoObject(\n      routeParams.path,\n    );\n    const headersObjectSchema = this.convertRouteParamsIntoObject(\n      routeParams.header,\n    );\n\n    const routeName = this.getRouteName(rawRouteInfo);\n\n    const requestBodyInfo = this.getRequestBodyInfo(\n      routeInfo,\n      routeParams,\n      parsedSchemas,\n      routeName,\n    );\n\n    const requestParamsSchema = this.createRequestParamsSchema({\n      queryParams: routeParams.query,\n      pathArgsSchemas: routeParams.path,\n      queryObjectSchema,\n      extractRequestParams,\n      routeName,\n    });\n\n    if (this.config.extractResponseBody) {\n      this.extractResponseBodyIfItNeeded(\n        routeInfo,\n        responseBodyInfo,\n        routeName,\n      );\n    }\n    if (this.config.extractResponseError) {\n      this.extractResponseErrorIfItNeeded(\n        routeInfo,\n        responseBodyInfo,\n        routeName,\n      );\n    }\n\n    const typeName = this.schemaUtils.resolveTypeName(routeName.usage, {\n      suffixes: this.config.extractingOptions.requestParamsSuffix,\n      resolver: this.config.extractingOptions.requestParamsNameResolver,\n      shouldReserve: false,\n    });\n\n    const queryType = routeParams.query.length\n      ? this.schemaParserFabric.getInlineParseContent(queryObjectSchema, null, [\n          typeName,\n        ])\n      : null;\n    const pathType = routeParams.path.length\n      ? this.schemaParserFabric.getInlineParseContent(pathObjectSchema, null, [\n          typeName,\n        ])\n      : null;\n    const headersType = routeParams.header.length\n      ? this.schemaParserFabric.getInlineParseContent(\n          headersObjectSchema,\n          null,\n          [typeName],\n        )\n      : null;\n\n    const nameResolver = new SpecificArgNameResolver(\n      this.config,\n      pathArgsNames,\n    );\n\n    const specificArgs = {\n      query: queryType\n        ? {\n            name: nameResolver.resolve(RESERVED_QUERY_ARG_NAMES),\n            optional: this.schemaParserFabric.parseSchema(\n              queryObjectSchema,\n              null,\n              [routeName.usage],\n            ).allFieldsAreOptional,\n            type: queryType,\n          }\n        : void 0,\n      body: requestBodyInfo.type\n        ? {\n            ...requestBodyInfo,\n            name: nameResolver.resolve([\n              requestBodyInfo.paramName,\n              ...RESERVED_BODY_ARG_NAMES,\n            ]),\n            optional: !requestBodyInfo.required,\n            type: requestBodyInfo.type,\n          }\n        : void 0,\n      pathParams: pathType\n        ? {\n            name: nameResolver.resolve(RESERVED_PATH_ARG_NAMES),\n            optional: this.schemaParserFabric.parseSchema(\n              pathObjectSchema,\n              null,\n              [routeName.usage],\n            ).allFieldsAreOptional,\n            type: pathType,\n          }\n        : void 0,\n      headers: headersType\n        ? {\n            name: nameResolver.resolve(RESERVED_HEADER_ARG_NAMES),\n            optional: this.schemaParserFabric.parseSchema(\n              headersObjectSchema,\n              null,\n              [routeName.usage],\n            ).allFieldsAreOptional,\n            type: headersType,\n          }\n        : void 0,\n    };\n\n    pathArgs.forEach((pathArg, i) => {\n      pathArg.type = this.schemaParserFabric.getInlineParseContent(\n        routeParams.path[i].schema,\n        null,\n        [typeName],\n      );\n    });\n\n    return {\n      id: routeId,\n      namespace: moduleName.replace(/^(\\d)/, \"v$1\"),\n      routeName,\n      routeParams,\n      requestBodyInfo,\n      responseBodyInfo,\n      specificArgs,\n      queryObjectSchema,\n      pathObjectSchema,\n      headersObjectSchema,\n      responseBodySchema: responseBodyInfo.success.schema,\n      requestBodySchema: requestBodyInfo.schema,\n      specificArgNameResolver: nameResolver,\n      request: {\n        contentTypes: requestBodyInfo.contentTypes,\n        parameters: pathArgs,\n        path: route,\n        formData: requestBodyInfo.contentKind === CONTENT_KIND.FORM_DATA,\n        isQueryBody: requestBodyInfo.contentKind === CONTENT_KIND.URL_ENCODED,\n        security: hasSecurity,\n        method: method,\n        requestParams: requestParamsSchema,\n\n        payload: specificArgs.body,\n        query: specificArgs.query,\n        pathParams: specificArgs.pathParams,\n        headers: specificArgs.headers,\n      },\n      response: {\n        contentTypes: responseBodyInfo.contentTypes,\n        type: responseBodyInfo.success.type,\n        errorType: responseBodyInfo.error.type,\n        fullTypes: responseBodyInfo.full.types,\n      },\n      raw: rawRouteInfo,\n    };\n  };\n\n  attachSchema = ({ usageSchema, parsedSchemas }) => {\n    this.config.routeNameDuplicatesMap.clear();\n\n    const pathsEntries = lodash.entries(usageSchema.paths);\n\n    for (const [rawRouteName, routeInfoByMethodsMap] of pathsEntries) {\n      const routeInfosMap = this.createRequestsMap(routeInfoByMethodsMap);\n\n      for (const [method, routeInfo] of Object.entries(routeInfosMap)) {\n        const parsedRouteInfo = this.parseRouteInfo(\n          rawRouteName,\n          routeInfo,\n          method,\n          usageSchema,\n          parsedSchemas,\n        );\n        const processedRouteInfo =\n          this.config.hooks.onCreateRoute(parsedRouteInfo);\n        if (processedRouteInfo !== false) {\n          const route = processedRouteInfo || parsedRouteInfo;\n\n          if (!this.hasSecurityRoutes && route.security) {\n            this.hasSecurityRoutes = route.security;\n          }\n          if (!this.hasQueryRoutes && route.hasQuery) {\n            this.hasQueryRoutes = route.hasQuery;\n          }\n          if (!this.hasFormDataRoutes && route.hasFormDataParams) {\n            this.hasFormDataRoutes = route.hasFormDataParams;\n          }\n\n          this.routes.push(route);\n        }\n      }\n    }\n  };\n\n  getGroupedRoutes = () => {\n    const groupedRoutes = this.routes.reduce(\n      (modules, route) => {\n        if (route.namespace) {\n          if (!modules[route.namespace]) {\n            modules[route.namespace] = [];\n          }\n\n          modules[route.namespace].push(route);\n        } else {\n          modules.$outOfModule.push(route);\n        }\n\n        return modules;\n      },\n      { $outOfModule: [] as ParsedRoute[] },\n    );\n\n    const routeGroups = lodash.reduce(\n      groupedRoutes,\n      (acc, routesGroup, moduleName) => {\n        if (moduleName === \"$outOfModule\") {\n          acc.outOfModule = routesGroup;\n        } else {\n          if (!acc.combined) {\n            acc.combined = [];\n          }\n          acc.combined.push({\n            moduleName,\n            routes: routesGroup.map((route) => {\n              const { original: originalName, usage: usageName } =\n                route.routeName;\n\n              // TODO: https://github.com/acacode/swagger-typescript-api/issues/152\n              // TODO: refactor\n              if (\n                routesGroup.length > 1 &&\n                usageName !== originalName &&\n                !routesGroup.some(\n                  ({ routeName, id }) =>\n                    id !== route.id && originalName === routeName.original,\n                )\n              ) {\n                return {\n                  ...route,\n                  routeName: {\n                    ...route.routeName,\n                    usage: originalName,\n                  },\n                };\n              }\n\n              return route;\n            }),\n          });\n        }\n        return acc;\n      },\n      {} as GenerateApiConfiguration[\"routes\"],\n    );\n\n    if (this.config.sortRoutes) {\n      if (routeGroups.outOfModule) {\n        routeGroups.outOfModule = this.sortRoutes(routeGroups.outOfModule);\n      }\n      if (routeGroups.combined) {\n        lodash.each(routeGroups.combined, (routeGroup) => {\n          routeGroup.routes = this.sortRoutes(routeGroup.routes);\n        });\n      }\n    }\n\n    return routeGroups;\n  };\n\n  sortRoutes = (routes: ParsedRoute[]) => {\n    return lodash\n      .slice(routes)\n      .sort((routeA, routeB) =>\n        routeA.routeName.usage.localeCompare(routeB.routeName.usage),\n      );\n  };\n}\n","import lodash from \"lodash\";\nimport type { OpenAPI } from \"openapi-types\";\nimport type { CodeGenConfig } from \"./configuration.js\";\nimport type { SwaggerSchemaResolver } from \"./swagger-schema-resolver.js\";\n\n// TODO: WIP\n// this class will be needed to walk by schema everywhere\nexport class SchemaWalker {\n  config: CodeGenConfig;\n  swaggerSchemaResolver: SwaggerSchemaResolver;\n  schemas = new Map<string, OpenAPI.Document>();\n  caches = new Map<string, OpenAPI.Document>();\n\n  constructor(\n    config: CodeGenConfig,\n    swaggerSchemaResolver: SwaggerSchemaResolver,\n  ) {\n    this.config = config;\n    this.swaggerSchemaResolver = swaggerSchemaResolver;\n  }\n\n  addSchema = (name: string, schema: OpenAPI.Document) => {\n    this.schemas.set(name, structuredClone(schema));\n  };\n\n  _isLocalRef = (ref: string) => {\n    return ref.startsWith(\"#\");\n  };\n\n  _isRemoteRef = (ref: string) => {\n    return ref.startsWith(\"http://\") || ref.startsWith(\"https://\");\n  };\n\n  _getRefDataFromSchema = (schema: Record<string, unknown>, ref: string) => {\n    const path = ref.replace(\"#\", \"\").split(\"/\");\n    const refData = lodash.get(schema, path);\n    if (refData) {\n      this.caches.set(ref, refData);\n    }\n    return refData;\n  };\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport type { CodeGenConfig } from \"../configuration.js\";\n\nexport class Request {\n  config: CodeGenConfig;\n\n  constructor(config: CodeGenConfig) {\n    this.config = config;\n  }\n\n  async download({\n    url,\n    authToken,\n    ...options\n  }: {\n    url: string;\n    authToken?: string;\n    options?: Partial<RequestInit>;\n  }) {\n    const requestOptions: Partial<RequestInit> = {};\n\n    if (authToken) {\n      requestOptions.headers = {\n        Authorization: authToken,\n      };\n    }\n\n    lodash.merge(requestOptions, options, this.config.requestOptions);\n\n    try {\n      const response = await fetch(url, requestOptions);\n      return await response.text();\n    } catch (error) {\n      const message = `error while fetching data from URL \"${url}\"`;\n      consola.error(message, error);\n      return message;\n    }\n  }\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport type { OpenAPI, OpenAPIV2 } from \"openapi-types\";\nimport * as swagger2openapi from \"swagger2openapi\";\nimport * as YAML from \"yaml\";\nimport type { CodeGenConfig } from \"./configuration.js\";\nimport type { FileSystem } from \"./util/file-system.js\";\nimport { Request } from \"./util/request.js\";\n\nexport class SwaggerSchemaResolver {\n  config: CodeGenConfig;\n  fileSystem: FileSystem;\n  request: Request;\n\n  constructor(config: CodeGenConfig, fileSystem: FileSystem) {\n    this.config = config;\n    this.fileSystem = fileSystem;\n    this.request = new Request(config);\n  }\n\n  async create() {\n    const { spec, patch, input, url, authorizationToken } = this.config;\n\n    if (spec) {\n      return await this.convertSwaggerObject(spec, { patch });\n    }\n\n    const swaggerSchemaFile = await this.fetchSwaggerSchemaFile(\n      input,\n      url,\n      authorizationToken,\n    );\n    const swaggerSchemaObject =\n      this.processSwaggerSchemaFile(swaggerSchemaFile);\n    return await this.convertSwaggerObject(swaggerSchemaObject, { patch });\n  }\n\n  convertSwaggerObject(\n    swaggerSchema: OpenAPI.Document,\n    converterOptions: { patch?: boolean },\n  ): Promise<{\n    usageSchema: OpenAPI.Document;\n    originalSchema: OpenAPI.Document;\n  }> {\n    return new Promise((resolve) => {\n      const result = structuredClone(swaggerSchema);\n      result.info = lodash.merge(\n        {\n          title: \"No title\",\n          version: \"\",\n        },\n        result.info,\n      );\n\n      if (!Object.hasOwn(result, \"openapi\")) {\n        result.paths = lodash.merge({}, result.paths);\n\n        swagger2openapi.convertObj(\n          result as OpenAPIV2.Document,\n          {\n            ...converterOptions,\n            resolveInternal: true,\n            warnOnly: true,\n            refSiblings: \"preserve\",\n            rbname: \"requestBodyName\",\n          },\n          (err, options) => {\n            const parsedSwaggerSchema = lodash.get(\n              err,\n              \"options.openapi\",\n              lodash.get(options, \"openapi\"),\n            );\n            if (!parsedSwaggerSchema && err) {\n              throw err;\n            }\n            this.config.update({ convertedFromSwagger2: true });\n            resolve({\n              usageSchema: parsedSwaggerSchema,\n              originalSchema: result,\n            });\n          },\n        );\n      } else {\n        resolve({\n          usageSchema: result,\n          originalSchema: structuredClone(result),\n        });\n      }\n    });\n  }\n\n  getSwaggerSchemaByPath = (pathToSwagger: string) => {\n    consola.info(`try to get swagger by path \"${pathToSwagger}\"`);\n    return this.fileSystem.getFileContent(pathToSwagger);\n  };\n\n  async fetchSwaggerSchemaFile(\n    pathToSwagger: string,\n    urlToSwagger: string,\n    authToken?: string,\n  ) {\n    if (this.fileSystem.pathIsExist(pathToSwagger)) {\n      return this.getSwaggerSchemaByPath(pathToSwagger);\n    }\n    consola.info(`try to get swagger by URL \"${urlToSwagger}\"`);\n    return await this.request.download({\n      url: urlToSwagger,\n      authToken: authToken,\n    });\n  }\n\n  processSwaggerSchemaFile(file: string) {\n    if (typeof file !== \"string\") return file;\n\n    try {\n      return JSON.parse(file);\n    } catch {\n      return YAML.parse(file);\n    }\n  }\n\n  fixSwaggerSchema({ usageSchema, originalSchema }) {\n    const usagePaths = lodash.get(usageSchema, \"paths\");\n    const originalPaths = lodash.get(originalSchema, \"paths\");\n\n    // walk by routes\n    lodash.each(usagePaths, (usagePathObject, route) => {\n      const originalPathObject = lodash.get(originalPaths, route);\n\n      // walk by methods\n      lodash.each(usagePathObject, (usageRouteInfo, methodName) => {\n        const originalRouteInfo = lodash.get(originalPathObject, methodName);\n        const usageRouteParams = lodash.get(usageRouteInfo, \"parameters\", []);\n        const originalRouteParams = lodash.get(\n          originalRouteInfo,\n          \"parameters\",\n          [],\n        );\n\n        if (typeof usageRouteInfo === \"object\") {\n          usageRouteInfo.consumes = lodash.uniq(\n            lodash.compact([\n              ...(usageRouteInfo.consumes || []),\n              ...(originalRouteInfo.consumes || []),\n            ]),\n          );\n          usageRouteInfo.produces = lodash.uniq(\n            lodash.compact([\n              ...(usageRouteInfo.produces || []),\n              ...(originalRouteInfo.produces || []),\n            ]),\n          );\n        }\n\n        lodash.each(originalRouteParams, (originalRouteParam) => {\n          const existUsageParam = usageRouteParams.find(\n            (param) =>\n              originalRouteParam.in === param.in &&\n              originalRouteParam.name === param.name,\n          );\n          if (!existUsageParam) {\n            usageRouteParams.push(originalRouteParam);\n          }\n        });\n      });\n    });\n  }\n}\n","import * as module from \"node:module\";\nimport * as path from \"node:path\";\nimport * as url from \"node:url\";\nimport { consola } from \"consola\";\nimport { Eta } from \"eta\";\nimport lodash from \"lodash\";\nimport type { CodeGenProcess } from \"./code-gen-process.js\";\nimport type { CodeGenConfig } from \"./configuration.js\";\nimport type { FileSystem } from \"./util/file-system.js\";\n\nconst require = module.createRequire(import.meta.url);\n\nconst eta = new Eta({\n  functionHeader: \"const includeFile = options.includeFile;\",\n});\n\nexport class TemplatesWorker {\n  config: CodeGenConfig;\n  fileSystem: FileSystem;\n  getRenderTemplateData: CodeGenProcess[\"getRenderTemplateData\"];\n\n  constructor(\n    config: CodeGenConfig,\n    fileSystem: FileSystem,\n    getRenderTemplateData: CodeGenProcess[\"getRenderTemplateData\"],\n  ) {\n    this.config = config;\n    this.fileSystem = fileSystem;\n    this.getRenderTemplateData = getRenderTemplateData;\n    if (this.config.debug) consola.level = Number.MAX_SAFE_INTEGER;\n    if (this.config.silent) consola.level = 0;\n  }\n\n  getTemplatePaths = (\n    config: CodeGenConfig,\n  ): CodeGenConfig[\"templatePaths\"] => {\n    const __dirname = path.dirname(url.fileURLToPath(import.meta.url));\n    const baseTemplatesPath = path.resolve(__dirname, \"../templates/base\");\n    const defaultTemplatesPath = path.resolve(\n      __dirname,\n      \"../templates/default\",\n    );\n    const modularTemplatesPath = path.resolve(\n      __dirname,\n      \"../templates/modular\",\n    );\n    const originalTemplatesPath = config.modular\n      ? modularTemplatesPath\n      : defaultTemplatesPath;\n    const customTemplatesPath =\n      config.templates && path.resolve(process.cwd(), config.templates);\n\n    return {\n      /** `templates/base` */\n      base: baseTemplatesPath,\n      /** `templates/default` */\n      default: defaultTemplatesPath,\n      /** `templates/modular` */\n      modular: modularTemplatesPath,\n      /** usage path if `--templates` option is not set */\n      original: originalTemplatesPath,\n      /** custom path to templates (`--templates`) */\n      custom: customTemplatesPath,\n    };\n  };\n\n  cropExtension = (path: string) =>\n    this.config.templateExtensions.reduce(\n      (path, ext) => (path.endsWith(ext) ? path.replace(ext, \"\") : path),\n      path,\n    );\n\n  getTemplateFullPath = (path_: string, fileName: string) => {\n    const raw = path.resolve(path_, \"./\", this.cropExtension(fileName));\n    const pathVariants = this.config.templateExtensions.map(\n      (extension) => `${raw}${extension}`,\n    );\n\n    return pathVariants.find(\n      (variant) => !!this.fileSystem.pathIsExist(variant),\n    );\n  };\n\n  requireFnFromTemplate = (packageOrPath: string) => {\n    const isPath =\n      packageOrPath.startsWith(\"./\") || packageOrPath.startsWith(\"../\");\n\n    if (isPath) {\n      return require(\n        path.resolve(\n          this.config.templatePaths.custom ||\n            this.config.templatePaths.original,\n          packageOrPath,\n        ),\n      );\n    }\n\n    return require(packageOrPath);\n  };\n\n  getTemplate = (name: string, fileName: string, path?: string) => {\n    const { templatePaths } = this.config;\n\n    if (path) {\n      return this.fileSystem.getFileContent(path);\n    }\n\n    if (!fileName) return \"\";\n\n    const customFullPath =\n      templatePaths.custom &&\n      this.getTemplateFullPath(templatePaths.custom, fileName);\n    let fileContent =\n      customFullPath && this.fileSystem.getFileContent(customFullPath);\n\n    if (fileContent) {\n      consola.info(\n        `\"${name.toLowerCase()}\" template found in \"${templatePaths.custom}\"`,\n      );\n      return fileContent;\n    }\n\n    const baseFullPath = this.getTemplateFullPath(templatePaths.base, fileName);\n\n    if (baseFullPath) {\n      fileContent = this.fileSystem.getFileContent(baseFullPath);\n    } else {\n      if (templatePaths.custom) {\n        consola.warn(\n          \"Code generator will use the default template:\",\n          `\"${name.toLowerCase()}\"`,\n          \"template not found in\",\n          `\"${templatePaths.custom}\"`,\n        );\n      } else {\n        consola.info(\n          `Code generator will use the default template for \"${name.toLowerCase()}\"`,\n        );\n      }\n    }\n\n    const originalFullPath = this.getTemplateFullPath(\n      templatePaths.original,\n      fileName,\n    );\n\n    if (originalFullPath) {\n      fileContent = this.fileSystem.getFileContent(originalFullPath);\n    }\n\n    return fileContent;\n  };\n\n  getTemplates = ({ templatePaths }: CodeGenConfig) => {\n    if (templatePaths.custom) {\n      consola.info(\n        `try to read templates from directory \"${templatePaths.custom}\"`,\n      );\n    }\n\n    return lodash.reduce(\n      this.config.templateInfos,\n      (acc, { name, fileName }) => ({\n        ...acc,\n        [name]: this.getTemplate(name, fileName),\n      }),\n      {},\n    );\n  };\n\n  findTemplateWithExt = (path: string) => {\n    const raw = this.cropExtension(path);\n    const pathVariants = this.config.templateExtensions.map(\n      (extension) => `${raw}${extension}`,\n    );\n    return pathVariants.find((variant) => this.fileSystem.pathIsExist(variant));\n  };\n\n  getTemplateContent = (path_: string) => {\n    const foundTemplatePathKey = lodash\n      .keys(this.config.templatePaths)\n      .find((key) => path_.startsWith(`@${key}`));\n\n    if (foundTemplatePathKey) {\n      const rawPath = path.resolve(\n        path_.replace(\n          `@${foundTemplatePathKey}`,\n          lodash.get(this.config.templatePaths, foundTemplatePathKey),\n        ),\n      );\n      const fixedPath = this.findTemplateWithExt(rawPath);\n\n      if (fixedPath) {\n        return this.fileSystem.getFileContent(fixedPath);\n      }\n    }\n\n    const customPath =\n      this.config.templatePaths.custom &&\n      this.findTemplateWithExt(\n        path.resolve(this.config.templatePaths.custom, path_),\n      );\n\n    if (customPath) {\n      return this.fileSystem.getFileContent(customPath);\n    }\n\n    const originalPath = this.findTemplateWithExt(\n      path.resolve(this.config.templatePaths.original, path_),\n    );\n\n    if (originalPath) {\n      return this.fileSystem.getFileContent(originalPath);\n    }\n\n    return \"\";\n  };\n\n  renderTemplate = (\n    template: string,\n    configuration: Record<string, unknown>,\n  ) => {\n    if (!template) return \"\";\n\n    return eta.render(\n      eta.compile(template, { async: false }),\n      {\n        ...this.getRenderTemplateData(),\n        ...configuration,\n      },\n      {\n        // @ts-expect-error eta's meta options lack includeFile despite runtime support\n        includeFile: (path: string, configuration: Record<string, string>) =>\n          this.renderTemplate(this.getTemplateContent(path), configuration),\n      },\n    );\n  };\n}\n","import type { CodeFormatter } from \"../code-formatter.js\";\nimport type { CodeGenConfig } from \"../configuration.js\";\n\nexport interface TranslatorIO {\n  fileName: string;\n  fileExtension: string;\n  fileContent: string;\n}\n\nexport class Translator {\n  config: CodeGenConfig;\n  codeFormatter: CodeFormatter;\n\n  constructor(config: CodeGenConfig, codeFormatter: CodeFormatter) {\n    this.config = config;\n    this.codeFormatter = codeFormatter;\n  }\n\n  translate(_input: TranslatorIO): Promise<TranslatorIO[]> {\n    throw new Error(\"not implemented\");\n  }\n}\n","import * as typescript from \"typescript\";\nimport { Translator, type TranslatorIO } from \"./translator.js\";\n\nexport class JavascriptTranslator extends Translator {\n  compileTSCode = (input: TranslatorIO): Record<string, string> => {\n    const fileNameFull = `${input.fileName}${input.fileExtension}`;\n    const output = {};\n    const host = typescript.createCompilerHost(\n      this.config.compilerTsConfig,\n      true,\n    );\n    const fileNames = [fileNameFull];\n    const originalSourceFileGet = host.getSourceFile.bind(host);\n    host.getSourceFile = (\n      sourceFileName,\n      languageVersion,\n      onError,\n      shouldCreateNewSourceFile,\n    ) => {\n      if (sourceFileName !== fileNameFull)\n        return originalSourceFileGet(\n          sourceFileName,\n          languageVersion,\n          onError,\n          shouldCreateNewSourceFile,\n        );\n\n      return typescript.createSourceFile(\n        sourceFileName,\n        input.fileContent,\n        languageVersion,\n        true,\n        typescript.ScriptKind.TS,\n      );\n    };\n\n    host.writeFile = (fileName, contents) => {\n      output[fileName] = contents;\n    };\n\n    typescript\n      .createProgram(fileNames, this.config.compilerTsConfig, host)\n      .emit();\n\n    return output;\n  };\n\n  translate = async (input) => {\n    const compiled = this.compileTSCode(input);\n\n    const jsFileName = `${input.fileName}${typescript.Extension.Js}`;\n    const dtsFileName = `${input.fileName}${typescript.Extension.Dts}`;\n    const sourceContent = compiled[jsFileName];\n    const tsImportRows = input.fileContent\n      .split(\"\\n\")\n      .filter((line) => line.startsWith(\"import \"));\n    const declarationContent = compiled[dtsFileName]\n      .split(\"\\n\")\n      .map((line) => {\n        if (line.startsWith(\"import \")) {\n          return tsImportRows.shift();\n        }\n        return line;\n      })\n      .join(\"\\n\");\n\n    return [\n      {\n        fileName: input.fileName,\n        fileExtension: typescript.Extension.Js,\n        fileContent: await this.codeFormatter.formatCode(sourceContent),\n      },\n      {\n        fileName: input.fileName,\n        fileExtension: typescript.Extension.Dts,\n        fileContent: await this.codeFormatter.formatCode(declarationContent),\n      },\n    ];\n  };\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport type { CodeGenConfig } from \"./configuration.js\";\n\ntype FormattingSchemaType = \"enum-key\" | \"type-name\";\n\nexport class TypeNameFormatter {\n  formattedModelNamesMap = new Map<string, string>();\n  config: CodeGenConfig;\n\n  constructor(config: CodeGenConfig) {\n    this.config = config;\n  }\n\n  format = (name: string, options: { type?: FormattingSchemaType } = {}) => {\n    const schemaType = options.type ?? \"type-name\";\n\n    const typePrefix =\n      schemaType === \"enum-key\"\n        ? this.config.enumKeyPrefix\n        : this.config.typePrefix;\n    const typeSuffix =\n      schemaType === \"enum-key\"\n        ? this.config.enumKeySuffix\n        : this.config.typeSuffix;\n\n    const hashKey = `${typePrefix}_${name}_${typeSuffix}`;\n\n    if (typeof name !== \"string\") {\n      consola.warn(\"wrong model name\", name);\n      return name;\n    }\n\n    // constant names like LEFT_ARROW, RIGHT_FORWARD, ETC_KEY, _KEY_NUM_\n    if (/^(?!\\d)([A-Z0-9_]{1,})$/g.test(name)) {\n      return lodash.compact([typePrefix, name, typeSuffix]).join(\"_\");\n    }\n\n    if (this.formattedModelNamesMap.has(hashKey)) {\n      return this.formattedModelNamesMap.get(hashKey);\n    }\n\n    const fixedModelName = this.fixModelName(name, { type: schemaType });\n\n    const formattedName = lodash\n      .startCase(`${typePrefix}_${fixedModelName}_${typeSuffix}`)\n      .replace(/\\s/g, \"\");\n    const formattedResultName =\n      this.config.hooks.onFormatTypeName(formattedName, name, schemaType) ||\n      formattedName;\n\n    this.formattedModelNamesMap.set(hashKey, formattedResultName);\n\n    return formattedResultName;\n  };\n\n  isValidName = (name: string) => /^([A-Za-z$_]{1,})$/g.test(name);\n\n  fixModelName = (\n    name: string,\n    options: { type?: FormattingSchemaType },\n  ): string => {\n    if (!this.isValidName(name)) {\n      if (!/^[a-zA-Z_$]/g.test(name)) {\n        const fixPrefix =\n          options.type === \"enum-key\"\n            ? this.config.fixInvalidEnumKeyPrefix\n            : this.config.fixInvalidTypeNamePrefix;\n        return `${fixPrefix} ${name}`;\n      }\n\n      // specific replaces for TSOA 3.x\n      if (name.includes(\".\")) {\n        return name\n          .replace(/Exclude_keyof[A-Za-z]+/g, () => \"ExcludeKeys\")\n          .replace(/%22~AND~%22/g, \"And\")\n          .replace(/%22~OR~%22/g, \"Or\")\n          .replace(/(\\.?%22)|\\./g, \"_\")\n          .replace(/__+$/, \"\");\n      }\n\n      if (name.includes(\"-\")) {\n        return lodash.startCase(name).replace(/ /g, \"\");\n      }\n    }\n\n    return name;\n  };\n}\n","import * as fs from \"node:fs\";\nimport * as path from \"node:path\";\nimport * as url from \"node:url\";\nimport { consola } from \"consola\";\nimport { FILE_PREFIX } from \"../constants.js\";\n\nexport class FileSystem {\n  getFileContent = (path: string) => {\n    return fs.readFileSync(path, { encoding: \"utf8\" });\n  };\n\n  readDir = (path: string) => {\n    return fs.readdirSync(path);\n  };\n\n  pathIsDir = (path: string) => {\n    if (!path) return false;\n\n    try {\n      const stat = fs.statSync(path);\n      return stat.isDirectory();\n    } catch (e) {\n      return false;\n    }\n  };\n\n  cropExtension = (fileName: string) => {\n    const fileNameParts = fileName.split(\".\");\n\n    if (fileNameParts.length > 1) {\n      fileNameParts.pop();\n    }\n\n    return fileNameParts.join(\".\");\n  };\n\n  removeDir = (path: string) => {\n    try {\n      if (typeof fs.rmSync === \"function\") {\n        fs.rmSync(path, { recursive: true });\n      } else {\n        fs.rmdirSync(path, { recursive: true });\n      }\n    } catch (e) {\n      consola.debug(\"failed to remove dir\", e);\n    }\n  };\n\n  createDir = (path: string) => {\n    try {\n      fs.mkdirSync(path, { recursive: true });\n    } catch (e) {\n      consola.debug(\"failed to create dir\", e);\n    }\n  };\n\n  cleanDir = (path: string) => {\n    this.removeDir(path);\n    this.createDir(path);\n  };\n\n  pathIsExist = (path: string) => {\n    return !!path && fs.existsSync(path);\n  };\n\n  createFile = ({ path: path_, fileName, content, withPrefix }) => {\n    const __dirname = path.dirname(url.fileURLToPath(import.meta.url));\n    const absolutePath = path.resolve(__dirname, path_, `./${fileName}`);\n    const fileContent = `${withPrefix ? FILE_PREFIX : \"\"}${content}`;\n\n    return fs.writeFileSync(absolutePath, fileContent);\n  };\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport * as typescript from \"typescript\";\nimport type {\n  GenerateApiConfiguration,\n  SchemaComponent,\n} from \"../types/index.js\";\nimport { CodeFormatter } from \"./code-formatter.js\";\nimport { CodeGenConfig } from \"./configuration.js\";\nimport { SchemaComponentsMap } from \"./schema-components-map.js\";\nimport { SchemaParserFabric } from \"./schema-parser/schema-parser-fabric.js\";\nimport { SchemaRoutes } from \"./schema-routes/schema-routes.js\";\nimport { SchemaWalker } from \"./schema-walker.js\";\nimport { SwaggerSchemaResolver } from \"./swagger-schema-resolver.js\";\nimport { TemplatesWorker } from \"./templates-worker.js\";\nimport { JavascriptTranslator } from \"./translators/javascript.js\";\nimport type { TranslatorIO } from \"./translators/translator.js\";\nimport { TypeNameFormatter } from \"./type-name-formatter.js\";\nimport { FileSystem } from \"./util/file-system.js\";\nimport { internalCase } from \"./util/internal-case.js\";\nimport { NameResolver } from \"./util/name-resolver.js\";\nimport { pascalCase } from \"./util/pascal-case.js\";\nimport { sortByProperty } from \"./util/sort-by-property.js\";\n\nconst PATCHABLE_INSTANCES = [\n  \"schemaWalker\",\n  \"swaggerSchemaResolver\",\n  \"schemaComponentsMap\",\n  \"typeNameFormatter\",\n  \"templatesWorker\",\n  \"codeFormatter\",\n  \"schemaParserFabric\",\n  \"schemaRoutes\",\n  \"javascriptTranslator\",\n];\n\nexport class CodeGenProcess {\n  config: CodeGenConfig;\n  swaggerSchemaResolver: SwaggerSchemaResolver;\n  schemaComponentsMap: SchemaComponentsMap;\n  typeNameFormatter: TypeNameFormatter;\n  schemaParserFabric: SchemaParserFabric;\n  schemaRoutes: SchemaRoutes;\n  fileSystem: FileSystem;\n  codeFormatter: CodeFormatter;\n  templatesWorker: TemplatesWorker;\n  schemaWalker: SchemaWalker;\n  javascriptTranslator: JavascriptTranslator;\n\n  constructor(config: Partial<GenerateApiConfiguration[\"config\"]>) {\n    this.config = new CodeGenConfig(config);\n    this.fileSystem = new FileSystem();\n    this.swaggerSchemaResolver = new SwaggerSchemaResolver(\n      this.config,\n      this.fileSystem,\n    );\n    this.schemaWalker = new SchemaWalker(\n      this.config,\n      this.swaggerSchemaResolver,\n    );\n    this.schemaComponentsMap = new SchemaComponentsMap(this.config);\n    this.typeNameFormatter = new TypeNameFormatter(this.config);\n    this.templatesWorker = new TemplatesWorker(\n      this.config,\n      this.fileSystem,\n      this.getRenderTemplateData,\n    );\n    this.codeFormatter = new CodeFormatter(this.config);\n    this.schemaParserFabric = new SchemaParserFabric(\n      this.config,\n      this.templatesWorker,\n      this.schemaComponentsMap,\n      this.typeNameFormatter,\n      this.schemaWalker,\n    );\n    this.schemaRoutes = new SchemaRoutes(\n      this.config,\n      this.schemaParserFabric,\n      this.schemaComponentsMap,\n      this.templatesWorker,\n      this.typeNameFormatter,\n    );\n    this.javascriptTranslator = new JavascriptTranslator(\n      this.config,\n      this.codeFormatter,\n    );\n  }\n\n  async start() {\n    this.config.update({\n      templatePaths: this.templatesWorker.getTemplatePaths(this.config),\n    });\n    this.config.update({\n      templatesToRender: this.templatesWorker.getTemplates(this.config),\n    });\n\n    const swagger = await this.swaggerSchemaResolver.create();\n\n    this.swaggerSchemaResolver.fixSwaggerSchema(swagger);\n\n    this.config.update({\n      swaggerSchema: swagger.usageSchema,\n      originalSchema: swagger.originalSchema,\n    });\n\n    this.schemaWalker.addSchema(\"$usage\", swagger.usageSchema);\n    this.schemaWalker.addSchema(\"$original\", swagger.originalSchema);\n\n    consola.info(\"start generating your typescript api\");\n\n    this.config.update(\n      this.config.hooks.onInit(this.config, this) || this.config,\n    );\n\n    if (this.config.swaggerSchema) {\n      swagger.usageSchema = this.config.swaggerSchema;\n    }\n    if (this.config.originalSchema) {\n      swagger.originalSchema = this.config.originalSchema;\n    }\n\n    this.schemaComponentsMap.clear();\n\n    lodash.each(swagger.usageSchema.components, (component, componentName) =>\n      lodash.each(component, (rawTypeData, typeName) => {\n        this.schemaComponentsMap.createComponent(\n          this.schemaComponentsMap.createRef([\n            \"components\",\n            componentName,\n            typeName,\n          ]),\n          rawTypeData,\n        );\n      }),\n    );\n\n    // Set all discriminators at the top\n    this.schemaComponentsMap.discriminatorsFirst();\n    // Put all enums at the top (before discriminators)\n    this.schemaComponentsMap.enumsFirst();\n\n    const componentsToParse: SchemaComponent[] =\n      this.schemaComponentsMap.filter(\n        lodash.compact([\n          \"schemas\",\n          this.config.extractResponses && \"responses\",\n        ]),\n      );\n\n    const parsedSchemas = componentsToParse.map((schemaComponent) => {\n      const parsed = this.schemaParserFabric.parseSchema(\n        schemaComponent.rawTypeData,\n        schemaComponent.typeName,\n      );\n      schemaComponent.typeData = parsed;\n      return parsed;\n    });\n\n    this.schemaRoutes.attachSchema({\n      usageSchema: swagger.usageSchema,\n      parsedSchemas,\n    });\n\n    const rawConfiguration = {\n      apiConfig: this.createApiConfig(swagger.usageSchema),\n      config: this.config,\n      modelTypes: this.collectModelTypes(),\n      hasSecurityRoutes: this.schemaRoutes.hasSecurityRoutes,\n      hasQueryRoutes: this.schemaRoutes.hasQueryRoutes,\n      hasFormDataRoutes: this.schemaRoutes.hasFormDataRoutes,\n      generateResponses: this.config.generateResponses,\n      routes: this.schemaRoutes.getGroupedRoutes(),\n      extraTemplates: this.config.extraTemplates,\n      fileName: this.config.fileName,\n      translateToJavaScript: this.config.toJS,\n      customTranslator: this.config.customTranslator\n        ? new this.config.customTranslator()\n        : null,\n      utils: this.getRenderTemplateData().utils,\n    };\n\n    const configuration =\n      this.config.hooks.onPrepareConfig(rawConfiguration) || rawConfiguration;\n\n    if (this.fileSystem.pathIsExist(this.config.output)) {\n      if (this.config.cleanOutput) {\n        consola.debug(\"cleaning dir\", this.config.output);\n        this.fileSystem.cleanDir(this.config.output);\n      }\n    } else {\n      consola.debug(\n        `path ${this.config.output} is not exist. creating dir by this path`,\n      );\n      this.fileSystem.createDir(this.config.output);\n    }\n\n    const files = await this.generateOutputFiles({\n      configuration: configuration,\n    });\n\n    const isDirPath = this.fileSystem.pathIsDir(this.config.output);\n\n    if (isDirPath) {\n      for (const file of files) {\n        this.fileSystem.createFile({\n          path: this.config.output,\n          fileName: `${file.fileName}${file.fileExtension}`,\n          content: file.fileContent,\n          withPrefix: true,\n        });\n\n        consola.success(\n          \"api file\",\n          `\"${file.fileName}${file.fileExtension}\"`,\n          `created in ${this.config.output}`,\n        );\n      }\n    }\n\n    return {\n      files,\n      configuration,\n      getTemplate: this.templatesWorker.getTemplate,\n      renderTemplate: this.templatesWorker.renderTemplate,\n      createFile: this.fileSystem.createFile,\n      formatTSContent: this.codeFormatter.formatCode,\n    };\n  }\n\n  getRenderTemplateData = () => {\n    return {\n      utils: {\n        Ts: this.config.Ts,\n        formatDescription:\n          this.schemaParserFabric.schemaFormatters.formatDescription,\n        internalCase: internalCase,\n        classNameCase: pascalCase,\n        pascalCase: pascalCase,\n        getInlineParseContent: this.schemaParserFabric.getInlineParseContent,\n        getParseContent: this.schemaParserFabric.getParseContent,\n        getComponentByRef: this.schemaComponentsMap.get,\n        parseSchema: this.schemaParserFabric.parseSchema,\n        checkAndAddNull: this.schemaParserFabric.schemaUtils.safeAddNullToType,\n        safeAddNullToType:\n          this.schemaParserFabric.schemaUtils.safeAddNullToType,\n        isNeedToAddNull:\n          this.schemaParserFabric.schemaUtils.isNullMissingInType,\n        inlineExtraFormatters: this.schemaParserFabric.schemaFormatters.inline,\n        formatters: this.schemaParserFabric.schemaFormatters.base,\n        formatModelName: this.typeNameFormatter.format,\n        fmtToJSDocLine: (line: string, { eol = true }) => {\n          return ` * ${line}${eol ? \"\\n\" : \"\"}`;\n        },\n        NameResolver: NameResolver,\n        _: lodash,\n        require: this.templatesWorker.requireFnFromTemplate,\n      },\n      config: this.config,\n    };\n  };\n\n  collectModelTypes = () => {\n    const components = this.schemaComponentsMap.getComponents();\n    let modelTypes = [];\n\n    const modelTypeComponents = lodash.compact([\n      \"schemas\",\n      this.config.extractResponses && \"responses\",\n    ]);\n\n    const getSchemaComponentsCount = () =>\n      this.schemaComponentsMap.filter(...modelTypeComponents).length;\n\n    let schemaComponentsCount = getSchemaComponentsCount();\n    let processedCount = 0;\n\n    while (processedCount < schemaComponentsCount) {\n      modelTypes = [];\n      processedCount = 0;\n      for (const component of components) {\n        if (modelTypeComponents.includes(component.componentName)) {\n          const modelType = this.prepareModelType(component);\n          if (modelType) {\n            modelTypes.push(modelType);\n          }\n          processedCount++;\n        }\n      }\n      schemaComponentsCount = getSchemaComponentsCount();\n    }\n\n    if (this.config.sortTypes) {\n      return modelTypes.sort(sortByProperty(\"name\"));\n    }\n\n    return modelTypes;\n  };\n\n  prepareModelType = (typeInfo) => {\n    if (typeInfo.$prepared) return typeInfo.$prepared;\n\n    if (!typeInfo.typeData) {\n      typeInfo.typeData = this.schemaParserFabric.parseSchema(\n        typeInfo.rawTypeData,\n        typeInfo.typeName,\n      );\n    }\n    const rawTypeData = typeInfo.typeData;\n    const typeData = this.schemaParserFabric.schemaFormatters.base[\n      rawTypeData.type\n    ]\n      ? this.schemaParserFabric.schemaFormatters.base[rawTypeData.type](\n          rawTypeData,\n        )\n      : rawTypeData;\n    const {\n      typeIdentifier,\n      name: originalName,\n      content,\n      description,\n    } = typeData;\n    const name = this.typeNameFormatter.format(originalName);\n\n    if (name === null) return null;\n\n    const preparedModelType = {\n      ...typeData,\n      typeIdentifier,\n      name,\n      description,\n      $content: rawTypeData.content,\n      rawContent: rawTypeData.content,\n      content: content,\n      typeData,\n    };\n\n    typeInfo.$prepared = preparedModelType;\n\n    return preparedModelType;\n  };\n\n  generateOutputFiles = async ({ configuration }): Promise<TranslatorIO[]> => {\n    const { modular, templatesToRender } = this.config;\n\n    const output = modular\n      ? await this.createMultipleFileInfos(templatesToRender, configuration)\n      : await this.createSingleFileInfo(templatesToRender, configuration);\n\n    if (!lodash.isEmpty(configuration.extraTemplates)) {\n      for (const extraTemplate of configuration.extraTemplates) {\n        const content = this.templatesWorker.renderTemplate(\n          this.fileSystem.getFileContent(extraTemplate.path),\n          configuration,\n        );\n        output.push(\n          ...(await this.createOutputFileInfo(\n            configuration,\n            extraTemplate.name,\n            content,\n          )),\n        );\n      }\n    }\n\n    return output.filter((fileInfo) => !!fileInfo && !!fileInfo.fileContent);\n  };\n\n  createMultipleFileInfos = async (\n    templatesToRender,\n    configuration,\n  ): Promise<TranslatorIO[]> => {\n    const { routes } = configuration;\n    const { fileNames, generateRouteTypes, generateClient } =\n      configuration.config;\n    const modularApiFileInfos: TranslatorIO[] = [];\n\n    if (routes.$outOfModule) {\n      if (generateRouteTypes) {\n        const outOfModuleRouteContent = this.templatesWorker.renderTemplate(\n          templatesToRender.routeTypes,\n          {\n            ...configuration,\n            route: configuration.routes.$outOfModule,\n          },\n        );\n\n        modularApiFileInfos.push(\n          ...(await this.createOutputFileInfo(\n            configuration,\n            fileNames.outOfModuleApi,\n            outOfModuleRouteContent,\n          )),\n        );\n      }\n      if (generateClient) {\n        const outOfModuleApiContent = this.templatesWorker.renderTemplate(\n          templatesToRender.api,\n          {\n            ...configuration,\n            route: configuration.routes.$outOfModule,\n          },\n        );\n\n        modularApiFileInfos.push(\n          ...(await this.createOutputFileInfo(\n            configuration,\n            fileNames.outOfModuleApi,\n            outOfModuleApiContent,\n          )),\n        );\n      }\n    }\n\n    if (routes.combined) {\n      for (const route of routes.combined) {\n        if (generateRouteTypes) {\n          const routeModuleContent = this.templatesWorker.renderTemplate(\n            templatesToRender.routeTypes,\n            {\n              ...configuration,\n              route,\n            },\n          );\n\n          modularApiFileInfos.push(\n            ...(await this.createOutputFileInfo(\n              configuration,\n              pascalCase(`${route.moduleName}_Route`),\n              routeModuleContent,\n            )),\n          );\n        }\n\n        if (generateClient) {\n          const apiModuleContent = this.templatesWorker.renderTemplate(\n            templatesToRender.api,\n            {\n              ...configuration,\n              route,\n            },\n          );\n\n          modularApiFileInfos.push(\n            ...(await this.createOutputFileInfo(\n              configuration,\n              pascalCase(route.moduleName),\n              apiModuleContent,\n            )),\n          );\n        }\n      }\n    }\n\n    return [\n      ...(await this.createOutputFileInfo(\n        configuration,\n        fileNames.dataContracts,\n        this.templatesWorker.renderTemplate(\n          templatesToRender.dataContracts,\n          configuration,\n        ),\n      )),\n      ...(generateClient\n        ? await this.createOutputFileInfo(\n            configuration,\n            fileNames.httpClient,\n            this.templatesWorker.renderTemplate(\n              templatesToRender.httpClient,\n              configuration,\n            ),\n          )\n        : []),\n      ...modularApiFileInfos,\n    ];\n  };\n\n  createSingleFileInfo = async (\n    templatesToRender,\n    configuration,\n  ): Promise<TranslatorIO[]> => {\n    const { generateRouteTypes, generateClient } = configuration.config;\n\n    return await this.createOutputFileInfo(\n      configuration,\n      configuration.fileName,\n      lodash\n        .compact([\n          this.templatesWorker.renderTemplate(\n            templatesToRender.dataContracts,\n            configuration,\n          ),\n          generateRouteTypes &&\n            this.templatesWorker.renderTemplate(\n              templatesToRender.routeTypes,\n              configuration,\n            ),\n          generateClient &&\n            this.templatesWorker.renderTemplate(\n              templatesToRender.httpClient,\n              configuration,\n            ),\n          generateClient &&\n            this.templatesWorker.renderTemplate(\n              templatesToRender.api,\n              configuration,\n            ),\n        ])\n        .join(\"\\n\"),\n    );\n  };\n\n  createOutputFileInfo = async (\n    configuration,\n    fileNameFull,\n    content,\n  ): Promise<TranslatorIO[]> => {\n    const fileName = this.fileSystem.cropExtension(fileNameFull);\n    const fileExtension = typescript.Extension.Ts;\n\n    if (configuration.translateToJavaScript) {\n      consola.debug(\"using js translator for\", fileName);\n      return await this.javascriptTranslator.translate({\n        fileName: fileName,\n        fileExtension: fileExtension,\n        fileContent: content,\n      });\n    }\n\n    if (configuration.customTranslator) {\n      consola.debug(\"using custom translator for\", fileName);\n      return await configuration.customTranslator.translate({\n        fileName: fileName,\n        fileExtension: fileExtension,\n        fileContent: content,\n      });\n    }\n\n    consola.debug(\"generating output for\", `${fileName}${fileExtension}`);\n\n    return [\n      {\n        fileName,\n        fileExtension: fileExtension,\n        fileContent: await this.codeFormatter.formatCode(content),\n      },\n    ];\n  };\n\n  createApiConfig = (swaggerSchema) => {\n    const { info, servers, host, basePath, externalDocs, tags } = swaggerSchema;\n    const server = servers?.[0] || { url: \"\" };\n    const { title = \"No title\", version } = info || {};\n    const { url: serverUrl } = server;\n\n    return {\n      info: info || {},\n      servers: servers || [],\n      basePath,\n      host,\n      externalDocs: lodash.merge(\n        {\n          url: \"\",\n          description: \"\",\n        },\n        externalDocs,\n      ),\n      tags: lodash.compact(tags),\n      baseUrl: serverUrl,\n      title,\n      version,\n    };\n  };\n\n  injectClassInstance = (key, value) => {\n    this[key] = value;\n    for (const instanceKey of PATCHABLE_INSTANCES) {\n      if (instanceKey !== key && key in this[instanceKey]) {\n        this[instanceKey][key] = value;\n      }\n    }\n  };\n}\n","import type { ComponentTypeNameResolver } from \"../src/component-type-name-resolver.js\";\nimport type * as CONSTANTS from \"../src/constants.js\";\nimport type { MonoSchemaParser } from \"../src/schema-parser/mono-schema-parser.js\";\nimport type { Translator } from \"../src/translators/translator.js\";\n\nexport type HttpClientType =\n  (typeof CONSTANTS.HTTP_CLIENT)[keyof typeof CONSTANTS.HTTP_CLIENT];\n\ntype CodeGenConstruct = {\n  Keyword: {\n    Number: string;\n    String: string;\n    Boolean: string;\n    Any: string;\n    Void: string;\n    Unknown: string;\n    Null: string;\n    Undefined: string;\n    Object: string;\n    File: string;\n    Date: string;\n    Type: string;\n    Enum: string;\n    Interface: string;\n    Array: string;\n    Record: string;\n    Intersection: string;\n    Union: string;\n  };\n  CodeGenKeyword: {\n    UtilRequiredKeys: string;\n  };\n  ArrayType: (content: unknown) => string;\n  StringValue: (content: unknown) => string;\n  BooleanValue: (content: unknown) => string;\n  NumberValue: (content: unknown) => string;\n  NullValue: (content: unknown) => string;\n  UnionType: (content: unknown) => string;\n  ExpressionGroup: (content: unknown) => string;\n  IntersectionType: (content: unknown) => string;\n  RecordType: (content: unknown) => string;\n  TypeField: (content: unknown) => string;\n  InterfaceDynamicField: (content: unknown) => string;\n  EnumUsageKey: (enumStruct: unknown, key: unknown) => string;\n  EnumField: (content: unknown) => string;\n  EnumFieldDescription: (content: unknown) => string;\n  EnumFieldsWrapper: (content: unknown) => string;\n  ObjectWrapper: (content: unknown) => string;\n  MultilineComment: (content: unknown) => string;\n  TypeWithGeneric: (content: unknown) => string;\n  Tuple: (content: unknown) => string;\n};\n\ntype PrimitiveTypeStructValue =\n  | string\n  | ((\n      schema: Record<string, unknown>,\n      parser: import(\"../src/schema-parser/schema-parser.js\").SchemaParser,\n    ) => string);\n\ntype PrimitiveTypeStruct = Record<\n  \"integer\" | \"number\" | \"boolean\" | \"object\" | \"file\" | \"string\" | \"array\",\n  | string\n  | ({ $default: PrimitiveTypeStructValue } & Record<\n      string,\n      PrimitiveTypeStructValue\n    >)\n>;\n\ninterface GenerateApiParamsFromPath\n  extends Partial<GenerateApiConfiguration[\"config\"]> {\n  /**\n   * path to swagger schema\n   */\n  input: string;\n}\n\ninterface GenerateApiParamsFromUrl\n  extends Partial<GenerateApiConfiguration[\"config\"]> {\n  /**\n   * url to swagger schema\n   */\n  url: string;\n}\n\ninterface GenerateApiParamsFromSpecLiteral\n  extends Partial<GenerateApiConfiguration[\"config\"]> {\n  /**\n   * swagger schema JSON\n   */\n  spec: import(\"swagger-schema-official\").Spec;\n}\n\nexport type GenerateApiParams =\n  | GenerateApiParamsFromPath\n  | GenerateApiParamsFromUrl\n  | GenerateApiParamsFromSpecLiteral;\n\ntype BuildRouteParam = {\n  /** {bar} */\n  $match: string;\n  name: string;\n  required: boolean;\n  type: \"string\";\n  description: string;\n  schema: {\n    type: string;\n  };\n  in: \"path\" | \"query\";\n};\n\ntype BuildRoutePath = {\n  /** /foo/{bar}/baz */\n  originalRoute: string;\n  /** /foo/${bar}/baz */\n  route: string;\n  pathParams: BuildRouteParam[];\n  queryParams: BuildRouteParam[];\n};\n\nexport interface Hooks {\n  /** calls before parse\\process route path */\n  onPreBuildRoutePath: (routePath: string) => string | undefined;\n  /** calls after parse\\process route path */\n  onBuildRoutePath: (data: BuildRoutePath) => BuildRoutePath | undefined;\n  /** calls before insert path param name into string path interpolation */\n  onInsertPathParam: (\n    paramName: string,\n    index: number,\n    arr: BuildRouteParam[],\n    resultRoute: string,\n  ) => string | undefined;\n  /** calls after parse schema component */\n  onCreateComponent: (\n    component: SchemaComponent,\n  ) => SchemaComponent | undefined;\n  /** calls before parse any kind of schema */\n  onPreParseSchema: (\n    originalSchema: unknown,\n    typeName: string,\n    schemaType: string,\n  ) => undefined;\n  /** calls after parse any kind of schema */\n  onParseSchema: (\n    originalSchema: unknown,\n    parsedSchema: unknown,\n  ) => unknown | undefined;\n  /** calls after parse route (return type: customized route (ParsedRoute), nothing change (void), false (ignore this route)) */\n  onCreateRoute: (routeData: ParsedRoute) => ParsedRoute | false | undefined;\n  /** Start point of work this tool (after fetching schema) */\n  onInit?: <C extends GenerateApiConfiguration[\"config\"]>(\n    configuration: C,\n    codeGenProcess: import(\"../src/code-gen-process.js\").CodeGenProcess,\n  ) => C | undefined;\n  /** customize configuration object before sending it to ETA templates */\n  onPrepareConfig?: <C extends GenerateApiConfiguration>(\n    currentConfiguration: C,\n  ) => C | undefined;\n  /** customize route name as you need */\n  onCreateRouteName?: (\n    routeNameInfo: RouteNameInfo,\n    rawRouteInfo: RawRouteInfo,\n  ) => RouteNameInfo | undefined;\n  /** customize request params (path params, query params) */\n  onCreateRequestParams?: (\n    rawType: SchemaComponent[\"rawTypeData\"],\n  ) => SchemaComponent[\"rawTypeData\"] | undefined;\n  /** customize name of model type */\n  onFormatTypeName?: (\n    typeName: string,\n    rawTypeName?: string,\n    schemaType?: \"type-name\" | \"enum-key\",\n  ) => string | undefined;\n  /** customize name of route (operationId), you can do it with using onCreateRouteName too */\n  onFormatRouteName?: (\n    routeInfo: RawRouteInfo,\n    templateRouteName: string,\n  ) => string | undefined;\n}\n\nexport type RouteNameRouteInfo = Record<string, unknown>;\n\nexport type RouteNameInfo = {\n  usage: string;\n  original: string;\n  duplicate: boolean;\n};\n\nexport type SchemaTypePrimitiveContent = {\n  $parsedSchema: boolean;\n  schemaType: string;\n  type: string;\n  typeIdentifier: string;\n  name?: unknown;\n  description: string;\n  content: string;\n};\n\nexport type SchemaTypeObjectContent = {\n  $$raw: {\n    type: string;\n    required: boolean;\n    $parsed: SchemaTypePrimitiveContent;\n  };\n  isRequired: boolean;\n  field: string;\n}[];\n\nexport type SchemaTypeEnumContent = {\n  key: string;\n  type: string;\n  value: string;\n};\n\nexport interface ParsedSchema<C> {\n  $parsedSchema: boolean;\n  schemaType: string;\n  type: string;\n  typeIdentifier: string;\n  name: string;\n  description?: string;\n  allFieldsAreOptional?: boolean;\n  content: C;\n  isExtractedRequestParams?: boolean;\n  isExtractedRequestBody?: boolean;\n  isExtractedResponseBody?: boolean;\n  isExtractedResponseError?: boolean;\n}\n\nexport interface PathArgInfo {\n  name: string;\n  optional: boolean;\n  type: string;\n  description?: string;\n}\n\nexport interface SchemaComponent {\n  $ref: string;\n  typeName: string;\n  rawTypeData?: {\n    type: string;\n    required?: string[];\n    properties?: Record<\n      string,\n      {\n        name?: string;\n        type: string;\n        required: boolean;\n        $parsed?: SchemaTypePrimitiveContent;\n      }\n    >;\n    discriminator?: {\n      propertyName?: string;\n    };\n    $parsed: ParsedSchema<\n      | SchemaTypeObjectContent\n      | SchemaTypeEnumContent\n      | SchemaTypePrimitiveContent\n    >;\n  };\n  componentName: \"schemas\" | \"paths\";\n  typeData: ParsedSchema<\n    SchemaTypeObjectContent | SchemaTypeEnumContent | SchemaTypePrimitiveContent\n  > | null;\n}\n\nexport enum RequestContentKind {\n  JSON = \"JSON\",\n  URL_ENCODED = \"URL_ENCODED\",\n  FORM_DATA = \"FORM_DATA\",\n  IMAGE = \"IMAGE\",\n  OTHER = \"OTHER\",\n  TEXT = \"TEXT\",\n}\n\nexport interface RequestResponseInfo {\n  contentTypes: string[];\n  contentKind: RequestContentKind;\n  type: string;\n  description: string;\n  status: string | number;\n  isSuccess: boolean;\n}\n\nexport type RawRouteInfo = {\n  operationId: string;\n  method: string;\n  route: string;\n  moduleName: string;\n  responsesTypes: RequestResponseInfo[];\n  description?: string;\n  tags?: string[];\n  summary?: string;\n  responses?: import(\"swagger-schema-official\").Spec[\"responses\"];\n  produces?: string[];\n  requestBody?: object;\n  consumes?: string[];\n};\n\nexport interface ParsedRouteRequest {\n  contentTypes?: string[];\n  formData?: boolean;\n  headers?: {\n    name: string | null;\n    optional: boolean | undefined;\n    type: Record<string, any>;\n  };\n  isQueryBody?: boolean;\n  method?: string;\n  parameters?: Record<string, unknown>[];\n  path?: string;\n  pathParams?: Record<string, unknown>;\n  payload?: { name: string | null; optional?: boolean; type: string };\n  query?: Record<string, unknown>;\n  requestParams?: Record<string, unknown> | null;\n  security?: boolean;\n}\n\nexport interface ParsedRouteResponse {\n  contentTypes?: string[];\n  errorType?: string;\n  fullTypes?: string;\n  type?: string;\n}\n\nexport interface ParsedRoute {\n  id: string;\n  namespace: string;\n  // biome-ignore lint/suspicious/noExplicitAny: TODO\n  routeParams?: Record<string, any>;\n  requestBodyInfo?: {\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    paramName: any;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    contentTypes: any[];\n    contentKind: string;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    schema: any;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    type: any;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    required: any;\n  };\n  responseBodyInfo?: {\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    contentTypes: any[];\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    responses: any[];\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    success?: Record<string, any>;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    error?: Record<string, any>;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO\n    full?: Record<string, any>;\n  };\n  // biome-ignore lint/suspicious/noExplicitAny: TODO\n  specificArgs?: Record<string, any>;\n  // biome-ignore lint/suspicious/noExplicitAny: TODO\n  queryObjectSchema?: Record<string, any>;\n  // biome-ignore lint/suspicious/noExplicitAny: TODO\n  pathObjectSchema?: Record<string, any>;\n  // biome-ignore lint/suspicious/noExplicitAny: TODO\n  headersObjectSchema?: Record<string, any>;\n  // biome-ignore lint/suspicious/noExplicitAny: TODO\n  responseBodySchema?: Record<string, any>;\n  requestBodySchema?: Record<string, any>;\n  specificArgNameResolver?: Record<string, any>;\n  request: ParsedRouteRequest;\n  response: ParsedRouteResponse;\n  routeName: RouteNameInfo;\n  raw: RawRouteInfo;\n}\n\nexport type ModelType = {\n  typeIdentifier: string;\n  name: string;\n  rawContent: string;\n  description: string;\n  content: string;\n};\n\nexport enum SCHEMA_TYPES {\n  ARRAY = \"array\",\n  OBJECT = \"object\",\n  ENUM = \"enum\",\n  REF = \"$ref\",\n  PRIMITIVE = \"primitive\",\n  COMPLEX = \"complex\",\n  COMPLEX_ONE_OF = \"oneOf\",\n  COMPLEX_ANY_OF = \"anyOf\",\n  COMPLEX_ALL_OF = \"allOf\",\n  COMPLEX_NOT = \"not\",\n  COMPLEX_UNKNOWN = \"__unknown\",\n}\n\ntype MAIN_SCHEMA_TYPES =\n  | SCHEMA_TYPES.PRIMITIVE\n  | SCHEMA_TYPES.OBJECT\n  | SCHEMA_TYPES.ENUM;\n\nexport type ExtractingOptions = {\n  requestBodySuffix: string[];\n  responseBodySuffix: string[];\n  responseErrorSuffix: string[];\n  requestParamsSuffix: string[];\n  enumSuffix: string[];\n  discriminatorMappingSuffix: string[];\n  discriminatorAbstractPrefix: string[];\n  requestBodyNameResolver: (\n    name: string,\n    reservedNames: string,\n  ) => string | undefined;\n  responseBodyNameResolver: (\n    name: string,\n    reservedNames: string,\n  ) => string | undefined;\n  responseErrorNameResolver: (\n    name: string,\n    reservedNames: string,\n  ) => string | undefined;\n  requestParamsNameResolver: (\n    name: string,\n    reservedNames: string,\n  ) => string | undefined;\n  enumNameResolver: (name: string, reservedNames: string) => string | undefined;\n  discriminatorMappingNameResolver: (\n    name: string,\n    reservedNames: string,\n  ) => string | undefined;\n  discriminatorAbstractResolver: (\n    name: string,\n    reservedNames: string,\n  ) => string | undefined;\n};\n\nexport interface GenerateApiConfiguration {\n  apiConfig: {\n    /** base url from schema */\n    baseUrl: string;\n    /** document title */\n    title: string;\n    /** document version */\n    version: string;\n    /** description split into lines */\n    description: string[];\n    /** flag that description is present */\n    hasDescription: boolean;\n  };\n  config: {\n    /** path to swagger schema */\n    input: string;\n    /**\n     * generate separated files for http client, data contracts, and routes\n     * @default false\n     */\n    modular: boolean;\n    /**\n     * path to folder where the created api module will be placed.\n     * may be set to `false` to skip writing content to disk; in this case\n     * the `files` array on the return value will contain the generated contents.\n     */\n    output: string | false;\n    /** url to swagger schema */\n    url: string;\n    /** swagger schema JSON */\n    spec: unknown;\n    /**\n     * file name for the generated API module\n     * @default 'Api.ts'\n     */\n    fileName: string;\n    /**\n     * path to folder containing custom templates\n     * @default \"\"\n     */\n    templates: string;\n    templatePaths: {\n      /** `templates/base` */\n      base: string;\n      /** `templates/default` */\n      default: string;\n      /** `templates/modular` */\n      modular: string;\n      /** usage path if `--templates` option is not set */\n      original: string;\n      /** custom path to templates (`--templates`) */\n      custom: string | null;\n    };\n    /** authorisation token for private swagger schema access */\n    authorizationToken?: string;\n    /** generate additional information about request responses and error typings */\n    generateResponses: boolean;\n    /**\n     * use \"default\" response status code as success response.\n     * some swagger schemas treat \"default\" as a successful response.\n     */\n    defaultResponseAsSuccess: boolean;\n    /** generate type definitions for API routes */\n    generateRouteTypes: boolean;\n    /** generate an API client */\n    generateClient: boolean;\n    /** generate all \"enum\" types as union types (T1 | T2 | TN) */\n    generateUnionEnums: boolean;\n    /** parsed swagger schema */\n    swaggerSchema: object;\n    /** original swagger schema */\n    originalSchema: object;\n    /** map of schema component references */\n    componentsMap: Record<string, SchemaComponent>;\n    /** flag indicating the schema was converted from Swagger 2.0 */\n    convertedFromSwagger2: boolean;\n    /** determines which path index should be used for routes separation */\n    moduleNameIndex: number;\n    /** use the first tag for the module name */\n    moduleNameFirstTag: boolean;\n    /** extra templates */\n    extraTemplates: { name: string; path: string }[];\n    /** extract request params to data contract */\n    extractRequestParams: boolean;\n    /** unwrap the data item from the response */\n    unwrapResponseData: boolean;\n    /** sort data contracts in alphabetical order */\n    sortTypes: boolean;\n    /** sort routes in alphabetical order */\n    sortRoutes: boolean;\n    /** ability to send HttpClient instance to Api constructor */\n    singleHttpClient: boolean;\n    /** prefix string value for type names */\n    typePrefix: string;\n    /** suffix string value for type names */\n    typeSuffix: string;\n    /** prefix string value for enum keys */\n    enumKeyPrefix: string;\n    /** suffix string value for enum keys */\n    enumKeySuffix: string;\n    /** fix up small errors in the swagger source definition */\n    patch: boolean;\n    /** remove output directory before generating */\n    cleanOutput: boolean;\n    /** output debug messages */\n    debug: boolean;\n    /**\n     * generate array types as Array<Type>\n     * @default false\n     */\n    anotherArrayType: boolean;\n    /** extract request body type to data contract */\n    extractRequestBody: boolean;\n    /** generated http client type */\n    httpClientType: \"axios\" | \"fetch\";\n    /** generate readonly properties */\n    addReadonly: boolean;\n    /** customise primitive type mappings */\n    primitiveTypeConstructs?: (\n      struct: PrimitiveTypeStruct,\n    ) => Partial<PrimitiveTypeStruct>;\n    /** customise code generation constructs */\n    codeGenConstructs?: (struct: CodeGenConstruct) => Partial<CodeGenConstruct>;\n    /** extract response body type to data contract */\n    extractResponseBody: boolean;\n    /** extract response error type to data contract */\n    extractResponseError: boolean;\n    /** extract all enums from nested types/interfaces to `enum` construction */\n    extractEnums: boolean;\n    /** extract all enums from inline interface/type content to typescript enum construction */\n    extractResponses: boolean;\n    /**\n     * prefix string value needed to fix invalid type names\n     * @default \"Type\"\n     */\n    fixInvalidTypeNamePrefix: string;\n    /**\n     * prefix string value needed to fix invalid enum keys\n     * @default \"Value\"\n     */\n    fixInvalidEnumKeyPrefix: string;\n    /**\n     * default type for empty response schema\n     * @default \"void\"\n     */\n    defaultResponseType: string;\n    /**\n     * generate js api module with declaration file\n     * @default false\n     */\n    toJS: boolean;\n    /** disable throwing on a non-successful response */\n    disableThrowOnError: boolean;\n    /**\n     * output only errors to console\n     * @default false\n     */\n    silent: boolean;\n    /** hooks for customising the generation process */\n    hooks: Partial<Hooks>;\n    /** use enum names as values */\n    enumNamesAsValues: boolean;\n    /** package version */\n    version: string;\n    /** ts compiler configuration object (for --to-js option) */\n    compilerTsConfig: Record<string, unknown>;\n    /** enum key resolver name */\n    enumKeyResolverName: string;\n    /** type name resolver name */\n    typeNameResolverName: string;\n    /** specific argument name resolver name */\n    specificArgNameResolverName: string;\n    /**\n     * custom ts->* translator\n     * do not use constructor args, just send class reference\n     */\n    customTranslator?: new () => Translator;\n    /** internal constants */\n    constants: typeof CONSTANTS;\n    /** code generation constructs for TypeScript */\n    Ts: CodeGenConstruct;\n    /**\n     * swagger schema type -> typescript type\n     * https://json-schema.org/understanding-json-schema/reference/string.html#dates-and-times\n     */\n    primitiveTypes: PrimitiveTypeStruct;\n    /** built-in template info */\n    templateInfos: { name: string; fileName: string }[];\n    /** supported template file extensions */\n    templateExtensions: string[];\n    /** range of HTTP status codes treated as success */\n    successResponseStatusRange: [number, number];\n    /** custom schema parsers */\n    schemaParsers?: {\n      complexOneOf?: MonoSchemaParser;\n      complexAllOf?: MonoSchemaParser;\n      complexAnyOf?: MonoSchemaParser;\n      complexNot?: MonoSchemaParser;\n      enum?: MonoSchemaParser;\n      object?: MonoSchemaParser;\n      complex?: MonoSchemaParser;\n      primitive?: MonoSchemaParser;\n      discriminator?: MonoSchemaParser;\n      array?: MonoSchemaParser;\n    };\n    /** internal options for templates */\n    internalTemplateOptions: {\n      addUtilRequiredKeysType: boolean;\n    };\n    /** resolver for component type names */\n    componentTypeNameResolver: ComponentTypeNameResolver;\n    /** generated file names */\n    fileNames: {\n      dataContracts: string;\n      routeTypes: string;\n      httpClient: string;\n      outOfModuleApi: string;\n    };\n    /** Record<templateName, templateContent> */\n    templatesToRender: {\n      api: string;\n      dataContracts: string;\n      httpClient: string;\n      routeTypes: string;\n      routeName: string;\n      dataContractJsDoc: string;\n      interfaceDataContract: string;\n      typeDataContract: string;\n      enumDataContract: string;\n      objectFieldJsDoc: string;\n    };\n    /** map of duplicate route names */\n    routeNameDuplicatesMap: Map<string, string>;\n    /** name of the main exported class */\n    apiClassName: string;\n    /** configuration for fetching swagger schema requests */\n    requestOptions?: Partial<RequestInit>;\n    /** extra configuration for extracting type names operations */\n    extractingOptions: Partial<ExtractingOptions>;\n    /** update configuration object during generation */\n    update: (update: Partial<GenerateApiConfiguration[\"config\"]>) => void;\n  };\n  modelTypes: ModelType[];\n  hasFormDataRoutes: boolean;\n  hasSecurityRoutes: boolean;\n  hasQueryRoutes: boolean;\n  generateResponses: boolean;\n  routes: {\n    outOfModule: ParsedRoute[];\n    combined?: {\n      moduleName: string;\n      routes: ParsedRoute[];\n    }[];\n  };\n  requestOptions?: Partial<RequestInit>;\n  utils: {\n    formatDescription: (description: string, inline?: boolean) => string;\n    internalCase: (value: string) => string;\n    /** @deprecated */\n    classNameCase: (value: string) => string;\n    pascalCase: (value: string) => string;\n    getInlineParseContent: (\n      rawTypeData: SchemaComponent[\"rawTypeData\"],\n      typeName?: string,\n    ) => string;\n    getParseContent: (\n      rawTypeData: SchemaComponent[\"rawTypeData\"],\n      typeName?: string,\n    ) => ModelType;\n    getComponentByRef: (ref: string) => SchemaComponent;\n    parseSchema: (\n      rawSchema: string | SchemaComponent[\"rawTypeData\"],\n      typeName?: string,\n      formattersMap?: Record<MAIN_SCHEMA_TYPES, (content: ModelType) => string>,\n    ) => ModelType;\n    formatters: Record<\n      MAIN_SCHEMA_TYPES,\n      (content: string | object | string[] | object[]) => string\n    >;\n    inlineExtraFormatters: Record<\n      Exclude<MAIN_SCHEMA_TYPES, SCHEMA_TYPES.PRIMITIVE>,\n      (schema: ModelType) => string\n    >;\n    formatModelName: (name: string) => string;\n    fmtToJSDocLine: (line: string, params?: { eol?: boolean }) => string;\n    _: import(\"lodash\").LoDashStatic;\n    require: (path: string) => unknown;\n  };\n}\n\ntype FileInfo = {\n  /** @example myFilename */\n  fileName: string;\n  /** @example .d.ts */\n  fileExtension: string;\n  /** content of the file */\n  fileContent: string;\n};\n\nexport interface GenerateApiOutput {\n  configuration: GenerateApiConfiguration;\n  files: FileInfo[];\n  createFile: (params: {\n    path: string;\n    fileName: string;\n    content: string;\n    withPrefix: boolean;\n  }) => void;\n  renderTemplate: (\n    templateContent: string,\n    data: Record<string, unknown>,\n    etaOptions?: Partial<import(\"eta\").EtaConfig>,\n  ) => Promise<string> | string;\n  getTemplate: (params: {\n    fileName?: string;\n    name?: string;\n    path?: string;\n  }) => string;\n  formatTSContent: (content: string) => Promise<string>;\n}\n\nexport declare function generateApi(\n  params: GenerateApiParams,\n): Promise<GenerateApiOutput>;\n\nexport interface GenerateTemplatesParams {\n  cleanOutput?: boolean;\n  output?: string;\n  httpClientType?: HttpClientType;\n  modular?: boolean;\n  rewrite?: boolean;\n  silent?: boolean;\n  debug?: boolean;\n}\n\nexport interface GenerateTemplatesOutput\n  extends Pick<GenerateApiOutput, \"files\" | \"createFile\"> {}\n\nexport declare function generateTemplates(\n  params: GenerateTemplatesParams,\n): Promise<GenerateTemplatesOutput>;\n","import type {\n  GenerateTemplatesParams,\n  HttpClientType,\n} from \"../../../types/index.js\";\nimport { HTTP_CLIENT, PROJECT_VERSION } from \"../../constants.js\";\nimport { objectAssign } from \"../../util/object-assign.js\";\n\nexport class TemplatesGenConfig {\n  cleanOutput = false;\n  debug = false;\n  httpClientType: HttpClientType = HTTP_CLIENT.FETCH;\n  modular = false;\n  output = undefined;\n  rewrite = false;\n  silent = false;\n  version = PROJECT_VERSION;\n\n  constructor(config: GenerateTemplatesParams) {\n    this.update(config);\n  }\n\n  update = (update: Partial<GenerateTemplatesParams>) => {\n    objectAssign(this, update);\n  };\n}\n","import path from \"node:path\";\nimport url from \"node:url\";\nimport { consola } from \"consola\";\nimport type {\n  GenerateTemplatesOutput,\n  GenerateTemplatesParams,\n} from \"../../../types/index.js\";\nimport { FileSystem } from \"../../util/file-system.js\";\nimport { TemplatesGenConfig } from \"./configuration.js\";\n\nconst __dirname = path.dirname(url.fileURLToPath(import.meta.url));\n\nexport class TemplatesGenProcess {\n  config: TemplatesGenConfig;\n  fileSystem: FileSystem;\n\n  rootDir = path.resolve(__dirname, \"..\");\n\n  paths = {\n    baseTemplates: \"templates/base\",\n    httpClientTemplates: \"templates/base/http-clients\",\n    moduleApiTemplates: \"templates/modular\",\n    defaultApiTemplates: \"templates/default\",\n  };\n\n  importTemplatePrefixes = [\"@base\", \"@modular\", \"@default\"];\n\n  constructor(config: GenerateTemplatesParams) {\n    this.config = new TemplatesGenConfig(config);\n    this.fileSystem = new FileSystem();\n  }\n\n  async start(): Promise<GenerateTemplatesOutput> {\n    consola.info('start generating source templates \".ejs\" for code generator');\n\n    const templates = this.getTemplates();\n\n    if (this.config.output) {\n      consola.info(\"preparing output directory for source templates\");\n      const outputPath = path.resolve(process.cwd(), this.config.output);\n\n      if (this.fileSystem.pathIsExist(outputPath)) {\n        if (this.config.cleanOutput) {\n          this.fileSystem.cleanDir(outputPath);\n        }\n      } else {\n        this.fileSystem.createDir(outputPath);\n      }\n\n      for (const template of templates) {\n        const templateName = this.fileSystem.cropExtension(template.name);\n        const templateEjsPath = path.resolve(outputPath, `${templateName}.ejs`);\n        const templateEtaPath = path.resolve(outputPath, `${templateName}.eta`);\n        const templateEjsPathExist =\n          this.fileSystem.pathIsExist(templateEjsPath);\n        const templateEtaPathExist =\n          this.fileSystem.pathIsExist(templateEtaPath);\n\n        const templateNotExist = !templateEjsPathExist && !templateEtaPathExist;\n\n        if (templateNotExist) {\n          this.fileSystem.createFile({\n            path: outputPath,\n            fileName: template.name,\n            content: template.content,\n            withPrefix: false,\n          });\n        } else if (this.config.rewrite) {\n          if (templateEjsPathExist) {\n            this.fileSystem.createFile({\n              path: outputPath,\n              fileName: `${templateName}.ejs`,\n              content: template.content,\n              withPrefix: false,\n            });\n          } else if (templateEtaPathExist) {\n            this.fileSystem.createFile({\n              path: outputPath,\n              fileName: `${templateName}.eta`,\n              content: template.content,\n              withPrefix: false,\n            });\n          }\n        }\n      }\n\n      consola.success(\n        `source templates has been successfully created in \"${outputPath}\"`,\n      );\n    }\n\n    return {\n      files: templates,\n      configuration: this.config,\n      createFile: this.fileSystem.createFile,\n    };\n  }\n\n  getTemplates = () => {\n    const outputFiles = [];\n    const baseTemplates = this.getTemplateNamesFromDir(\n      this.paths.baseTemplates,\n    );\n    const httpClientTemplates = this.getTemplateNamesFromDir(\n      this.paths.httpClientTemplates,\n    );\n    const apiTemplatesPath = this.config.modular\n      ? this.paths.moduleApiTemplates\n      : this.paths.defaultApiTemplates;\n    const apiTemplates = this.getTemplateNamesFromDir(apiTemplatesPath);\n\n    const usingHttpClientTemplate = httpClientTemplates.find((template) =>\n      template.startsWith(`${this.config.httpClientType}-`),\n    );\n\n    let httpClientTemplateContent = \"\";\n\n    if (usingHttpClientTemplate) {\n      httpClientTemplateContent = this.fixTemplateContent(\n        this.getTemplateContent(\n          `${this.paths.httpClientTemplates}/${usingHttpClientTemplate}`,\n        ),\n      );\n    }\n\n    for (const fileName of baseTemplates) {\n      const templateContent =\n        (fileName === \"http-client.ejs\" && httpClientTemplateContent) ||\n        this.fixTemplateContent(\n          this.getTemplateContent(`${this.paths.baseTemplates}/${fileName}`),\n        );\n\n      outputFiles.push({\n        name: fileName,\n        content: templateContent,\n      });\n    }\n\n    for (const fileName of apiTemplates) {\n      outputFiles.push({\n        name: fileName,\n        content: this.fixTemplateContent(\n          this.getTemplateContent(`${apiTemplatesPath}/${fileName}`),\n        ),\n      });\n    }\n\n    return outputFiles;\n  };\n\n  fixTemplateContent = (content) => {\n    // includeFile(\"@base/\n    const importsRegExp1 = new RegExp(\n      `includeFile\\\\(\"(${this.importTemplatePrefixes\n        .map((v) => `(${v})`)\n        .join(\"|\")})/`,\n      \"g\",\n    );\n    // includeFile(`@base/\n    const importsRegExp2 = new RegExp(\n      `includeFile\\\\(\\`(${this.importTemplatePrefixes\n        .map((v) => `(${v})`)\n        .join(\"|\")})/`,\n      \"g\",\n    );\n    // includeFile('@base/\n    const importsRegExp3 = new RegExp(\n      `includeFile\\\\('(${this.importTemplatePrefixes\n        .map((v) => `(${v})`)\n        .join(\"|\")})/`,\n      \"g\",\n    );\n\n    return content\n      .replace(importsRegExp1, 'includeFile(\"./')\n      .replace(importsRegExp2, \"includeFile(`./\")\n      .replace(importsRegExp3, \"includeFile('./\");\n  };\n\n  getTemplateNamesFromDir = (dir) => {\n    return this.fileSystem\n      .readDir(path.resolve(this.rootDir, dir))\n      .filter((file) => file.endsWith(\".ejs\"));\n  };\n\n  getTemplateContent = (pathToFile) => {\n    return this.fileSystem.getFileContent(\n      path.resolve(this.rootDir, pathToFile),\n    );\n  };\n}\n","import { consola } from \"consola\";\nimport type { GenerateTemplatesParams } from \"../../../types/index.js\";\nimport { TemplatesGenProcess } from \"./templates-gen-process.js\";\n\nexport async function generateTemplates(config: GenerateTemplatesParams) {\n  if (config.debug) consola.level = Number.MAX_SAFE_INTEGER;\n  if (config.silent) consola.level = 0;\n  const codeGenProcess = new TemplatesGenProcess(config);\n  return await codeGenProcess.start();\n}\n","import { consola } from \"consola\";\nimport type { GenerateApiConfiguration } from \"../types/index.js\";\nimport { CodeGenProcess } from \"./code-gen-process.js\";\n\nexport * from \"../types/index.js\";\n\nexport async function generateApi(\n  config: Partial<GenerateApiConfiguration[\"config\"]>,\n) {\n  if (config.debug) consola.level = Number.MAX_SAFE_INTEGER;\n  if (config.silent) consola.level = 0;\n  const codeGenProcess = new CodeGenProcess(config);\n  return await codeGenProcess.start();\n}\n\nexport { generateTemplates } from \"./commands/generate-templates/index.js\";\nexport * as constants from \"./constants.js\";\n"],"mappings":"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"}