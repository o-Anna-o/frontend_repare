//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (all) => {
	let target = {};
	for (var name$1 in all) __defProp(target, name$1, {
		get: all[name$1],
		enumerable: true
	});
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let consola = require("consola");
consola = __toESM(consola);
let lodash = require("lodash");
lodash = __toESM(lodash);
let typescript = require("typescript");
typescript = __toESM(typescript);
let node_path = require("node:path");
node_path = __toESM(node_path);
let __biomejs_js_api = require("@biomejs/js-api");
__biomejs_js_api = __toESM(__biomejs_js_api);
let nanoid = require("nanoid");
nanoid = __toESM(nanoid);
let swagger2openapi = require("swagger2openapi");
swagger2openapi = __toESM(swagger2openapi);
let yaml = require("yaml");
yaml = __toESM(yaml);
let node_module = require("node:module");
node_module = __toESM(node_module);
let node_url = require("node:url");
node_url = __toESM(node_url);
let eta = require("eta");
eta = __toESM(eta);
let node_fs = require("node:fs");
node_fs = __toESM(node_fs);

//#region src/code-formatter.ts
var CodeFormatter = class {
	config;
	constructor(config) {
		this.config = config;
	}
	removeUnusedImports = (content) => {
		const tempFileName = "file.ts";
		const host = new TsLanguageServiceHost(tempFileName, content);
		const fileTextChanges = typescript.createLanguageService(host).organizeImports({
			type: "file",
			fileName: tempFileName
		}, { newLineCharacter: typescript.sys.newLine }, void 0)[0];
		if (fileTextChanges?.textChanges.length) return fileTextChanges.textChanges.reduceRight((content$1, { span, newText }) => `${content$1.slice(0, span.start)}${newText}${content$1.slice(span.start + span.length)}`, content);
		return content;
	};
	format = async (content) => {
		const biome = await __biomejs_js_api.Biome.create({ distribution: __biomejs_js_api.Distribution.NODE });
		const biomeProject = biome.openProject();
		biome.applyConfiguration(biomeProject.projectKey, {
			files: { maxSize: Number.MAX_SAFE_INTEGER },
			formatter: { indentStyle: "space" }
		});
		return biome.formatContent(biomeProject.projectKey, content, { filePath: node_path.format({
			name: nanoid.nanoid(),
			ext: "ts"
		}) }).content;
	};
	formatCode = async (code, { removeUnusedImports = true, format = true } = {}) => {
		if (removeUnusedImports) code = this.removeUnusedImports(code);
		if (format) code = await this.format(code);
		return code;
	};
};
var TsLanguageServiceHost = class {
	fileName;
	content;
	compilerOptions;
	constructor(fileName, content) {
		this.fileName = fileName;
		this.content = content;
		const tsconfig = typescript.findConfigFile(fileName, typescript.sys.fileExists);
		this.compilerOptions = tsconfig ? typescript.convertCompilerOptionsFromJson(typescript.readConfigFile(tsconfig, typescript.sys.readFile).config.compilerOptions, "").options : typescript.getDefaultCompilerOptions();
	}
	getNewLine() {
		return "newLine" in typescript.sys ? typescript.sys.newLine : "\n";
	}
	getScriptFileNames() {
		return [this.fileName];
	}
	getCompilationSettings() {
		return this.compilerOptions;
	}
	getDefaultLibFileName() {
		return typescript.getDefaultLibFileName(this.getCompilationSettings());
	}
	getCurrentDirectory() {
		return process.cwd();
	}
	getScriptVersion() {
		return typescript.version;
	}
	getScriptSnapshot() {
		return typescript.ScriptSnapshot.fromString(this.content);
	}
	readFile(fileName, encoding) {
		if (fileName === this.fileName) return this.content;
		return typescript.sys.readFile(fileName, encoding);
	}
	fileExists(path$1) {
		return typescript.sys.fileExists(path$1);
	}
};

//#endregion
//#region src/util/name-resolver.ts
var NameResolver = class {
	reservedNames = [];
	getFallbackName;
	config;
	constructor(config, reservedNames, getFallbackName) {
		this.config = config;
		this.getFallbackName = getFallbackName;
		this.reserve(reservedNames);
	}
	reserve(names) {
		const fixedNames = lodash.default.uniq(lodash.default.compact(names));
		for (const name$1 of fixedNames) if (this.reservedNames.indexOf(name$1) === -1) this.reservedNames.push(name$1);
	}
	unreserve(names) {
		this.reservedNames = this.reservedNames.filter((reservedName) => !names.some((name$1) => name$1 === reservedName));
	}
	isReserved(name$1) {
		return this.reservedNames.some((reservedName) => reservedName === name$1);
	}
	resolve(variants, resolver, extras, shouldReserve = true) {
		if (typeof resolver === "function") {
			let usageName = null;
			while (usageName === null) {
				const variant = resolver(variants, extras);
				if (variant === void 0) {
					consola.consola.warn("unable to resolve name. current reserved names: ", ...this.reservedNames);
					return null;
				}
				if (!shouldReserve || !this.isReserved(variant)) usageName = variant;
			}
			shouldReserve && this.reserve([usageName]);
			return usageName;
		}
		if (Array.isArray(variants)) {
			let usageName = null;
			const uniqVariants = lodash.default.uniq(lodash.default.compact(variants));
			for (const variant of uniqVariants) if (!usageName && (!shouldReserve || !this.isReserved(variant))) usageName = variant;
			if (usageName) {
				shouldReserve && this.reserve([usageName]);
				return usageName;
			}
			consola.consola.debug("trying to resolve name with using fallback name generator using variants", ...variants);
			return this.resolve(variants, this.getFallbackName, extras);
		}
		consola.consola.debug("problem with reserving names. current reserved names: ", ...this.reservedNames);
		return null;
	}
};

//#endregion
//#region src/util/random.ts
const getRandomFloat = (min = 0, max = 1) => {
	return Math.random() * (max - min) + min;
};
const getRandomInt = (min = 0, max = 1) => {
	if (min === max) return min;
	return Math.round(getRandomFloat(min, max));
};

//#endregion
//#region src/component-type-name-resolver.ts
var ComponentTypeNameResolver = class extends NameResolver {
	counter = 1;
	fallbackNameCounter = 1;
	countersByVariant = /* @__PURE__ */ new Map();
	constructor(config, reservedNames) {
		super(config, reservedNames, (variants) => {
			const randomVariant = variants[getRandomInt(0, variants.length - 1)];
			if (randomVariant) {
				if (!this.countersByVariant.has(randomVariant)) this.countersByVariant.set(randomVariant, 0);
				const variantCounter = this.countersByVariant.get(randomVariant) + 1;
				this.countersByVariant.set(randomVariant, variantCounter);
				const dirtyResolvedName = `${randomVariant}${variantCounter}`;
				consola.consola.debug("generated dirty resolved type name for component - ", dirtyResolvedName);
				return dirtyResolvedName;
			}
			const fallbackName = `${this.config.componentTypeNameResolver}${this.fallbackNameCounter++}`;
			consola.consola.debug("generated fallback type name for component - ", fallbackName);
			return fallbackName;
		});
	}
};

//#endregion
//#region package.json
var name = "swagger-typescript-api";
var version = "13.2.16";
var description = "Generate the API client for Fetch or Axios from an OpenAPI Specification";

//#endregion
//#region src/constants.ts
var constants_exports = /* @__PURE__ */ __export({
	DEFAULT_BODY_ARG_NAME: () => DEFAULT_BODY_ARG_NAME,
	FILE_PREFIX: () => FILE_PREFIX,
	HTTP_CLIENT: () => HTTP_CLIENT,
	PROJECT_VERSION: () => PROJECT_VERSION,
	RESERVED_BODY_ARG_NAMES: () => RESERVED_BODY_ARG_NAMES,
	RESERVED_HEADER_ARG_NAMES: () => RESERVED_HEADER_ARG_NAMES,
	RESERVED_PATH_ARG_NAMES: () => RESERVED_PATH_ARG_NAMES,
	RESERVED_QUERY_ARG_NAMES: () => RESERVED_QUERY_ARG_NAMES,
	RESERVED_REQ_PARAMS_ARG_NAMES: () => RESERVED_REQ_PARAMS_ARG_NAMES,
	SCHEMA_TYPES: () => SCHEMA_TYPES$1
});
const DEFAULT_BODY_ARG_NAME = "data";
const FILE_PREFIX = `/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

`;
const HTTP_CLIENT = {
	FETCH: "fetch",
	AXIOS: "axios"
};
const PROJECT_VERSION = version;
const RESERVED_BODY_ARG_NAMES = [
	"data",
	"body",
	"reqBody"
];
const RESERVED_HEADER_ARG_NAMES = ["headers", "headersParams"];
const RESERVED_PATH_ARG_NAMES = ["path", "pathParams"];
const RESERVED_QUERY_ARG_NAMES = [
	"query",
	"queryParams",
	"queryArg"
];
const RESERVED_REQ_PARAMS_ARG_NAMES = [
	"params",
	"requestParams",
	"reqParams",
	"httpParams"
];
const SCHEMA_TYPES$1 = {
	ARRAY: "array",
	OBJECT: "object",
	ENUM: "enum",
	REF: "$ref",
	PRIMITIVE: "primitive",
	COMPLEX: "complex",
	DISCRIMINATOR: "discriminator",
	COMPLEX_ONE_OF: "oneOf",
	COMPLEX_ANY_OF: "anyOf",
	COMPLEX_ALL_OF: "allOf",
	COMPLEX_NOT: "not",
	COMPLEX_UNKNOWN: "__unknown"
};

//#endregion
//#region src/util/object-assign.ts
const objectAssign = (target, updater) => {
	if (!updater) return;
	const update = typeof updater === "function" ? updater(target) : updater;
	const undefinedKeys = lodash.default.map(update, (value, key) => value === void 0 && key).filter((key) => typeof key === "string");
	Object.assign(target, lodash.default.merge(target, update));
	for (const key of undefinedKeys) target[key] = void 0;
};

//#endregion
//#region src/configuration.ts
const TsKeyword = {
	Number: "number",
	String: "string",
	Boolean: "boolean",
	Any: "any",
	Void: "void",
	Unknown: "unknown",
	Null: "null",
	Undefined: "undefined",
	Object: "object",
	File: "File",
	Date: "Date",
	Type: "type",
	Enum: "enum",
	Interface: "interface",
	Array: "Array",
	Record: "Record",
	Intersection: "&",
	Union: "|"
};
const TsCodeGenKeyword = { UtilRequiredKeys: "UtilRequiredKeys" };
var CodeGenConfig = class {
	version = PROJECT_VERSION;
	/** CLI flag */
	templates = "";
	/** CLI flag */
	generateResponses = false;
	/** CLI flag */
	defaultResponseAsSuccess = false;
	/** CLI flag */
	generateRouteTypes = false;
	/** CLI flag */
	generateClient = true;
	/** CLI flag */
	generateUnionEnums = false;
	/** CLI flag */
	addReadonly = false;
	enumNamesAsValues = false;
	/** parsed swagger schema from getSwaggerObject() */
	/** parsed swagger schema ref */
	swaggerSchema = null;
	/** original (converted to json) swagger schema ref */
	originalSchema = null;
	/** { "#/components/schemas/Foo": @TypeInfo, ... } */
	componentsMap = {};
	/** flag for catching conversion from swagger 2.0 */
	convertedFromSwagger2 = false;
	/** url index from paths used for merging into modules */
	moduleNameIndex = 0;
	/** use the first tag for the module name */
	moduleNameFirstTag = false;
	extractRequestParams = false;
	extractRequestBody = false;
	extractResponseBody = false;
	extractResponseError = false;
	extractResponses = false;
	extractEnums = false;
	fileNames = {
		dataContracts: "data-contracts",
		routeTypes: "route-types",
		httpClient: "http-client",
		outOfModuleApi: "Common"
	};
	routeNameDuplicatesMap = /* @__PURE__ */ new Map();
	hooks = {
		onPreBuildRoutePath: (_routePath) => void 0,
		onBuildRoutePath: (_routeData) => void 0,
		onInsertPathParam: (_pathParam) => void 0,
		onCreateComponent: (schema) => schema,
		onPreParseSchema: (_originalSchema, _typeName, _schemaType) => void 0,
		onParseSchema: (_originalSchema, parsedSchema) => parsedSchema,
		onCreateRoute: (routeData) => routeData,
		onInit: (config, _codeGenProcess) => config,
		onPrepareConfig: (apiConfig) => apiConfig,
		onCreateRequestParams: (_rawType) => {},
		onCreateRouteName: () => {},
		onFormatTypeName: (_typeName, _rawTypeName, _schemaType) => {},
		onFormatRouteName: (_routeInfo, _templateRouteName) => {}
	};
	defaultResponseType;
	singleHttpClient = false;
	httpClientType = HTTP_CLIENT.FETCH;
	unwrapResponseData = false;
	disableThrowOnError = false;
	sortTypes = false;
	sortRoutes = false;
	templatePaths = {
		base: "",
		default: "",
		modular: "",
		original: "",
		custom: ""
	};
	/** Record<templateName, templateContent> */
	templatesToRender = {
		api: "",
		dataContracts: "",
		dataContractJsDoc: "",
		interfaceDataContract: "",
		typeDataContract: "",
		enumDataContract: "",
		objectFieldJsDoc: "",
		httpClient: "",
		routeTypes: "",
		routeName: ""
	};
	schemaParsers = {};
	toJS = false;
	silent = false;
	typePrefix = "";
	typeSuffix = "";
	enumKeyPrefix = "";
	enumKeySuffix = "";
	patch = false;
	componentTypeNameResolver;
	/** name of the main exported class */
	apiClassName = "Api";
	debug = false;
	anotherArrayType = false;
	internalTemplateOptions = { addUtilRequiredKeysType: false };
	extraTemplates = [];
	input = "";
	modular = false;
	output = "";
	url = "";
	cleanOutput = false;
	spec = null;
	fileName = "Api.ts";
	authorizationToken;
	requestOptions = null;
	jsPrimitiveTypes = [];
	jsEmptyTypes = [];
	fixInvalidTypeNamePrefix = "Type";
	fixInvalidEnumKeyPrefix = "Value";
	enumKeyResolverName = "Value";
	typeNameResolverName = "ComponentType";
	specificArgNameResolverName = "arg";
	successResponseStatusRange = [200, 299];
	extractingOptions = {
		requestBodySuffix: [
			"Payload",
			"Body",
			"Input"
		],
		requestParamsSuffix: ["Params"],
		responseBodySuffix: [
			"Data",
			"Result",
			"Output"
		],
		responseErrorSuffix: [
			"Error",
			"Fail",
			"Fails",
			"ErrorData",
			"HttpError",
			"BadResponse"
		],
		enumSuffix: ["Enum"],
		discriminatorMappingSuffix: [
			"Mapping",
			"Mapper",
			"MapType"
		],
		discriminatorAbstractPrefix: [
			"Base",
			"Abstract",
			"Discriminator",
			"Internal",
			"Polymorph"
		]
	};
	compilerTsConfig = {
		module: typescript.ModuleKind.ESNext,
		noImplicitReturns: true,
		alwaysStrict: true,
		target: typescript.ScriptTarget.ESNext,
		declaration: true,
		noImplicitAny: false,
		sourceMap: false,
		removeComments: false,
		disableSizeLimit: true,
		esModuleInterop: true,
		emitDecoratorMetadata: true,
		skipLibCheck: true
	};
	customTranslator;
	Ts = {
		Keyword: structuredClone(TsKeyword),
		CodeGenKeyword: structuredClone(TsCodeGenKeyword),
		ArrayType: (content) => {
			if (this.anotherArrayType) return this.Ts.TypeWithGeneric(this.Ts.Keyword.Array, [content]);
			return `${this.Ts.ExpressionGroup(content)}[]`;
		},
		StringValue: (content) => `"${content}"`,
		BooleanValue: (content) => `${content}`,
		NumberValue: (content) => `${content}`,
		NullValue: () => "null",
		UnionType: (contents) => lodash.default.join(lodash.default.uniq(contents), ` ${this.Ts.Keyword.Union} `),
		ExpressionGroup: (content) => content ? `(${content})` : "",
		IntersectionType: (contents) => lodash.default.join(lodash.default.uniq(contents), ` ${this.Ts.Keyword.Intersection} `),
		RecordType: (key, value) => this.Ts.TypeWithGeneric(this.Ts.Keyword.Record, [key, value]),
		TypeField: ({ readonly, key, optional, value }) => lodash.default.compact([
			readonly && "readonly ",
			key,
			optional && "?",
			": ",
			value
		]).join(""),
		InterfaceDynamicField: (key, value) => `[key: ${key}]: ${value}`,
		EnumUsageKey: (enumStruct, key) => `${enumStruct}.${key}`,
		EnumField: (key, value) => `${key} = ${value}`,
		EnumFieldDescription: (description$1) => {
			if (description$1) return `  /** ${description$1} */`;
			else return "";
		},
		EnumFieldsWrapper: (contents) => lodash.default.map(contents, ({ key, value, description: description$1 }) => {
			return [this.Ts.EnumFieldDescription(description$1), `  ${this.Ts.EnumField(key, value)}`].filter(Boolean).join("\n");
		}).join(",\n"),
		ObjectWrapper: (content) => `{\n${content}\n}`,
		MultilineComment: (contents, formatFn) => [...contents.length === 1 ? [`/** ${contents[0]} */`] : [
			"/**",
			...contents.map((content) => ` * ${content}`),
			" */"
		]].map((part) => `${formatFn ? formatFn(part) : part}\n`),
		TypeWithGeneric: (typeName, genericArgs) => {
			return `${typeName}${genericArgs.length ? `<${genericArgs.join(",")}>` : ""}`;
		},
		Tuple: (values) => {
			return `[${values.join(", ")}]`;
		}
	};
	/**
	* swagger schema type -> typescript type
	* https://json-schema.org/understanding-json-schema/reference/string.html#dates-and-times
	*/
	primitiveTypes = {
		integer: () => this.Ts.Keyword.Number,
		number: () => this.Ts.Keyword.Number,
		boolean: () => this.Ts.Keyword.Boolean,
		object: () => this.Ts.Keyword.Object,
		file: () => this.Ts.Keyword.File,
		string: {
			$default: this.Ts.Keyword.String,
			binary: () => this.Ts.Keyword.File,
			file: () => this.Ts.Keyword.File,
			"date-time": () => this.Ts.Keyword.String,
			time: () => this.Ts.Keyword.String,
			date: () => this.Ts.Keyword.String,
			duration: () => this.Ts.Keyword.String,
			email: () => this.Ts.Keyword.String,
			"idn-email": () => this.Ts.Keyword.String,
			"idn-hostname": () => this.Ts.Keyword.String,
			ipv4: () => this.Ts.Keyword.String,
			ipv6: () => this.Ts.Keyword.String,
			uuid: () => this.Ts.Keyword.String,
			uri: () => this.Ts.Keyword.String,
			"uri-reference": () => this.Ts.Keyword.String,
			"uri-template": () => this.Ts.Keyword.String,
			"json-pointer": () => this.Ts.Keyword.String,
			"relative-json-pointer": () => this.Ts.Keyword.String,
			regex: () => this.Ts.Keyword.String
		}
	};
	templateInfos = [
		{
			name: "api",
			fileName: "api"
		},
		{
			name: "dataContracts",
			fileName: "data-contracts"
		},
		{
			name: "dataContractJsDoc",
			fileName: "data-contract-jsdoc"
		},
		{
			name: "interfaceDataContract",
			fileName: "interface-data-contract"
		},
		{
			name: "typeDataContract",
			fileName: "type-data-contract"
		},
		{
			name: "enumDataContract",
			fileName: "enum-data-contract"
		},
		{
			name: "objectFieldJsDoc",
			fileName: "object-field-jsdoc"
		},
		{
			name: "httpClient",
			fileName: "http-client"
		},
		{
			name: "routeTypes",
			fileName: "route-types"
		},
		{
			name: "routeName",
			fileName: "route-name"
		}
	];
	templateExtensions = [".eta", ".ejs"];
	constructor({ codeGenConstructs, primitiveTypeConstructs, constants, templateInfos, hooks,...otherConfig }) {
		objectAssign(this.Ts, codeGenConstructs);
		objectAssign(this.primitiveTypes, primitiveTypeConstructs);
		this.defaultResponseType = this.Ts.Keyword.Void;
		this.update({
			...otherConfig,
			hooks: lodash.default.merge(this.hooks, hooks || {}),
			constants: {
				...constants_exports,
				...constants
			},
			templateInfos: templateInfos || this.templateInfos
		});
		this.jsPrimitiveTypes = [
			this.Ts.Keyword.Number,
			this.Ts.Keyword.String,
			this.Ts.Keyword.Boolean
		];
		this.jsEmptyTypes = [this.Ts.Keyword.Null, this.Ts.Keyword.Undefined];
		this.componentTypeNameResolver = new ComponentTypeNameResolver(this, []);
	}
	update = (update) => {
		objectAssign(this, update);
		if (this.enumNamesAsValues) this.extractEnums = true;
	};
};

//#endregion
//#region src/schema-components-map.ts
var SchemaComponentsMap = class {
	_data = [];
	config;
	constructor(config) {
		this.config = config;
	}
	clear() {
		this._data = [];
	}
	createRef = (paths) => {
		return ["#", ...paths].join("/");
	};
	parseRef = (ref) => {
		return ref.split("/");
	};
	createComponent($ref, rawTypeData) {
		const parsed = this.parseRef($ref);
		const componentSchema = {
			$ref,
			typeName: parsed[parsed.length - 1],
			rawTypeData,
			componentName: parsed[parsed.length - 2],
			typeData: null
		};
		const usageComponent = this.config.hooks.onCreateComponent(componentSchema) || componentSchema;
		const refIndex = this._data.findIndex((c) => c.$ref === $ref);
		if (refIndex === -1) this._data.push(usageComponent);
		else this._data[refIndex] = usageComponent;
		return usageComponent;
	}
	getComponents() {
		return this._data;
	}
	filter(...componentNames) {
		return this._data.filter((it) => componentNames.some((componentName) => it.$ref.startsWith(`#/components/${componentName}`)));
	}
	get = ($ref) => {
		return this._data.find((c) => c.$ref === $ref) || null;
	};
	enumsFirst() {
		this._data.sort((a, b) => {
			if (Object.keys(a.rawTypeData || {}).includes("enum")) return -1;
			if (Object.keys(b.rawTypeData || {}).includes("enum")) return 1;
			return 0;
		});
	}
	discriminatorsFirst() {
		this._data.sort((a, b) => {
			if (Object.keys(a.rawTypeData || {}).includes("discriminator")) return -1;
			if (Object.keys(b.rawTypeData || {}).includes("discriminator")) return 1;
			return 0;
		});
	}
};

//#endregion
//#region src/schema-parser/schema-formatters.ts
var SchemaFormatters = class {
	config;
	templatesWorker;
	schemaUtils;
	constructor(schemaParser) {
		this.config = schemaParser.config;
		this.schemaUtils = schemaParser.schemaUtils;
		this.templatesWorker = schemaParser.templatesWorker;
	}
	base = {
		[SCHEMA_TYPES$1.ENUM]: (parsedSchema) => {
			if (this.config.generateUnionEnums) return {
				...parsedSchema,
				$content: parsedSchema.content,
				content: this.config.Ts.UnionType(parsedSchema.content.map(({ value }) => value))
			};
			return {
				...parsedSchema,
				$content: parsedSchema.content,
				content: this.config.Ts.EnumFieldsWrapper(parsedSchema.content)
			};
		},
		[SCHEMA_TYPES$1.OBJECT]: (parsedSchema) => {
			if (parsedSchema.nullable) return this.inline[SCHEMA_TYPES$1.OBJECT](parsedSchema);
			return {
				...parsedSchema,
				$content: parsedSchema.content,
				content: this.formatObjectContent(parsedSchema.content)
			};
		},
		[SCHEMA_TYPES$1.PRIMITIVE]: (parsedSchema) => {
			return {
				...parsedSchema,
				$content: parsedSchema.content
			};
		}
	};
	inline = {
		[SCHEMA_TYPES$1.ENUM]: (parsedSchema) => {
			return {
				...parsedSchema,
				content: parsedSchema.$ref ? parsedSchema.typeName : this.config.Ts.UnionType(lodash.default.compact([...parsedSchema.content.map(({ value }) => `${value}`), parsedSchema.nullable && this.config.Ts.Keyword.Null])) || this.config.Ts.Keyword.Any
			};
		},
		[SCHEMA_TYPES$1.OBJECT]: (parsedSchema) => {
			if (typeof parsedSchema.content === "string") return {
				...parsedSchema,
				typeIdentifier: this.config.Ts.Keyword.Type,
				content: this.schemaUtils.safeAddNullToType(parsedSchema.content)
			};
			return {
				...parsedSchema,
				typeIdentifier: this.config.Ts.Keyword.Type,
				content: this.schemaUtils.safeAddNullToType(parsedSchema, parsedSchema.content.length ? this.config.Ts.ObjectWrapper(this.formatObjectContent(parsedSchema.content)) : this.config.Ts.RecordType(this.config.Ts.Keyword.String, this.config.Ts.Keyword.Any))
			};
		}
	};
	formatSchema = (parsedSchema, formatType = "base") => {
		const schemaType = lodash.default.get(parsedSchema, ["schemaType"]) || lodash.default.get(parsedSchema, ["$parsed", "schemaType"]);
		return lodash.default.get(this, [formatType, schemaType])?.(parsedSchema) || parsedSchema;
	};
	formatDescription = (description$1, inline) => {
		if (!description$1) return "";
		if (!description$1.includes("\n")) return description$1;
		if (inline) return lodash.default._(description$1).split(/\n/g).map((part) => part.trim()).compact().join(" ").valueOf();
		return description$1.replace(/\n$/g, "");
	};
	formatObjectContent = (content) => {
		const fields = [];
		for (const part of content) {
			const extraSpace = "  ";
			const result = `${extraSpace}${part.field},\n`;
			const routeNameFromTemplate = this.templatesWorker.renderTemplate(this.config.templatesToRender.dataContractJsDoc, { data: part }).split("\n").map((c) => `${extraSpace}${c}`).join("\n");
			if (routeNameFromTemplate) fields.push(`${routeNameFromTemplate}${result}`);
			else fields.push(`${result}`);
		}
		return fields.join("");
	};
};

//#endregion
//#region src/util/sort-by-property.ts
const sortByProperty = (propertyName) => (o1, o2) => {
	if (o1[propertyName] > o2[propertyName]) return 1;
	if (o1[propertyName] < o2[propertyName]) return -1;
	return 0;
};

//#endregion
//#region src/schema-parser/mono-schema-parser.ts
var MonoSchemaParser = class {
	schema;
	typeName;
	schemaPath;
	schemaParser;
	schemaParserFabric;
	typeNameFormatter;
	schemaComponentsMap;
	schemaUtils;
	config;
	schemaFormatters;
	constructor(schemaParser, schema, typeName = null, schemaPath = []) {
		this.schemaParser = schemaParser;
		this.schemaParserFabric = schemaParser.schemaParserFabric;
		this.schema = schema;
		this.typeName = typeName;
		this.typeNameFormatter = schemaParser.typeNameFormatter;
		this.schemaPath = schemaPath;
		this.schemaComponentsMap = this.schemaParser.schemaComponentsMap;
		this.schemaUtils = this.schemaParser.schemaUtils;
		this.config = this.schemaParser.config;
		this.schemaFormatters = this.schemaParser.schemaFormatters;
	}
	parse() {
		throw new Error("not implemented");
	}
	buildTypeNameFromPath = () => {
		return this.schemaUtils.buildTypeNameFromPath(this.schemaPath);
	};
};

//#endregion
//#region src/schema-parser/base-schema-parsers/array.ts
var ArraySchemaParser = class extends MonoSchemaParser {
	parse() {
		let contentType;
		const { type, description: description$1, items } = this.schema || {};
		if (Array.isArray(items) && type === SCHEMA_TYPES$1.ARRAY) {
			const tupleContent = [];
			for (const item of items) tupleContent.push(this.schemaParserFabric.createSchemaParser({
				schema: item,
				schemaPath: this.schemaPath
			}).getInlineParseContent());
			contentType = this.config.Ts.Tuple(tupleContent);
		} else {
			const content = this.schemaParserFabric.createSchemaParser({
				schema: items,
				schemaPath: this.schemaPath
			}).getInlineParseContent();
			contentType = this.config.Ts.ArrayType(content);
		}
		return {
			...typeof this.schema === "object" ? this.schema : {},
			$schemaPath: this.schemaPath.slice(),
			$parsedSchema: true,
			schemaType: SCHEMA_TYPES$1.PRIMITIVE,
			type: SCHEMA_TYPES$1.PRIMITIVE,
			typeIdentifier: this.config.Ts.Keyword.Type,
			name: this.typeName,
			description: this.schemaFormatters.formatDescription(description$1),
			content: this.schemaUtils.safeAddNullToType(this.schema, contentType)
		};
	}
};

//#endregion
//#region src/schema-parser/base-schema-parsers/complex.ts
var ComplexSchemaParser = class extends MonoSchemaParser {
	parse() {
		const complexType = this.schemaUtils.getComplexType(this.schema);
		const simpleSchema = lodash.default.omit(lodash.default.clone(this.schema), lodash.default.keys(this.schemaParser._complexSchemaParsers));
		const complexSchemaContent = this.schemaParser._complexSchemaParsers[complexType](this.schema);
		return {
			...typeof this.schema === "object" ? this.schema : {},
			$schemaPath: this.schemaPath.slice(),
			$parsedSchema: true,
			schemaType: SCHEMA_TYPES$1.COMPLEX,
			type: SCHEMA_TYPES$1.PRIMITIVE,
			typeIdentifier: this.config.Ts.Keyword.Type,
			name: this.typeName,
			description: this.schemaFormatters.formatDescription(this.schema.description || lodash.default.compact(lodash.default.map(this.schema[complexType], "description"))[0] || ""),
			content: this.config.Ts.IntersectionType(lodash.default.compact([this.config.Ts.ExpressionGroup(complexSchemaContent), this.schemaUtils.getInternalSchemaType(simpleSchema) === SCHEMA_TYPES$1.OBJECT && this.config.Ts.ExpressionGroup(this.schemaParserFabric.createSchemaParser({
				schema: simpleSchema,
				schemaPath: this.schemaPath
			}).getInlineParseContent())])) || this.config.Ts.Keyword.Any
		};
	}
};

//#endregion
//#region src/schema-parser/base-schema-parsers/discriminator.ts
var DiscriminatorSchemaParser = class extends MonoSchemaParser {
	parse() {
		const ts = this.config.Ts;
		const { discriminator,...noDiscriminatorSchema } = this.schema;
		if (!discriminator.mapping) return this.schemaParserFabric.createSchemaParser({
			schema: noDiscriminatorSchema,
			typeName: this.typeName,
			schemaPath: this.schemaPath
		}).parseSchema();
		const skipMappingType = false;
		const abstractSchemaStruct = this.createAbstractSchemaStruct();
		const discriminatorSchemaStruct = this.createDiscriminatorSchema({
			skipMappingType,
			abstractSchemaStruct
		});
		const schemaContent = ts.IntersectionType([abstractSchemaStruct?.content, discriminatorSchemaStruct?.content].filter(Boolean));
		return {
			...typeof this.schema === "object" ? this.schema : {},
			$schemaPath: this.schemaPath.slice(),
			$parsedSchema: true,
			schemaType: SCHEMA_TYPES$1.COMPLEX,
			type: SCHEMA_TYPES$1.PRIMITIVE,
			typeIdentifier: ts.Keyword.Type,
			name: this.typeName,
			description: this.schemaFormatters.formatDescription(this.schema.description),
			content: schemaContent
		};
	}
	createDiscriminatorSchema = ({ skipMappingType, abstractSchemaStruct }) => {
		const ts = this.config.Ts;
		const refPath = this.schemaComponentsMap.createRef([
			"components",
			"schemas",
			this.typeName
		]);
		const { discriminator } = this.schema;
		const mappingEntries = lodash.default.entries(discriminator.mapping);
		const ableToCreateMappingType = !skipMappingType && !!(abstractSchemaStruct?.typeName && mappingEntries.length);
		const mappingContents = [];
		let mappingTypeName;
		/** { mapping_key: SchemaEnum.MappingKey, ... } */
		const mappingPropertySchemaEnumKeysMap = this.createMappingPropertySchemaEnumKeys({
			abstractSchemaStruct,
			discPropertyName: discriminator.propertyName
		});
		if (ableToCreateMappingType) {
			const rawTypeName = `${abstractSchemaStruct.typeName}_${discriminator.propertyName}`;
			const generatedTypeName = this.schemaUtils.resolveTypeName(rawTypeName, {
				suffixes: this.config.extractingOptions.discriminatorMappingSuffix,
				resolver: this.config.extractingOptions.discriminatorMappingNameResolver
			});
			const content = ts.IntersectionType([ts.ObjectWrapper(ts.TypeField({
				key: ts.StringValue(discriminator.propertyName),
				value: "Key"
			})), "Type"]);
			const component = this.schemaParserFabric.createParsedComponent({
				typeName: generatedTypeName,
				schema: {
					type: "object",
					properties: {},
					genericArgs: [{ name: "Key" }, { name: "Type" }],
					internal: true
				}
			});
			component.typeData.content = content;
			mappingTypeName = this.typeNameFormatter.format(component.typeName);
		}
		/** returns (GenericType<"mapping_key", MappingType>) or ({ discriminatorProperty: "mapping_key" } & MappingType) */
		const createMappingContent = (mappingSchema, mappingKey) => {
			const content = this.schemaParserFabric.createSchemaParser({
				schema: mappingSchema,
				schemaPath: this.schemaPath
			}).getInlineParseContent();
			const mappingUsageKey = mappingPropertySchemaEnumKeysMap[mappingKey] || ts.StringValue(mappingKey);
			if (ableToCreateMappingType) return ts.TypeWithGeneric(mappingTypeName, [mappingUsageKey, content]);
			return ts.ExpressionGroup(ts.IntersectionType([ts.ObjectWrapper(ts.TypeField({
				key: discriminator.propertyName,
				value: mappingUsageKey
			})), content]));
		};
		for (const [mappingKey, schema] of mappingEntries) {
			const mappingSchema = typeof schema === "string" ? { $ref: schema } : schema;
			this.mutateMappingDependentSchema({
				discPropertyName: discriminator.propertyName,
				abstractSchemaStruct,
				mappingSchema,
				refPath,
				mappingPropertySchemaEnumKeysMap
			});
			mappingContents.push(createMappingContent(mappingSchema, mappingKey));
		}
		if (skipMappingType) return null;
		return { content: ts.ExpressionGroup(ts.UnionType(mappingContents)) };
	};
	createMappingPropertySchemaEnumKeys = ({ abstractSchemaStruct, discPropertyName }) => {
		const ts = this.config.Ts;
		let mappingPropertySchemaEnumKeysMap = {};
		let mappingPropertySchema = lodash.default.get(abstractSchemaStruct?.component?.rawTypeData, ["properties", discPropertyName]);
		if (this.schemaUtils.isRefSchema(mappingPropertySchema)) mappingPropertySchema = this.schemaUtils.getSchemaRefType(mappingPropertySchema);
		const parsedEnum = mappingPropertySchema?.rawTypeData?.$parsed;
		if (parsedEnum?.type === SCHEMA_TYPES$1.ENUM) mappingPropertySchemaEnumKeysMap = lodash.default.reduce(parsedEnum.enum, (acc, key, index) => {
			const enumContent = parsedEnum.content?.[index];
			if (this.config.generateUnionEnums) {
				const literalValue = enumContent?.value ?? (key !== void 0 ? ts.StringValue(key) : void 0);
				if (literalValue !== void 0) acc[key] = literalValue;
			} else if (parsedEnum.typeName && enumContent?.key) acc[key] = ts.EnumUsageKey(parsedEnum.typeName, enumContent.key);
			return acc;
		}, {});
		return mappingPropertySchemaEnumKeysMap;
	};
	mutateMappingDependentSchema = ({ discPropertyName, abstractSchemaStruct, mappingSchema, refPath, mappingPropertySchemaEnumKeysMap }) => {
		const complexSchemaKeys = lodash.default.keys(this.schemaParser._complexSchemaParsers);
		if (mappingSchema.$ref && abstractSchemaStruct?.component?.$ref) {
			const mappingRefSchema = this.schemaUtils.getSchemaRefType(mappingSchema)?.rawTypeData;
			if (mappingRefSchema) {
				for (const schemaKey of complexSchemaKeys) if (Array.isArray(mappingRefSchema[schemaKey])) mappingRefSchema[schemaKey] = mappingRefSchema[schemaKey].map((schema) => {
					if (schema.$ref === refPath) return {
						...schema,
						$ref: abstractSchemaStruct.component.$ref
					};
					if (this.schemaUtils.getInternalSchemaType(schema) === SCHEMA_TYPES$1.OBJECT) for (const schemaPropertyName in schema.properties) {
						const schemaProperty = schema.properties[schemaPropertyName];
						if (schemaPropertyName === discPropertyName && this.schemaUtils.getInternalSchemaType(schemaProperty) === SCHEMA_TYPES$1.ENUM && schemaProperty.enum.length === 1 && mappingPropertySchemaEnumKeysMap[schemaProperty.enum[0]]) schema.properties[schemaPropertyName] = this.schemaParserFabric.createSchema({ content: mappingPropertySchemaEnumKeysMap[schemaProperty.enum[0]] });
					}
					return schema;
				});
			}
		}
	};
	createAbstractSchemaStruct = () => {
		const { discriminator,...noDiscriminatorSchema } = this.schema;
		const complexSchemaKeys = lodash.default.keys(this.schemaParser._complexSchemaParsers);
		const schema = lodash.default.omit(structuredClone(noDiscriminatorSchema), complexSchemaKeys);
		const schemaIsAny = this.schemaParserFabric.getInlineParseContent(structuredClone(schema)) === this.config.Ts.Keyword.Any;
		if (!lodash.default.keys(schema).length || schemaIsAny) return null;
		const typeName = this.schemaUtils.resolveTypeName(this.typeName, {
			prefixes: this.config.extractingOptions.discriminatorAbstractPrefix,
			resolver: this.config.extractingOptions.discriminatorAbstractResolver
		});
		const component = this.schemaComponentsMap.createComponent(this.schemaComponentsMap.createRef([
			"components",
			"schemas",
			typeName
		]), {
			...schema,
			internal: true
		});
		return {
			typeName,
			component,
			content: this.schemaParserFabric.createSchemaParser({
				schema: component,
				schemaPath: this.schemaPath
			}).getInlineParseContent()
		};
	};
	createComplexSchemaStruct = () => {
		const ts = this.config.Ts;
		const complexType = this.schemaUtils.getComplexType(this.schema);
		if (complexType === SCHEMA_TYPES$1.COMPLEX_UNKNOWN) return null;
		return { content: ts.ExpressionGroup(this.schemaParser._complexSchemaParsers[complexType](this.schema)) };
	};
};

//#endregion
//#region src/schema-parser/util/enum-key-resolver.ts
var EnumKeyResolver = class extends NameResolver {
	counter = 1;
	constructor(config, reservedNames) {
		super(config, reservedNames, (variants) => {
			const generatedVariant = variants[0] && `${variants[0]}${this.counter++}` || `${this.config.enumKeyResolverName}${this.counter++}`;
			consola.consola.debug("generated fallback type name for enum key - ", generatedVariant);
			return generatedVariant;
		});
	}
};

//#endregion
//#region src/schema-parser/base-schema-parsers/enum.ts
var EnumSchemaParser = class extends MonoSchemaParser {
	enumKeyResolver;
	constructor(...args) {
		super(...args);
		this.enumKeyResolver = new EnumKeyResolver(this.config, []);
	}
	extractEnum = (pathTypeName) => {
		const generatedTypeName = this.schemaUtils.resolveTypeName(pathTypeName, {
			suffixes: this.config.extractingOptions.enumSuffix,
			resolver: this.config.extractingOptions.enumNameResolver
		});
		const customComponent = this.schemaComponentsMap.createComponent(this.schemaComponentsMap.createRef([
			"components",
			"schemas",
			generatedTypeName
		]), { ...this.schema });
		return this.schemaParserFabric.parseSchema(customComponent);
	};
	parse() {
		const pathTypeName = this.buildTypeNameFromPath();
		if (this.config.extractEnums && !this.typeName && pathTypeName != null) return this.extractEnum(pathTypeName);
		const refType = this.schemaUtils.getSchemaRefType(this.schema);
		const $ref = refType?.$ref || null;
		if (Array.isArray(this.schema.enum)) this.schema.enum = this.schema.enum.filter((key) => key != null);
		if (Array.isArray(this.schema.enum) && Array.isArray(this.schema.enum[0])) return this.schemaParserFabric.parseSchema({ oneOf: this.schema.enum.map((enumNames$1) => ({
			type: "array",
			items: enumNames$1.map((enumName) => ({
				type: "string",
				enum: [enumName]
			}))
		})) }, this.typeName, this.schemaPath);
		const keyType = this.schemaUtils.getSchemaType(this.schema);
		const enumNames = this.schemaUtils.getEnumNames(this.schema);
		const enumDescriptions = this.schemaUtils.getEnumDescriptions(this.schema);
		let content = null;
		const formatValue = (value) => {
			if (value === null) return this.config.Ts.NullValue(value);
			if (keyType.includes(this.schemaUtils.getSchemaType({ type: "number" }))) {
				const maybeNumber = typeof value === "number" ? value : Number(value);
				if (!Number.isNaN(maybeNumber)) return this.config.Ts.NumberValue(maybeNumber);
			}
			if (keyType.includes(this.schemaUtils.getSchemaType({ type: "boolean" }))) {
				if (typeof value === "boolean") return this.config.Ts.BooleanValue(value);
				if (value === "true" || value === "false") return this.config.Ts.BooleanValue(value === "true");
			}
			switch (typeof value) {
				case "number": return this.config.Ts.NumberValue(value);
				case "boolean": return this.config.Ts.BooleanValue(value);
				default: return this.config.Ts.StringValue(value);
			}
		};
		if (Array.isArray(enumNames) && lodash.default.size(enumNames)) content = enumNames.map((enumName, index) => {
			const enumValue = lodash.default.get(this.schema.enum, index);
			const formattedKey = this.formatEnumKey({
				key: enumName,
				value: enumValue
			});
			if (this.config.enumNamesAsValues || enumValue === void 0) return {
				key: formattedKey,
				type: this.config.Ts.Keyword.String,
				value: this.config.Ts.StringValue(enumName),
				description: enumDescriptions?.[index]
			};
			return {
				key: formattedKey,
				type: keyType,
				value: formatValue(enumValue),
				description: enumDescriptions?.[index]
			};
		});
		else content = this.schema.enum.map((value, index) => {
			return {
				key: this.formatEnumKey({ value }),
				type: keyType,
				value: formatValue(value),
				description: enumDescriptions?.[index]
			};
		});
		return {
			...typeof this.schema === "object" ? this.schema : {},
			$ref,
			typeName: this.typeName || $ref && refType.typeName || null,
			$parsedSchema: true,
			schemaType: SCHEMA_TYPES$1.ENUM,
			type: SCHEMA_TYPES$1.ENUM,
			keyType,
			typeIdentifier: this.config.generateUnionEnums ? this.config.Ts.Keyword.Type : this.config.Ts.Keyword.Enum,
			name: this.typeName,
			description: this.schemaFormatters.formatDescription(this.schema.description),
			content
		};
	}
	formatEnumKey = ({ key, value }) => {
		let formatted;
		if (key) formatted = this.typeNameFormatter.format(key, { type: "enum-key" });
		if (!formatted) formatted = this.typeNameFormatter.format(`${value}`, { type: "enum-key" });
		return this.enumKeyResolver.resolve([formatted]);
	};
};

//#endregion
//#region src/schema-parser/base-schema-parsers/object.ts
var ObjectSchemaParser = class extends MonoSchemaParser {
	parse() {
		const contentProperties = this.getObjectSchemaContent(this.schema);
		return {
			...typeof this.schema === "object" ? this.schema : {},
			$schemaPath: this.schemaPath.slice(),
			$parsedSchema: true,
			schemaType: SCHEMA_TYPES$1.OBJECT,
			type: SCHEMA_TYPES$1.OBJECT,
			typeIdentifier: this.config.Ts.Keyword.Interface,
			name: this.typeName,
			description: this.schemaFormatters.formatDescription(this.schema.description),
			allFieldsAreOptional: !contentProperties.some((part) => part.isRequired),
			content: contentProperties
		};
	}
	getObjectSchemaContent = (schema) => {
		const { properties, additionalProperties } = schema || {};
		const propertiesContent = lodash.default.map(properties, (property, name$1) => {
			const required = this.schemaUtils.isPropertyRequired(name$1, property, schema);
			const rawTypeData = lodash.default.get(this.schemaUtils.getSchemaRefType(property), "rawTypeData", {});
			const nullable = !!(rawTypeData.nullable || property.nullable);
			const fieldName = this.typeNameFormatter.isValidName(name$1) ? name$1 : this.config.Ts.StringValue(name$1);
			const fieldValue = this.schemaParserFabric.createSchemaParser({
				schema: property,
				schemaPath: [...this.schemaPath, name$1]
			}).getInlineParseContent();
			const readOnly = property.readOnly;
			return {
				...property,
				$$raw: property,
				title: property.title,
				description: property.description || lodash.default.compact(lodash.default.map(property[this.schemaUtils.getComplexType(property)], "description"))[0] || rawTypeData.description || lodash.default.compact(lodash.default.map(rawTypeData[this.schemaUtils.getComplexType(rawTypeData)], "description"))[0] || "",
				isRequired: required,
				isNullable: nullable,
				name: fieldName,
				value: fieldValue,
				field: this.config.Ts.TypeField({
					readonly: readOnly && this.config.addReadonly,
					optional: !required,
					key: fieldName,
					value: fieldValue
				})
			};
		});
		if (additionalProperties) {
			const propertyNamesSchema = this.schemaUtils.getSchemaPropertyNamesSchema(schema);
			let interfaceKeysContent;
			if (propertyNamesSchema) interfaceKeysContent = this.schemaParserFabric.createSchemaParser({
				schema: propertyNamesSchema,
				schemaPath: this.schemaPath
			}).getInlineParseContent();
			else interfaceKeysContent = this.config.Ts.Keyword.String;
			propertiesContent.push({
				$$raw: { additionalProperties },
				description: "",
				isRequired: false,
				field: this.config.Ts.InterfaceDynamicField(interfaceKeysContent, this.config.Ts.Keyword.Any)
			});
		}
		return propertiesContent;
	};
};

//#endregion
//#region src/schema-parser/base-schema-parsers/primitive.ts
var PrimitiveSchemaParser = class extends MonoSchemaParser {
	parse() {
		let contentType = null;
		const { additionalProperties, type, description: description$1, items } = this.schema || {};
		if (type === this.config.Ts.Keyword.Object && additionalProperties) {
			const propertyNamesSchema = this.schemaUtils.getSchemaPropertyNamesSchema(this.schema);
			let recordKeysContent;
			let recordValuesContent;
			if (propertyNamesSchema) recordKeysContent = this.schemaParserFabric.createSchemaParser({
				schema: propertyNamesSchema,
				schemaPath: this.schemaPath
			}).getInlineParseContent();
			else recordKeysContent = this.config.Ts.Keyword.String;
			if (typeof additionalProperties === "object") recordValuesContent = this.schemaParserFabric.createSchemaParser({
				schema: additionalProperties,
				schemaPath: this.schemaPath
			}).getInlineParseContent();
			else recordValuesContent = this.config.Ts.Keyword.Any;
			contentType = this.config.Ts.RecordType(recordKeysContent, recordValuesContent);
		}
		if (Array.isArray(type) && type.length) contentType = this.schemaParser._complexSchemaParsers.oneOf({
			...typeof this.schema === "object" ? this.schema : {},
			oneOf: type.map((type$1) => ({ type: type$1 }))
		});
		if (Array.isArray(items) && type === SCHEMA_TYPES$1.ARRAY) contentType = this.config.Ts.Tuple(items.map((item) => this.schemaParserFabric.createSchemaParser({
			schema: item,
			schemaPath: this.schemaPath
		}).getInlineParseContent()));
		return {
			...typeof this.schema === "object" ? this.schema : {},
			$schemaPath: this.schemaPath.slice(),
			$parsedSchema: true,
			schemaType: SCHEMA_TYPES$1.PRIMITIVE,
			type: SCHEMA_TYPES$1.PRIMITIVE,
			typeIdentifier: this.config.Ts.Keyword.Type,
			name: this.typeName,
			description: this.schemaFormatters.formatDescription(description$1),
			content: type === this.config.Ts.Keyword.Null ? type : contentType || this.schemaUtils.getSchemaType(this.schema)
		};
	}
};

//#endregion
//#region src/schema-parser/complex-schema-parsers/all-of.ts
var AllOfSchemaParser = class extends MonoSchemaParser {
	parse() {
		const ignoreTypes = [this.config.Ts.Keyword.Any];
		const combined = this.schema.allOf.map((childSchema) => this.schemaParserFabric.getInlineParseContent(this.schemaUtils.makeAddRequiredToChildSchema(this.schema, childSchema), null, this.schemaPath));
		const filtered = this.schemaUtils.filterSchemaContents(combined, (content) => !ignoreTypes.includes(content));
		const type = this.config.Ts.IntersectionType(filtered);
		return this.schemaUtils.safeAddNullToType(this.schema, type);
	}
};

//#endregion
//#region src/schema-parser/complex-schema-parsers/any-of.ts
var AnyOfSchemaParser = class extends MonoSchemaParser {
	parse() {
		const ignoreTypes = [this.config.Ts.Keyword.Any];
		const combined = this.schema.anyOf.map((childSchema) => this.schemaParserFabric.getInlineParseContent(this.schemaUtils.makeAddRequiredToChildSchema(this.schema, childSchema), null, this.schemaPath));
		const filtered = this.schemaUtils.filterSchemaContents(combined, (content) => !ignoreTypes.includes(content));
		const type = this.config.Ts.UnionType(filtered);
		return this.schemaUtils.safeAddNullToType(this.schema, type);
	}
};

//#endregion
//#region src/schema-parser/complex-schema-parsers/not.ts
var NotSchemaParser = class extends MonoSchemaParser {
	parse() {
		return this.config.Ts.Keyword.Any;
	}
};

//#endregion
//#region src/schema-parser/complex-schema-parsers/one-of.ts
var OneOfSchemaParser = class extends MonoSchemaParser {
	parse() {
		const ignoreTypes = [this.config.Ts.Keyword.Any];
		const combined = this.schema.oneOf.map((childSchema) => this.schemaParserFabric.getInlineParseContent(this.schemaUtils.makeAddRequiredToChildSchema(this.schema, childSchema), null, this.schemaPath));
		const filtered = this.schemaUtils.filterSchemaContents(combined, (content) => !ignoreTypes.includes(content));
		const type = this.config.Ts.UnionType(filtered);
		return this.schemaUtils.safeAddNullToType(this.schema, type);
	}
};

//#endregion
//#region src/schema-parser/schema-parser.ts
var SchemaParser = class {
	schemaParserFabric;
	config;
	schemaComponentsMap;
	typeNameFormatter;
	schemaFormatters;
	schemaUtils;
	templatesWorker;
	schemaWalker;
	typeName;
	schema;
	schemaPath = [];
	constructor(schemaParserFabric, { typeName, schema, schemaPath } = {}) {
		this.schemaParserFabric = schemaParserFabric;
		this.config = schemaParserFabric.config;
		this.templatesWorker = schemaParserFabric.templatesWorker;
		this.schemaComponentsMap = schemaParserFabric.schemaComponentsMap;
		this.typeNameFormatter = schemaParserFabric.typeNameFormatter;
		this.schemaWalker = schemaParserFabric.schemaWalker;
		this.schemaFormatters = schemaParserFabric.schemaFormatters;
		this.schemaUtils = schemaParserFabric.schemaUtils;
		this.typeName = typeName || null;
		this.schema = schema;
		this.schemaPath = [...schemaPath || []];
	}
	_complexSchemaParsers = {
		[SCHEMA_TYPES$1.COMPLEX_ONE_OF]: (schema) => {
			return new (this.config.schemaParsers.complexOneOf || OneOfSchemaParser)(this, schema, null, this.schemaPath).parse();
		},
		[SCHEMA_TYPES$1.COMPLEX_ALL_OF]: (schema) => {
			return new (this.config.schemaParsers.complexAllOf || AllOfSchemaParser)(this, schema, null, this.schemaPath).parse();
		},
		[SCHEMA_TYPES$1.COMPLEX_ANY_OF]: (schema) => {
			return new (this.config.schemaParsers.complexAnyOf || AnyOfSchemaParser)(this, schema, null, this.schemaPath).parse();
		},
		[SCHEMA_TYPES$1.COMPLEX_NOT]: (schema) => {
			return new (this.config.schemaParsers.complexNot || NotSchemaParser)(this, schema, null, this.schemaPath).parse();
		}
	};
	_baseSchemaParsers = {
		[SCHEMA_TYPES$1.ENUM]: (schema, typeName) => {
			return new (this.config.schemaParsers.enum || EnumSchemaParser)(this, schema, typeName, this.schemaPath).parse();
		},
		[SCHEMA_TYPES$1.OBJECT]: (schema, typeName) => {
			return new (this.config.schemaParsers.object || ObjectSchemaParser)(this, schema, typeName, this.schemaPath).parse();
		},
		[SCHEMA_TYPES$1.COMPLEX]: (schema, typeName) => {
			return new (this.config.schemaParsers.complex || ComplexSchemaParser)(this, schema, typeName, this.schemaPath).parse();
		},
		[SCHEMA_TYPES$1.PRIMITIVE]: (schema, typeName) => {
			return new (this.config.schemaParsers.primitive || PrimitiveSchemaParser)(this, schema, typeName, this.schemaPath).parse();
		},
		[SCHEMA_TYPES$1.DISCRIMINATOR]: (schema, typeName) => {
			return new (this.config.schemaParsers.discriminator || DiscriminatorSchemaParser)(this, schema, typeName, this.schemaPath).parse();
		},
		[SCHEMA_TYPES$1.ARRAY]: (schema, typeName) => {
			return new (this.config.schemaParsers.array || ArraySchemaParser)(this, schema, typeName, this.schemaPath).parse();
		}
	};
	parseSchema = () => {
		if (!this.schema) return this._baseSchemaParsers[SCHEMA_TYPES$1.PRIMITIVE](null, this.typeName);
		let schemaType = null;
		let parsedSchema = null;
		if (typeof this.schema === "string") return this.schema;
		if (!this.schema.$parsed) {
			if (!this.typeName && this.schemaUtils.isRefSchema(this.schema)) this.typeName = this.schemaUtils.getSchemaType(this.schema);
			if (this.schema.items && !Array.isArray(this.schema.items) && !this.schema.type) this.schema.type = SCHEMA_TYPES$1.ARRAY;
			if (Array.isArray(this.schema.enum) && this.schema.enum.length === 1 && this.schema.enum[0] == null) {
				consola.consola.debug("invalid enum schema", this.schema);
				this.schema = { type: this.config.Ts.Keyword.Null };
			}
			if ("content" in this.schema && typeof this.schema.content === "object") {
				const schema = this.extractSchemaFromResponseStruct(this.schema);
				const schemaParser = this.schemaParserFabric.createSchemaParser({
					schema,
					typeName: this.typeName,
					schemaPath: this.schemaPath
				});
				this.schema.$parsed = schemaParser.parseSchema();
				return this.schema.$parsed;
			}
			schemaType = this.schemaUtils.getInternalSchemaType(this.schema);
			this.schemaPath.push(this.typeName);
			lodash.default.merge(this.schema, this.config.hooks.onPreParseSchema(this.schema, this.typeName, schemaType));
			parsedSchema = this._baseSchemaParsers[schemaType](this.schema, this.typeName);
			this.schema.$parsed = this.config.hooks.onParseSchema(this.schema, parsedSchema) || parsedSchema;
			if (this.config.sortTypes && Array.isArray(this.schema.$parsed?.content)) this.schema.$parsed.content = this.schema.$parsed.content.sort(sortByProperty("name"));
		}
		this.schemaPath.pop();
		return this.schema.$parsed;
	};
	getInlineParseContent = () => {
		const parsedSchema = this.parseSchema();
		return this.schemaFormatters.formatSchema(parsedSchema, "inline").content;
	};
	getParseContent = () => {
		const parsedSchema = this.parseSchema();
		return this.schemaFormatters.formatSchema(parsedSchema, "base").content;
	};
	extractSchemaFromResponseStruct = (responseStruct) => {
		const { content,...extras } = responseStruct;
		const firstResponse = lodash.default.first(lodash.default.values(content));
		const firstSchema = lodash.default.get(firstResponse, "schema");
		if (!firstSchema) return;
		return {
			...extras,
			...lodash.default.omit(firstResponse, "schema"),
			...firstSchema
		};
	};
};

//#endregion
//#region src/util/internal-case.ts
function internalCase(value) {
	return lodash.default.camelCase(lodash.default.lowerCase(value));
}

//#endregion
//#region src/util/pascal-case.ts
function pascalCase(value) {
	return lodash.default.upperFirst(lodash.default.camelCase(value));
}

//#endregion
//#region src/schema-parser/schema-utils.ts
var SchemaUtils = class {
	config;
	schemaComponentsMap;
	typeNameFormatter;
	schemaWalker;
	constructor({ config, schemaComponentsMap, typeNameFormatter, schemaWalker }) {
		this.config = config;
		this.schemaComponentsMap = schemaComponentsMap;
		this.typeNameFormatter = typeNameFormatter;
		this.schemaWalker = schemaWalker;
	}
	getRequiredProperties = (schema) => {
		return lodash.default.uniq(schema && Array.isArray(schema.required) && schema.required || []);
	};
	isRefSchema = (schema) => {
		return !!schema?.$ref;
	};
	getEnumNames = (schema) => {
		return schema["x-enumNames"] || schema.xEnumNames || schema["x-enumnames"] || schema["x-enum-varnames"];
	};
	getEnumDescriptions = (schema) => {
		return schema["x-enumDescriptions"] || schema.xEnumDescriptions || schema["x-enumdescriptions"] || schema["x-enum-descriptions"];
	};
	getSchemaPropertyNamesSchema = (schema) => {
		if (!schema) return null;
		return schema.propertyNames || schema["x-propertyNames"] || null;
	};
	getSchemaRefType = (schema) => {
		if (!this.isRefSchema(schema)) return null;
		return this.schemaComponentsMap.get(schema.$ref);
	};
	isPropertyRequired = (name$1, propertySchema, rootSchema) => {
		if (propertySchema["x-omitempty"] === false) return true;
		const isRequired = typeof propertySchema.required === "boolean" ? !!propertySchema.required : Array.isArray(rootSchema.required) ? rootSchema.required.includes(name$1) : !!rootSchema.required;
		if (this.config.convertedFromSwagger2) return typeof propertySchema.nullable === this.config.Ts.Keyword.Undefined ? isRequired : !propertySchema.nullable;
		return isRequired;
	};
	isNullMissingInType = (schema, type) => {
		const { nullable, type: schemaType } = schema || {};
		return (nullable || !!lodash.default.get(schema, "x-nullable") || schemaType === this.config.Ts.Keyword.Null) && typeof type === "string" && !type.includes(` ${this.config.Ts.Keyword.Null}`) && !type.includes(`${this.config.Ts.Keyword.Null} `);
	};
	safeAddNullToType = (schema, type) => {
		if (this.isNullMissingInType(schema, type)) return this.config.Ts.UnionType([type, this.config.Ts.Keyword.Null]);
		return type;
	};
	getSchemaPrimitiveType = (rawSchema) => {
		const schema = rawSchema || {};
		if (schema.type) return internalCase(schema.type);
		if (schema.enum) {
			const enumFieldType = typeof schema.enum[0];
			if (enumFieldType === this.config.Ts.Keyword.Undefined) return;
			return internalCase(enumFieldType);
		}
		if (lodash.default.keys(schema.properties).length) return SCHEMA_TYPES$1.OBJECT;
		if (schema.items) return SCHEMA_TYPES$1.ARRAY;
		return null;
	};
	checkAndAddRequiredKeys = (schema, resultType) => {
		if ("$$requiredKeys" in schema && schema.$$requiredKeys.length) {
			this.config.update({ internalTemplateOptions: { addUtilRequiredKeysType: true } });
			return this.config.Ts.TypeWithGeneric(this.config.Ts.CodeGenKeyword.UtilRequiredKeys, [resultType, this.config.Ts.UnionType(schema.$$requiredKeys.map(this.config.Ts.StringValue))]);
		}
		return resultType;
	};
	makeAddRequiredToChildSchema = (parentSchema, childSchema) => {
		if (!childSchema) return childSchema;
		const required = lodash.default.uniq([...this.getRequiredProperties(parentSchema), ...this.getRequiredProperties(childSchema)]);
		const refData = this.getSchemaRefType(childSchema);
		if (refData) {
			const existedRequiredKeys = lodash.default.keys(refData.rawTypeData?.properties || {}).filter((key) => required.includes(key));
			if (!existedRequiredKeys.length) return childSchema;
			return {
				...childSchema,
				$$requiredKeys: existedRequiredKeys
			};
		}
		if (childSchema.properties) {
			const existedRequiredKeys = lodash.default.keys(childSchema.properties).filter((key) => required.includes(key));
			if (!existedRequiredKeys.length) return childSchema;
			return {
				required: lodash.default.uniq([...this.getRequiredProperties(childSchema), ...existedRequiredKeys]),
				...childSchema
			};
		}
		return childSchema;
	};
	filterSchemaContents = (contents, filterFn) => {
		return lodash.default.uniq(contents.filter((type) => filterFn(type)));
	};
	resolveTypeName = (typeName, { suffixes, resolver, prefixes, shouldReserve = true }) => {
		if (resolver) return this.config.componentTypeNameResolver.resolve([], (reserved) => {
			return resolver(pascalCase(typeName), reserved);
		});
		return this.config.componentTypeNameResolver.resolve([...(prefixes || []).map((prefix) => pascalCase(`${prefix} ${typeName}`)), ...(suffixes || []).map((suffix) => pascalCase(`${typeName} ${suffix}`))], shouldReserve);
	};
	getComplexType = (schema) => {
		if (schema.oneOf) return SCHEMA_TYPES$1.COMPLEX_ONE_OF;
		if (schema.allOf) return SCHEMA_TYPES$1.COMPLEX_ALL_OF;
		if (schema.anyOf) return SCHEMA_TYPES$1.COMPLEX_ANY_OF;
		if (schema.not) return SCHEMA_TYPES$1.COMPLEX_NOT;
		return SCHEMA_TYPES$1.COMPLEX_UNKNOWN;
	};
	getInternalSchemaType = (schema) => {
		if (!lodash.default.isEmpty(schema.enum) || !lodash.default.isEmpty(this.getEnumNames(schema))) return SCHEMA_TYPES$1.ENUM;
		if (schema.discriminator) return SCHEMA_TYPES$1.DISCRIMINATOR;
		if (schema.allOf || schema.oneOf || schema.anyOf || schema.not) return SCHEMA_TYPES$1.COMPLEX;
		if (!lodash.default.isEmpty(schema.properties)) return SCHEMA_TYPES$1.OBJECT;
		if (schema.type === SCHEMA_TYPES$1.ARRAY) return SCHEMA_TYPES$1.ARRAY;
		return SCHEMA_TYPES$1.PRIMITIVE;
	};
	getSchemaType = (schema) => {
		if (!schema) return this.config.Ts.Keyword.Any;
		const refTypeInfo = this.getSchemaRefType(schema);
		if (refTypeInfo) return this.checkAndAddRequiredKeys(schema, this.safeAddNullToType(schema, this.typeNameFormatter.format(refTypeInfo.typeName)));
		let resultType;
		if (this.isConstantSchema(schema) && !schema.enum) resultType = this.formatJsValue(schema.const);
		else {
			const primitiveType = this.getSchemaPrimitiveType(schema);
			if (primitiveType == null) return this.config.Ts.Keyword.Any;
			const typeAlias = lodash.default.get(this.config.primitiveTypes, [primitiveType, schema.format]) || lodash.default.get(this.config.primitiveTypes, [primitiveType, "$default"]) || this.config.primitiveTypes[primitiveType];
			if (typeof typeAlias === "function") resultType = typeAlias(schema, this);
			else resultType = typeAlias || primitiveType;
		}
		if (!resultType) return this.config.Ts.Keyword.Any;
		return this.checkAndAddRequiredKeys(schema, this.safeAddNullToType(schema, resultType));
	};
	buildTypeNameFromPath = (schemaPath) => {
		schemaPath = lodash.default.uniq(lodash.default.compact(schemaPath));
		if (!schemaPath || !schemaPath[0]) return null;
		return pascalCase(lodash.default.camelCase(lodash.default.uniq([schemaPath[0], schemaPath[schemaPath.length - 1]]).join("_")));
	};
	isConstantSchema(schema) {
		return "const" in schema;
	}
	formatJsValue = (value) => {
		switch (typeof value) {
			case "string": return this.config.Ts.StringValue(value);
			case "boolean": return this.config.Ts.BooleanValue(value);
			case "number": return this.config.Ts.NumberValue(value);
			default:
				if (value === null) return this.config.Ts.NullValue(value);
				return this.config.Ts.Keyword.Any;
		}
	};
};

//#endregion
//#region src/schema-parser/schema-parser-fabric.ts
var SchemaParserFabric = class {
	config;
	schemaComponentsMap;
	typeNameFormatter;
	schemaFormatters;
	templatesWorker;
	schemaUtils;
	schemaWalker;
	constructor(config, templatesWorker, schemaComponentsMap, typeNameFormatter, schemaWalker) {
		this.config = config;
		this.schemaComponentsMap = schemaComponentsMap;
		this.typeNameFormatter = typeNameFormatter;
		this.templatesWorker = templatesWorker;
		this.schemaWalker = schemaWalker;
		this.schemaUtils = new SchemaUtils(this);
		this.schemaFormatters = new SchemaFormatters(this);
	}
	createSchemaParser = ({ schema, typeName, schemaPath }) => {
		return new SchemaParser(this, {
			schema,
			typeName,
			schemaPath
		});
	};
	createSchema = ({ content, linkedSchema = {}, linkedComponent, schemaPath,...otherSchemaProps }) => {
		const parser = this.createSchemaParser({
			schema: linkedComponent || linkedSchema,
			schemaPath
		});
		const parsed = parser.parseSchema();
		parsed.content = content;
		Object.assign(parsed, otherSchemaProps);
		if (linkedComponent) linkedComponent.typeData = parsed;
		return parser.schema;
	};
	createParsedComponent = ({ typeName, schema, schemaPath }) => {
		const schemaCopy = structuredClone(schema);
		const customComponent = this.schemaComponentsMap.createComponent(this.schemaComponentsMap.createRef([
			"components",
			"schemas",
			typeName
		]), schemaCopy);
		const parsed = this.parseSchema(schemaCopy, null, schemaPath);
		parsed.name = typeName;
		customComponent.typeData = parsed;
		return customComponent;
	};
	parseSchema = (schema, typeName = null, schemaPath = []) => {
		return this.createSchemaParser({
			schema,
			typeName,
			schemaPath
		}).parseSchema();
	};
	getInlineParseContent = (schema, typeName, schemaPath) => {
		return this.createSchemaParser({
			schema,
			typeName,
			schemaPath
		}).getInlineParseContent();
	};
	getParseContent = (schema, typeName, schemaPath) => {
		return this.createSchemaParser({
			schema,
			typeName,
			schemaPath
		}).getParseContent();
	};
};

//#endregion
//#region src/util/id.ts
const ALPHABET = "abcdefghijklmnopqrstuvwxyz0123456789";
const generateId = nanoid.customAlphabet(ALPHABET, 12);

//#endregion
//#region src/schema-routes/util/specific-arg-name-resolver.ts
var SpecificArgNameResolver = class extends NameResolver {
	counter = 1;
	constructor(config, reservedNames) {
		super(config, reservedNames, (variants) => {
			const generatedVariant = variants[0] && `${variants[0]}${this.counter++}` || `${this.config.specificArgNameResolverName}${this.counter++}`;
			consola.consola.debug("generated fallback type name for specific arg - ", generatedVariant);
			return generatedVariant;
		});
	}
};

//#endregion
//#region src/schema-routes/schema-routes.ts
const CONTENT_KIND = {
	JSON: "JSON",
	JSON_API: "JSON_API",
	URL_ENCODED: "URL_ENCODED",
	FORM_DATA: "FORM_DATA",
	IMAGE: "IMAGE",
	OTHER: "OTHER",
	TEXT: "TEXT"
};
var SchemaRoutes = class {
	config;
	schemaParserFabric;
	schemaUtils;
	typeNameFormatter;
	schemaComponentsMap;
	templatesWorker;
	FORM_DATA_TYPES = [];
	routes = [];
	hasSecurityRoutes = false;
	hasQueryRoutes = false;
	hasFormDataRoutes = false;
	constructor(config, schemaParserFabric, schemaComponentsMap, templatesWorker, typeNameFormatter) {
		this.config = config;
		this.schemaParserFabric = schemaParserFabric;
		this.schemaUtils = this.schemaParserFabric.schemaUtils;
		this.typeNameFormatter = typeNameFormatter;
		this.schemaComponentsMap = schemaComponentsMap;
		this.templatesWorker = templatesWorker;
		this.FORM_DATA_TYPES = lodash.default.uniq([this.schemaUtils.getSchemaType({
			type: "string",
			format: "file"
		}), this.schemaUtils.getSchemaType({
			type: "string",
			format: "binary"
		})]);
	}
	createRequestsMap = (routeInfoByMethodsMap) => {
		const parameters = lodash.default.get(routeInfoByMethodsMap, "parameters");
		return lodash.default.reduce(routeInfoByMethodsMap, (acc, requestInfo, method) => {
			if (method.startsWith("x-") || ["parameters", "$ref"].includes(method)) return acc;
			acc[method] = {
				...requestInfo,
				parameters: lodash.default.compact(lodash.default.concat(parameters, requestInfo.parameters))
			};
			return acc;
		}, {});
	};
	parseRouteName = (originalRouteName) => {
		const routeName = this.config.hooks.onPreBuildRoutePath(originalRouteName) || originalRouteName;
		const pathParamMatches = (routeName || "").match(/({[\w[\\\]^`][-_.\w]*})|(:[\w[\\\]^`][-_.\w]*:?)/g);
		const pathParams = lodash.default.reduce(pathParamMatches, (pathParams$1, match) => {
			const paramName = match.replace(/\{|\}|:/g, "");
			if (!paramName) return pathParams$1;
			if (paramName.includes("-")) consola.consola.warn("wrong path param name", paramName);
			pathParams$1.push({
				$match: match,
				name: lodash.default.camelCase(paramName),
				required: true,
				type: "string",
				description: "",
				schema: { type: "string" },
				in: "path"
			});
			return pathParams$1;
		}, []);
		let fixedRoute = pathParams.reduce((fixedRoute$1, pathParam, i, arr) => {
			const insertion = this.config.hooks.onInsertPathParam(pathParam.name, i, arr, fixedRoute$1) || pathParam.name;
			return fixedRoute$1.replace(pathParam.$match, `\${${insertion}}`);
		}, routeName || "");
		const queryParamMatches = fixedRoute.match(/(\{\?.*\})/g);
		const queryParams = [];
		if (queryParamMatches?.length) {
			for (const match of queryParamMatches) fixedRoute = fixedRoute.replace(match, "");
			const paramNames = lodash.default.uniq(queryParamMatches.join(",").replace(/(\{\?)|(\})|\s/g, "").split(","));
			for (const paramName of paramNames) {
				if (paramName.includes("-")) consola.consola.warn("wrong query param name", paramName);
				queryParams.push({
					$match: paramName,
					name: lodash.default.camelCase(paramName),
					required: true,
					type: "string",
					description: "",
					schema: { type: "string" },
					in: "query"
				});
			}
		}
		const result = {
			originalRoute: originalRouteName || "",
			route: fixedRoute,
			pathParams,
			queryParams
		};
		return this.config.hooks.onBuildRoutePath(result) || result;
	};
	getRouteParams = (routeInfo, pathParamsFromRouteName, queryParamsFromRouteName) => {
		const { parameters } = routeInfo;
		const routeParams = {
			path: [],
			header: [],
			body: [],
			query: [],
			formData: [],
			cookie: []
		};
		lodash.default.each(parameters, (parameter) => {
			const refTypeInfo = this.schemaParserFabric.schemaUtils.getSchemaRefType(parameter);
			let routeParam = null;
			if (refTypeInfo?.rawTypeData.in && refTypeInfo.rawTypeData) {
				if (!routeParams[refTypeInfo.rawTypeData.in]) routeParams[refTypeInfo.rawTypeData.in] = [];
				routeParam = {
					...refTypeInfo.rawTypeData,
					...refTypeInfo.rawTypeData.schema || {}
				};
				if (parameter?.required && !routeParam.required) routeParam.required = parameter.required;
			} else {
				if (!parameter.in) return;
				if (!routeParams[parameter.in]) routeParams[parameter.in] = [];
				routeParam = {
					...parameter,
					...parameter.schema || {}
				};
			}
			if (routeParam.in === "path") {
				if (!routeParam.name) return;
				routeParam.name = lodash.default.camelCase(routeParam.name);
			}
			if (routeParam) routeParams[routeParam.in].push(routeParam);
		});
		for (const pathParam of pathParamsFromRouteName) if (!routeParams.path.some((parameter) => parameter.name === pathParam.name)) routeParams.path.push(pathParam);
		for (const queryParam of queryParamsFromRouteName) if (!routeParams.query.some((parameter) => parameter.name === queryParam.name)) routeParams.query.push(queryParam);
		return routeParams;
	};
	getContentTypes = (requestInfo, extraContentTypes) => lodash.default.uniq(lodash.default.compact([...extraContentTypes || [], ...lodash.default.flatten(lodash.default.map(requestInfo, (requestInfoData) => requestInfoData && lodash.default.keys(requestInfoData.content)))]));
	getContentKind = (contentTypes) => {
		if (contentTypes.includes("application/vnd.api+json")) return CONTENT_KIND.JSON_API;
		if (contentTypes.some((contentType) => contentType.startsWith("application/json")) || contentTypes.some((contentType) => contentType.endsWith("+json"))) return CONTENT_KIND.JSON;
		if (contentTypes.includes("application/x-www-form-urlencoded")) return CONTENT_KIND.URL_ENCODED;
		if (contentTypes.includes("multipart/form-data")) return CONTENT_KIND.FORM_DATA;
		if (contentTypes.some((contentType) => contentType.includes("image/"))) return CONTENT_KIND.IMAGE;
		if (contentTypes.some((contentType) => contentType.startsWith("text/"))) return CONTENT_KIND.TEXT;
		return CONTENT_KIND.OTHER;
	};
	isSuccessStatus = (status) => this.config.defaultResponseAsSuccess && status === "default" || +status >= this.config.successResponseStatusRange[0] && +status <= this.config.successResponseStatusRange[1] || status === "2xx";
	getSchemaFromRequestType = (requestInfo) => {
		const content = lodash.default.get(requestInfo, "content");
		if (!content) return null;
		for (const dataType in content) if (content[dataType]?.schema) return {
			...content[dataType].schema,
			dataType
		};
		return null;
	};
	getTypeFromRequestInfo = ({ requestInfo, parsedSchemas, operationId, defaultType, typeName }) => {
		const schema = this.getSchemaFromRequestType(requestInfo);
		const refTypeInfo = this.schemaParserFabric.schemaUtils.getSchemaRefType(requestInfo);
		if (schema) {
			const content = this.schemaParserFabric.getInlineParseContent(schema, typeName, [operationId]);
			const foundedSchemaByName = parsedSchemas.find((parsedSchema) => this.typeNameFormatter.format(parsedSchema.name) === content);
			const foundSchemaByContent = parsedSchemas.find((parsedSchema) => lodash.default.isEqual(parsedSchema.content, content));
			const foundSchema = foundedSchemaByName || foundSchemaByContent;
			return foundSchema ? this.typeNameFormatter.format(foundSchema.name) : content;
		}
		if (refTypeInfo) {
			const typeNameWithoutOpId = refTypeInfo.typeName.replace(operationId, "");
			if (parsedSchemas.find((schema$1) => schema$1.name === typeNameWithoutOpId)) return this.typeNameFormatter.format(typeNameWithoutOpId);
			switch (refTypeInfo.componentName) {
				case "schemas": return this.typeNameFormatter.format(refTypeInfo.typeName);
				case "responses":
				case "requestBodies": return this.schemaParserFabric.getInlineParseContent(this.getSchemaFromRequestType(refTypeInfo.rawTypeData), refTypeInfo.typeName || null, [operationId]);
				default: return this.schemaParserFabric.getInlineParseContent(refTypeInfo.rawTypeData, refTypeInfo.typeName || null, [operationId]);
			}
		}
		return defaultType || this.config.Ts.Keyword.Any;
	};
	getRequestInfoTypes = ({ requestInfos, parsedSchemas, operationId, defaultType }) => lodash.default.reduce(requestInfos, (acc, requestInfo, status) => {
		const contentTypes = this.getContentTypes([requestInfo]);
		return [...acc, {
			...requestInfo || {},
			contentTypes,
			contentKind: this.getContentKind(contentTypes),
			type: this.schemaParserFabric.schemaUtils.safeAddNullToType(requestInfo, this.getTypeFromRequestInfo({
				requestInfo,
				parsedSchemas,
				operationId,
				defaultType
			})),
			description: this.schemaParserFabric.schemaFormatters.formatDescription(requestInfo.description || "", true),
			status: Number.isNaN(+status) ? status : +status,
			isSuccess: this.isSuccessStatus(status)
		}];
	}, []);
	getResponseBodyInfo = (routeInfo, parsedSchemas) => {
		const { produces, operationId, responses } = routeInfo;
		const contentTypes = this.getContentTypes(responses, [...produces || [], routeInfo["x-accepts"]]);
		const responseInfos = this.getRequestInfoTypes({
			requestInfos: responses,
			parsedSchemas,
			operationId,
			defaultType: this.config.defaultResponseType
		});
		const successResponse = responseInfos.find((response) => response.isSuccess);
		const errorResponses = responseInfos.filter((response) => !response.isSuccess && response.type !== this.config.Ts.Keyword.Any);
		const handleResponseHeaders = (src) => {
			if (!src) return "headers: {},";
			const headerTypes = Object.fromEntries(Object.entries(src).map(([k, v]) => {
				return [k, this.schemaUtils.getSchemaType(v)];
			}));
			return `headers: { ${Object.entries(headerTypes).map(([k, v]) => `"${k}": ${v}`).join(",")} },`;
		};
		return {
			contentTypes,
			responses: responseInfos,
			success: {
				schema: successResponse,
				type: successResponse?.type || this.config.Ts.Keyword.Any
			},
			error: {
				schemas: errorResponses,
				type: this.config.Ts.UnionType(errorResponses.map((response) => response.type)) || this.config.Ts.Keyword.Any
			},
			full: { types: this.config.Ts.UnionType(responseInfos.map((response) => `{
      data: ${response.type}, status: ${response.status}, statusCode: ${response.status}, statusText: "${response.description}", ${handleResponseHeaders(response.headers)} config: {} }`)) || this.config.Ts.Keyword.Any }
		};
	};
	convertRouteParamsIntoObject = (params) => {
		return params.reduce((objectSchema, schemaPart) => {
			if (!schemaPart || !schemaPart.name) return objectSchema;
			return {
				...objectSchema,
				properties: {
					...objectSchema.properties,
					[schemaPart.name]: {
						...schemaPart,
						...schemaPart.schema || {}
					}
				}
			};
		}, {
			properties: {},
			type: "object"
		});
	};
	getRequestBodyInfo = (routeInfo, routeParams, parsedSchemas, routeName) => {
		const { requestBody, consumes, requestBodyName, operationId } = routeInfo;
		let schema = null;
		let content = null;
		const contentTypes = this.getContentTypes([requestBody], [...consumes || [], routeInfo["x-contentType"]]);
		let contentKind = this.getContentKind(contentTypes);
		let typeName = null;
		if (this.config.extractRequestBody) typeName = this.schemaUtils.resolveTypeName(routeName.usage, {
			suffixes: this.config.extractingOptions.requestBodySuffix,
			resolver: this.config.extractingOptions.requestBodyNameResolver
		});
		if (routeParams.formData.length) {
			contentKind = CONTENT_KIND.FORM_DATA;
			schema = this.convertRouteParamsIntoObject(routeParams.formData);
			content = this.schemaParserFabric.getInlineParseContent(schema, typeName, [operationId]);
		} else if (contentKind === CONTENT_KIND.FORM_DATA) {
			schema = this.getSchemaFromRequestType(requestBody);
			content = this.schemaParserFabric.getInlineParseContent(schema, typeName, [operationId]);
		} else if (requestBody) {
			schema = this.getSchemaFromRequestType(requestBody);
			content = this.schemaParserFabric.schemaUtils.safeAddNullToType(requestBody, this.getTypeFromRequestInfo({
				requestInfo: requestBody,
				parsedSchemas,
				operationId,
				typeName
			}));
			if (this.FORM_DATA_TYPES.some((dataType) => content.includes(`: ${dataType}`))) contentKind = CONTENT_KIND.FORM_DATA;
		}
		if (schema && !schema.$ref && this.config.extractRequestBody) {
			schema = this.schemaParserFabric.createParsedComponent({
				schema,
				typeName,
				schemaPath: [operationId]
			});
			if (schema?.typeData) schema.typeData.isExtractedRequestBody = true;
			content = this.schemaParserFabric.getInlineParseContent({ $ref: schema.$ref });
		}
		if (schema && schema.typeData && !schema.typeData.description && requestBody?.description) schema.typeData.description = requestBody.description;
		return {
			...requestBody || {},
			paramName: requestBodyName || requestBody?.name || DEFAULT_BODY_ARG_NAME,
			contentTypes,
			contentKind,
			schema,
			type: content,
			required: requestBody && (typeof requestBody.required === "undefined" || !!requestBody.required)
		};
	};
	createRequestParamsSchema = ({ queryParams, queryObjectSchema, pathArgsSchemas, extractRequestParams, routeName }) => {
		if ((!queryParams || !queryParams.length) && (!pathArgsSchemas || !pathArgsSchemas.length)) return null;
		const pathParams = pathArgsSchemas.reduce((acc, pathArgSchema) => {
			if (pathArgSchema.name) acc[pathArgSchema.name] = {
				...pathArgSchema,
				in: "path"
			};
			return acc;
		}, {});
		const fixedQueryParams = lodash.default.reduce(lodash.default.get(queryObjectSchema, "properties", {}), (acc, property, name$1) => {
			if (name$1 && typeof property === "object") acc[name$1] = {
				...property,
				in: "query"
			};
			return acc;
		}, {});
		const schema = {
			...queryObjectSchema,
			properties: {
				...fixedQueryParams,
				...pathParams
			}
		};
		const fixedSchema = this.config.hooks.onCreateRequestParams(schema);
		if (fixedSchema) return fixedSchema;
		if (extractRequestParams) {
			const generatedTypeName = this.schemaUtils.resolveTypeName(routeName.usage, {
				suffixes: this.config.extractingOptions.requestParamsSuffix,
				resolver: this.config.extractingOptions.requestParamsNameResolver
			});
			const component = this.schemaParserFabric.createParsedComponent({
				typeName: generatedTypeName,
				schema
			});
			if (component.typeData) component.typeData.isExtractedRequestParams = true;
			return component;
		}
		return schema;
	};
	extractResponseBodyIfItNeeded = (routeInfo, responseBodyInfo, routeName) => {
		if (responseBodyInfo.responses.length && responseBodyInfo.success && responseBodyInfo.success.schema) {
			const typeName = this.schemaUtils.resolveTypeName(routeName.usage, {
				suffixes: this.config.extractingOptions.responseBodySuffix,
				resolver: this.config.extractingOptions.responseBodyNameResolver
			});
			const idx = responseBodyInfo.responses.indexOf(responseBodyInfo.success.schema);
			const successResponse = responseBodyInfo.success;
			if (successResponse.schema && !successResponse.schema.$ref) {
				const contentKind = successResponse.schema.contentKind;
				const schema = this.getSchemaFromRequestType(successResponse.schema);
				successResponse.schema = this.schemaParserFabric.createParsedComponent({
					schema,
					typeName,
					schemaPath: [routeInfo.operationId]
				});
				successResponse.schema.contentKind = contentKind;
				if (successResponse.schema.typeData) successResponse.schema.typeData.isExtractedResponseBody = true;
				successResponse.type = this.schemaParserFabric.getInlineParseContent({ $ref: successResponse.schema.$ref });
				if (idx > -1) lodash.default.assign(responseBodyInfo.responses[idx], {
					...successResponse.schema,
					type: successResponse.type
				});
			}
		}
	};
	extractResponseErrorIfItNeeded = (routeInfo, responseBodyInfo, routeName) => {
		if (responseBodyInfo.responses.length && responseBodyInfo.error.schemas && responseBodyInfo.error.schemas.length) {
			const typeName = this.schemaUtils.resolveTypeName(routeName.usage, {
				suffixes: this.config.extractingOptions.responseErrorSuffix,
				resolver: this.config.extractingOptions.responseErrorNameResolver
			});
			const errorSchemas = responseBodyInfo.error.schemas.map(this.getSchemaFromRequestType).filter(Boolean);
			if (!errorSchemas.length) return;
			const schema = this.schemaParserFabric.parseSchema({
				oneOf: errorSchemas,
				title: errorSchemas.map((schema$1) => schema$1.title).filter(Boolean).join(" "),
				description: errorSchemas.map((schema$1) => schema$1.description).filter(Boolean).join("\n")
			}, null, [routeInfo.operationId]);
			const component = this.schemaComponentsMap.createComponent(this.schemaComponentsMap.createRef([
				"components",
				"schemas",
				typeName
			]), { ...schema });
			responseBodyInfo.error.schemas = [component];
			if (component.typeData) component.typeData.isExtractedResponseError = true;
			responseBodyInfo.error.type = this.typeNameFormatter.format(component.typeName);
		}
	};
	getRouteName = (rawRouteInfo) => {
		const { moduleName } = rawRouteInfo;
		const { routeNameDuplicatesMap, templatesToRender } = this.config;
		const routeNameTemplate = templatesToRender.routeName;
		const routeNameFromTemplate = this.templatesWorker.renderTemplate(routeNameTemplate, { routeInfo: rawRouteInfo });
		const routeName = this.config.hooks.onFormatRouteName(rawRouteInfo, routeNameFromTemplate) || routeNameFromTemplate;
		const duplicateIdentifier = `${moduleName}|${routeName}`;
		if (routeNameDuplicatesMap.has(duplicateIdentifier)) {
			routeNameDuplicatesMap.set(duplicateIdentifier, routeNameDuplicatesMap.get(duplicateIdentifier) + 1);
			consola.consola.warn(`Module "${moduleName}" already has method "${routeName}()".`, `This method has been renamed to "${routeName + routeNameDuplicatesMap.get(duplicateIdentifier)}()" to solve conflict names.`);
		} else routeNameDuplicatesMap.set(duplicateIdentifier, 1);
		const duplicates = routeNameDuplicatesMap.get(duplicateIdentifier);
		const routeNameInfo = {
			usage: routeName + (duplicates > 1 ? duplicates : ""),
			original: routeName,
			duplicate: duplicates > 1
		};
		return this.config.hooks.onCreateRouteName(routeNameInfo, rawRouteInfo) || routeNameInfo;
	};
	parseRouteInfo = (rawRouteName, routeInfo, method, usageSchema, parsedSchemas) => {
		const { security: globalSecurity } = usageSchema;
		const { moduleNameIndex, moduleNameFirstTag, extractRequestParams } = this.config;
		const { operationId, requestBody, security, parameters, summary, description: description$1, tags, responses, requestBodyName, produces, consumes,...otherInfo } = routeInfo;
		const { route, pathParams: pathParamsFromRouteName, queryParams: queryParamsFromRouteName } = this.parseRouteName(rawRouteName);
		const routeId = generateId();
		const firstTag = tags && tags.length > 0 ? tags[0] : null;
		const moduleName = moduleNameFirstTag && firstTag ? lodash.default.camelCase(firstTag) : lodash.default.camelCase(lodash.default.compact(route.split("/"))[moduleNameIndex]);
		let hasSecurity = !!globalSecurity?.length;
		if (security) hasSecurity = security.length > 0;
		const routeParams = this.getRouteParams(routeInfo, pathParamsFromRouteName, queryParamsFromRouteName);
		const pathArgs = routeParams.path.map((pathArgSchema) => ({
			name: pathArgSchema.name,
			optional: !pathArgSchema.required,
			type: this.config.Ts.Keyword.Any,
			description: pathArgSchema.description
		}));
		const pathArgsNames = pathArgs.map((arg) => arg.name);
		const responseBodyInfo = this.getResponseBodyInfo(routeInfo, parsedSchemas);
		const rawRouteInfo = {
			...otherInfo,
			pathArgs,
			operationId,
			method,
			route: rawRouteName,
			moduleName,
			responsesTypes: responseBodyInfo.responses,
			description: description$1,
			tags,
			summary,
			responses,
			produces,
			requestBody,
			consumes,
			security
		};
		const queryObjectSchema = this.convertRouteParamsIntoObject(routeParams.query);
		const pathObjectSchema = this.convertRouteParamsIntoObject(routeParams.path);
		const headersObjectSchema = this.convertRouteParamsIntoObject(routeParams.header);
		const routeName = this.getRouteName(rawRouteInfo);
		const requestBodyInfo = this.getRequestBodyInfo(routeInfo, routeParams, parsedSchemas, routeName);
		const requestParamsSchema = this.createRequestParamsSchema({
			queryParams: routeParams.query,
			pathArgsSchemas: routeParams.path,
			queryObjectSchema,
			extractRequestParams,
			routeName
		});
		if (this.config.extractResponseBody) this.extractResponseBodyIfItNeeded(routeInfo, responseBodyInfo, routeName);
		if (this.config.extractResponseError) this.extractResponseErrorIfItNeeded(routeInfo, responseBodyInfo, routeName);
		const typeName = this.schemaUtils.resolveTypeName(routeName.usage, {
			suffixes: this.config.extractingOptions.requestParamsSuffix,
			resolver: this.config.extractingOptions.requestParamsNameResolver,
			shouldReserve: false
		});
		const queryType = routeParams.query.length ? this.schemaParserFabric.getInlineParseContent(queryObjectSchema, null, [typeName]) : null;
		const pathType = routeParams.path.length ? this.schemaParserFabric.getInlineParseContent(pathObjectSchema, null, [typeName]) : null;
		const headersType = routeParams.header.length ? this.schemaParserFabric.getInlineParseContent(headersObjectSchema, null, [typeName]) : null;
		const nameResolver = new SpecificArgNameResolver(this.config, pathArgsNames);
		const specificArgs = {
			query: queryType ? {
				name: nameResolver.resolve(RESERVED_QUERY_ARG_NAMES),
				optional: this.schemaParserFabric.parseSchema(queryObjectSchema, null, [routeName.usage]).allFieldsAreOptional,
				type: queryType
			} : void 0,
			body: requestBodyInfo.type ? {
				...requestBodyInfo,
				name: nameResolver.resolve([requestBodyInfo.paramName, ...RESERVED_BODY_ARG_NAMES]),
				optional: !requestBodyInfo.required,
				type: requestBodyInfo.type
			} : void 0,
			pathParams: pathType ? {
				name: nameResolver.resolve(RESERVED_PATH_ARG_NAMES),
				optional: this.schemaParserFabric.parseSchema(pathObjectSchema, null, [routeName.usage]).allFieldsAreOptional,
				type: pathType
			} : void 0,
			headers: headersType ? {
				name: nameResolver.resolve(RESERVED_HEADER_ARG_NAMES),
				optional: this.schemaParserFabric.parseSchema(headersObjectSchema, null, [routeName.usage]).allFieldsAreOptional,
				type: headersType
			} : void 0
		};
		pathArgs.forEach((pathArg, i) => {
			pathArg.type = this.schemaParserFabric.getInlineParseContent(routeParams.path[i].schema, null, [typeName]);
		});
		return {
			id: routeId,
			namespace: moduleName.replace(/^(\d)/, "v$1"),
			routeName,
			routeParams,
			requestBodyInfo,
			responseBodyInfo,
			specificArgs,
			queryObjectSchema,
			pathObjectSchema,
			headersObjectSchema,
			responseBodySchema: responseBodyInfo.success.schema,
			requestBodySchema: requestBodyInfo.schema,
			specificArgNameResolver: nameResolver,
			request: {
				contentTypes: requestBodyInfo.contentTypes,
				parameters: pathArgs,
				path: route,
				formData: requestBodyInfo.contentKind === CONTENT_KIND.FORM_DATA,
				isQueryBody: requestBodyInfo.contentKind === CONTENT_KIND.URL_ENCODED,
				security: hasSecurity,
				method,
				requestParams: requestParamsSchema,
				payload: specificArgs.body,
				query: specificArgs.query,
				pathParams: specificArgs.pathParams,
				headers: specificArgs.headers
			},
			response: {
				contentTypes: responseBodyInfo.contentTypes,
				type: responseBodyInfo.success.type,
				errorType: responseBodyInfo.error.type,
				fullTypes: responseBodyInfo.full.types
			},
			raw: rawRouteInfo
		};
	};
	attachSchema = ({ usageSchema, parsedSchemas }) => {
		this.config.routeNameDuplicatesMap.clear();
		const pathsEntries = lodash.default.entries(usageSchema.paths);
		for (const [rawRouteName, routeInfoByMethodsMap] of pathsEntries) {
			const routeInfosMap = this.createRequestsMap(routeInfoByMethodsMap);
			for (const [method, routeInfo] of Object.entries(routeInfosMap)) {
				const parsedRouteInfo = this.parseRouteInfo(rawRouteName, routeInfo, method, usageSchema, parsedSchemas);
				const processedRouteInfo = this.config.hooks.onCreateRoute(parsedRouteInfo);
				if (processedRouteInfo !== false) {
					const route = processedRouteInfo || parsedRouteInfo;
					if (!this.hasSecurityRoutes && route.security) this.hasSecurityRoutes = route.security;
					if (!this.hasQueryRoutes && route.hasQuery) this.hasQueryRoutes = route.hasQuery;
					if (!this.hasFormDataRoutes && route.hasFormDataParams) this.hasFormDataRoutes = route.hasFormDataParams;
					this.routes.push(route);
				}
			}
		}
	};
	getGroupedRoutes = () => {
		const groupedRoutes = this.routes.reduce((modules, route) => {
			if (route.namespace) {
				if (!modules[route.namespace]) modules[route.namespace] = [];
				modules[route.namespace].push(route);
			} else modules.$outOfModule.push(route);
			return modules;
		}, { $outOfModule: [] });
		const routeGroups = lodash.default.reduce(groupedRoutes, (acc, routesGroup, moduleName) => {
			if (moduleName === "$outOfModule") acc.outOfModule = routesGroup;
			else {
				if (!acc.combined) acc.combined = [];
				acc.combined.push({
					moduleName,
					routes: routesGroup.map((route) => {
						const { original: originalName, usage: usageName } = route.routeName;
						if (routesGroup.length > 1 && usageName !== originalName && !routesGroup.some(({ routeName, id }) => id !== route.id && originalName === routeName.original)) return {
							...route,
							routeName: {
								...route.routeName,
								usage: originalName
							}
						};
						return route;
					})
				});
			}
			return acc;
		}, {});
		if (this.config.sortRoutes) {
			if (routeGroups.outOfModule) routeGroups.outOfModule = this.sortRoutes(routeGroups.outOfModule);
			if (routeGroups.combined) lodash.default.each(routeGroups.combined, (routeGroup) => {
				routeGroup.routes = this.sortRoutes(routeGroup.routes);
			});
		}
		return routeGroups;
	};
	sortRoutes = (routes) => {
		return lodash.default.slice(routes).sort((routeA, routeB) => routeA.routeName.usage.localeCompare(routeB.routeName.usage));
	};
};

//#endregion
//#region src/schema-walker.ts
var SchemaWalker = class {
	config;
	swaggerSchemaResolver;
	schemas = /* @__PURE__ */ new Map();
	caches = /* @__PURE__ */ new Map();
	constructor(config, swaggerSchemaResolver) {
		this.config = config;
		this.swaggerSchemaResolver = swaggerSchemaResolver;
	}
	addSchema = (name$1, schema) => {
		this.schemas.set(name$1, structuredClone(schema));
	};
	_isLocalRef = (ref) => {
		return ref.startsWith("#");
	};
	_isRemoteRef = (ref) => {
		return ref.startsWith("http://") || ref.startsWith("https://");
	};
	_getRefDataFromSchema = (schema, ref) => {
		const path$1 = ref.replace("#", "").split("/");
		const refData = lodash.default.get(schema, path$1);
		if (refData) this.caches.set(ref, refData);
		return refData;
	};
};

//#endregion
//#region src/util/request.ts
var Request = class {
	config;
	constructor(config) {
		this.config = config;
	}
	async download({ url: url$1, authToken,...options }) {
		const requestOptions = {};
		if (authToken) requestOptions.headers = { Authorization: authToken };
		lodash.default.merge(requestOptions, options, this.config.requestOptions);
		try {
			return await (await fetch(url$1, requestOptions)).text();
		} catch (error) {
			const message = `error while fetching data from URL "${url$1}"`;
			consola.consola.error(message, error);
			return message;
		}
	}
};

//#endregion
//#region src/swagger-schema-resolver.ts
var SwaggerSchemaResolver = class {
	config;
	fileSystem;
	request;
	constructor(config, fileSystem) {
		this.config = config;
		this.fileSystem = fileSystem;
		this.request = new Request(config);
	}
	async create() {
		const { spec, patch, input, url: url$1, authorizationToken } = this.config;
		if (spec) return await this.convertSwaggerObject(spec, { patch });
		const swaggerSchemaFile = await this.fetchSwaggerSchemaFile(input, url$1, authorizationToken);
		const swaggerSchemaObject = this.processSwaggerSchemaFile(swaggerSchemaFile);
		return await this.convertSwaggerObject(swaggerSchemaObject, { patch });
	}
	convertSwaggerObject(swaggerSchema, converterOptions) {
		return new Promise((resolve) => {
			const result = structuredClone(swaggerSchema);
			result.info = lodash.default.merge({
				title: "No title",
				version: ""
			}, result.info);
			if (!Object.hasOwn(result, "openapi")) {
				result.paths = lodash.default.merge({}, result.paths);
				swagger2openapi.convertObj(result, {
					...converterOptions,
					resolveInternal: true,
					warnOnly: true,
					refSiblings: "preserve",
					rbname: "requestBodyName"
				}, (err, options) => {
					const parsedSwaggerSchema = lodash.default.get(err, "options.openapi", lodash.default.get(options, "openapi"));
					if (!parsedSwaggerSchema && err) throw err;
					this.config.update({ convertedFromSwagger2: true });
					resolve({
						usageSchema: parsedSwaggerSchema,
						originalSchema: result
					});
				});
			} else resolve({
				usageSchema: result,
				originalSchema: structuredClone(result)
			});
		});
	}
	getSwaggerSchemaByPath = (pathToSwagger) => {
		consola.consola.info(`try to get swagger by path "${pathToSwagger}"`);
		return this.fileSystem.getFileContent(pathToSwagger);
	};
	async fetchSwaggerSchemaFile(pathToSwagger, urlToSwagger, authToken) {
		if (this.fileSystem.pathIsExist(pathToSwagger)) return this.getSwaggerSchemaByPath(pathToSwagger);
		consola.consola.info(`try to get swagger by URL "${urlToSwagger}"`);
		return await this.request.download({
			url: urlToSwagger,
			authToken
		});
	}
	processSwaggerSchemaFile(file) {
		if (typeof file !== "string") return file;
		try {
			return JSON.parse(file);
		} catch {
			return yaml.parse(file);
		}
	}
	fixSwaggerSchema({ usageSchema, originalSchema }) {
		const usagePaths = lodash.default.get(usageSchema, "paths");
		const originalPaths = lodash.default.get(originalSchema, "paths");
		lodash.default.each(usagePaths, (usagePathObject, route) => {
			const originalPathObject = lodash.default.get(originalPaths, route);
			lodash.default.each(usagePathObject, (usageRouteInfo, methodName) => {
				const originalRouteInfo = lodash.default.get(originalPathObject, methodName);
				const usageRouteParams = lodash.default.get(usageRouteInfo, "parameters", []);
				const originalRouteParams = lodash.default.get(originalRouteInfo, "parameters", []);
				if (typeof usageRouteInfo === "object") {
					usageRouteInfo.consumes = lodash.default.uniq(lodash.default.compact([...usageRouteInfo.consumes || [], ...originalRouteInfo.consumes || []]));
					usageRouteInfo.produces = lodash.default.uniq(lodash.default.compact([...usageRouteInfo.produces || [], ...originalRouteInfo.produces || []]));
				}
				lodash.default.each(originalRouteParams, (originalRouteParam) => {
					if (!usageRouteParams.find((param) => originalRouteParam.in === param.in && originalRouteParam.name === param.name)) usageRouteParams.push(originalRouteParam);
				});
			});
		});
	}
};

//#endregion
//#region src/templates-worker.ts
const require$1 = node_module.createRequire(require("url").pathToFileURL(__filename).href);
const eta$1 = new eta.Eta({ functionHeader: "const includeFile = options.includeFile;" });
var TemplatesWorker = class {
	config;
	fileSystem;
	getRenderTemplateData;
	constructor(config, fileSystem, getRenderTemplateData) {
		this.config = config;
		this.fileSystem = fileSystem;
		this.getRenderTemplateData = getRenderTemplateData;
		if (this.config.debug) consola.consola.level = Number.MAX_SAFE_INTEGER;
		if (this.config.silent) consola.consola.level = 0;
	}
	getTemplatePaths = (config) => {
		const __dirname$2 = node_path.dirname(node_url.fileURLToPath(require("url").pathToFileURL(__filename).href));
		const baseTemplatesPath = node_path.resolve(__dirname$2, "../templates/base");
		const defaultTemplatesPath = node_path.resolve(__dirname$2, "../templates/default");
		const modularTemplatesPath = node_path.resolve(__dirname$2, "../templates/modular");
		return {
			base: baseTemplatesPath,
			default: defaultTemplatesPath,
			modular: modularTemplatesPath,
			original: config.modular ? modularTemplatesPath : defaultTemplatesPath,
			custom: config.templates && node_path.resolve(process.cwd(), config.templates)
		};
	};
	cropExtension = (path$1) => this.config.templateExtensions.reduce((path$2, ext) => path$2.endsWith(ext) ? path$2.replace(ext, "") : path$2, path$1);
	getTemplateFullPath = (path_, fileName) => {
		const raw = node_path.resolve(path_, "./", this.cropExtension(fileName));
		return this.config.templateExtensions.map((extension) => `${raw}${extension}`).find((variant) => !!this.fileSystem.pathIsExist(variant));
	};
	requireFnFromTemplate = (packageOrPath) => {
		if (packageOrPath.startsWith("./") || packageOrPath.startsWith("../")) return require$1(node_path.resolve(this.config.templatePaths.custom || this.config.templatePaths.original, packageOrPath));
		return require$1(packageOrPath);
	};
	getTemplate = (name$1, fileName, path$1) => {
		const { templatePaths } = this.config;
		if (path$1) return this.fileSystem.getFileContent(path$1);
		if (!fileName) return "";
		const customFullPath = templatePaths.custom && this.getTemplateFullPath(templatePaths.custom, fileName);
		let fileContent = customFullPath && this.fileSystem.getFileContent(customFullPath);
		if (fileContent) {
			consola.consola.info(`"${name$1.toLowerCase()}" template found in "${templatePaths.custom}"`);
			return fileContent;
		}
		const baseFullPath = this.getTemplateFullPath(templatePaths.base, fileName);
		if (baseFullPath) fileContent = this.fileSystem.getFileContent(baseFullPath);
		else if (templatePaths.custom) consola.consola.warn("Code generator will use the default template:", `"${name$1.toLowerCase()}"`, "template not found in", `"${templatePaths.custom}"`);
		else consola.consola.info(`Code generator will use the default template for "${name$1.toLowerCase()}"`);
		const originalFullPath = this.getTemplateFullPath(templatePaths.original, fileName);
		if (originalFullPath) fileContent = this.fileSystem.getFileContent(originalFullPath);
		return fileContent;
	};
	getTemplates = ({ templatePaths }) => {
		if (templatePaths.custom) consola.consola.info(`try to read templates from directory "${templatePaths.custom}"`);
		return lodash.default.reduce(this.config.templateInfos, (acc, { name: name$1, fileName }) => ({
			...acc,
			[name$1]: this.getTemplate(name$1, fileName)
		}), {});
	};
	findTemplateWithExt = (path$1) => {
		const raw = this.cropExtension(path$1);
		return this.config.templateExtensions.map((extension) => `${raw}${extension}`).find((variant) => this.fileSystem.pathIsExist(variant));
	};
	getTemplateContent = (path_) => {
		const foundTemplatePathKey = lodash.default.keys(this.config.templatePaths).find((key) => path_.startsWith(`@${key}`));
		if (foundTemplatePathKey) {
			const rawPath = node_path.resolve(path_.replace(`@${foundTemplatePathKey}`, lodash.default.get(this.config.templatePaths, foundTemplatePathKey)));
			const fixedPath = this.findTemplateWithExt(rawPath);
			if (fixedPath) return this.fileSystem.getFileContent(fixedPath);
		}
		const customPath = this.config.templatePaths.custom && this.findTemplateWithExt(node_path.resolve(this.config.templatePaths.custom, path_));
		if (customPath) return this.fileSystem.getFileContent(customPath);
		const originalPath = this.findTemplateWithExt(node_path.resolve(this.config.templatePaths.original, path_));
		if (originalPath) return this.fileSystem.getFileContent(originalPath);
		return "";
	};
	renderTemplate = (template, configuration) => {
		if (!template) return "";
		return eta$1.render(eta$1.compile(template, { async: false }), {
			...this.getRenderTemplateData(),
			...configuration
		}, { includeFile: (path$1, configuration$1) => this.renderTemplate(this.getTemplateContent(path$1), configuration$1) });
	};
};

//#endregion
//#region src/translators/translator.ts
var Translator = class {
	config;
	codeFormatter;
	constructor(config, codeFormatter) {
		this.config = config;
		this.codeFormatter = codeFormatter;
	}
	translate(_input) {
		throw new Error("not implemented");
	}
};

//#endregion
//#region src/translators/javascript.ts
var JavascriptTranslator = class extends Translator {
	compileTSCode = (input) => {
		const fileNameFull = `${input.fileName}${input.fileExtension}`;
		const output = {};
		const host = typescript.createCompilerHost(this.config.compilerTsConfig, true);
		const fileNames = [fileNameFull];
		const originalSourceFileGet = host.getSourceFile.bind(host);
		host.getSourceFile = (sourceFileName, languageVersion, onError, shouldCreateNewSourceFile) => {
			if (sourceFileName !== fileNameFull) return originalSourceFileGet(sourceFileName, languageVersion, onError, shouldCreateNewSourceFile);
			return typescript.createSourceFile(sourceFileName, input.fileContent, languageVersion, true, typescript.ScriptKind.TS);
		};
		host.writeFile = (fileName, contents) => {
			output[fileName] = contents;
		};
		typescript.createProgram(fileNames, this.config.compilerTsConfig, host).emit();
		return output;
	};
	translate = async (input) => {
		const compiled = this.compileTSCode(input);
		const jsFileName = `${input.fileName}${typescript.Extension.Js}`;
		const dtsFileName = `${input.fileName}${typescript.Extension.Dts}`;
		const sourceContent = compiled[jsFileName];
		const tsImportRows = input.fileContent.split("\n").filter((line) => line.startsWith("import "));
		const declarationContent = compiled[dtsFileName].split("\n").map((line) => {
			if (line.startsWith("import ")) return tsImportRows.shift();
			return line;
		}).join("\n");
		return [{
			fileName: input.fileName,
			fileExtension: typescript.Extension.Js,
			fileContent: await this.codeFormatter.formatCode(sourceContent)
		}, {
			fileName: input.fileName,
			fileExtension: typescript.Extension.Dts,
			fileContent: await this.codeFormatter.formatCode(declarationContent)
		}];
	};
};

//#endregion
//#region src/type-name-formatter.ts
var TypeNameFormatter = class {
	formattedModelNamesMap = /* @__PURE__ */ new Map();
	config;
	constructor(config) {
		this.config = config;
	}
	format = (name$1, options = {}) => {
		const schemaType = options.type ?? "type-name";
		const typePrefix = schemaType === "enum-key" ? this.config.enumKeyPrefix : this.config.typePrefix;
		const typeSuffix = schemaType === "enum-key" ? this.config.enumKeySuffix : this.config.typeSuffix;
		const hashKey = `${typePrefix}_${name$1}_${typeSuffix}`;
		if (typeof name$1 !== "string") {
			consola.consola.warn("wrong model name", name$1);
			return name$1;
		}
		if (/^(?!\d)([A-Z0-9_]{1,})$/g.test(name$1)) return lodash.default.compact([
			typePrefix,
			name$1,
			typeSuffix
		]).join("_");
		if (this.formattedModelNamesMap.has(hashKey)) return this.formattedModelNamesMap.get(hashKey);
		const fixedModelName = this.fixModelName(name$1, { type: schemaType });
		const formattedName = lodash.default.startCase(`${typePrefix}_${fixedModelName}_${typeSuffix}`).replace(/\s/g, "");
		const formattedResultName = this.config.hooks.onFormatTypeName(formattedName, name$1, schemaType) || formattedName;
		this.formattedModelNamesMap.set(hashKey, formattedResultName);
		return formattedResultName;
	};
	isValidName = (name$1) => /^([A-Za-z$_]{1,})$/g.test(name$1);
	fixModelName = (name$1, options) => {
		if (!this.isValidName(name$1)) {
			if (!/^[a-zA-Z_$]/g.test(name$1)) return `${options.type === "enum-key" ? this.config.fixInvalidEnumKeyPrefix : this.config.fixInvalidTypeNamePrefix} ${name$1}`;
			if (name$1.includes(".")) return name$1.replace(/Exclude_keyof[A-Za-z]+/g, () => "ExcludeKeys").replace(/%22~AND~%22/g, "And").replace(/%22~OR~%22/g, "Or").replace(/(\.?%22)|\./g, "_").replace(/__+$/, "");
			if (name$1.includes("-")) return lodash.default.startCase(name$1).replace(/ /g, "");
		}
		return name$1;
	};
};

//#endregion
//#region src/util/file-system.ts
var FileSystem = class {
	getFileContent = (path$1) => {
		return node_fs.readFileSync(path$1, { encoding: "utf8" });
	};
	readDir = (path$1) => {
		return node_fs.readdirSync(path$1);
	};
	pathIsDir = (path$1) => {
		if (!path$1) return false;
		try {
			return node_fs.statSync(path$1).isDirectory();
		} catch (e) {
			return false;
		}
	};
	cropExtension = (fileName) => {
		const fileNameParts = fileName.split(".");
		if (fileNameParts.length > 1) fileNameParts.pop();
		return fileNameParts.join(".");
	};
	removeDir = (path$1) => {
		try {
			if (typeof node_fs.rmSync === "function") node_fs.rmSync(path$1, { recursive: true });
			else node_fs.rmdirSync(path$1, { recursive: true });
		} catch (e) {
			consola.consola.debug("failed to remove dir", e);
		}
	};
	createDir = (path$1) => {
		try {
			node_fs.mkdirSync(path$1, { recursive: true });
		} catch (e) {
			consola.consola.debug("failed to create dir", e);
		}
	};
	cleanDir = (path$1) => {
		this.removeDir(path$1);
		this.createDir(path$1);
	};
	pathIsExist = (path$1) => {
		return !!path$1 && node_fs.existsSync(path$1);
	};
	createFile = ({ path: path_, fileName, content, withPrefix }) => {
		const __dirname$2 = node_path.dirname(node_url.fileURLToPath(require("url").pathToFileURL(__filename).href));
		const absolutePath = node_path.resolve(__dirname$2, path_, `./${fileName}`);
		const fileContent = `${withPrefix ? FILE_PREFIX : ""}${content}`;
		return node_fs.writeFileSync(absolutePath, fileContent);
	};
};

//#endregion
//#region src/code-gen-process.ts
const PATCHABLE_INSTANCES = [
	"schemaWalker",
	"swaggerSchemaResolver",
	"schemaComponentsMap",
	"typeNameFormatter",
	"templatesWorker",
	"codeFormatter",
	"schemaParserFabric",
	"schemaRoutes",
	"javascriptTranslator"
];
var CodeGenProcess = class {
	config;
	swaggerSchemaResolver;
	schemaComponentsMap;
	typeNameFormatter;
	schemaParserFabric;
	schemaRoutes;
	fileSystem;
	codeFormatter;
	templatesWorker;
	schemaWalker;
	javascriptTranslator;
	constructor(config) {
		this.config = new CodeGenConfig(config);
		this.fileSystem = new FileSystem();
		this.swaggerSchemaResolver = new SwaggerSchemaResolver(this.config, this.fileSystem);
		this.schemaWalker = new SchemaWalker(this.config, this.swaggerSchemaResolver);
		this.schemaComponentsMap = new SchemaComponentsMap(this.config);
		this.typeNameFormatter = new TypeNameFormatter(this.config);
		this.templatesWorker = new TemplatesWorker(this.config, this.fileSystem, this.getRenderTemplateData);
		this.codeFormatter = new CodeFormatter(this.config);
		this.schemaParserFabric = new SchemaParserFabric(this.config, this.templatesWorker, this.schemaComponentsMap, this.typeNameFormatter, this.schemaWalker);
		this.schemaRoutes = new SchemaRoutes(this.config, this.schemaParserFabric, this.schemaComponentsMap, this.templatesWorker, this.typeNameFormatter);
		this.javascriptTranslator = new JavascriptTranslator(this.config, this.codeFormatter);
	}
	async start() {
		this.config.update({ templatePaths: this.templatesWorker.getTemplatePaths(this.config) });
		this.config.update({ templatesToRender: this.templatesWorker.getTemplates(this.config) });
		const swagger = await this.swaggerSchemaResolver.create();
		this.swaggerSchemaResolver.fixSwaggerSchema(swagger);
		this.config.update({
			swaggerSchema: swagger.usageSchema,
			originalSchema: swagger.originalSchema
		});
		this.schemaWalker.addSchema("$usage", swagger.usageSchema);
		this.schemaWalker.addSchema("$original", swagger.originalSchema);
		consola.consola.info("start generating your typescript api");
		this.config.update(this.config.hooks.onInit(this.config, this) || this.config);
		if (this.config.swaggerSchema) swagger.usageSchema = this.config.swaggerSchema;
		if (this.config.originalSchema) swagger.originalSchema = this.config.originalSchema;
		this.schemaComponentsMap.clear();
		lodash.default.each(swagger.usageSchema.components, (component, componentName) => lodash.default.each(component, (rawTypeData, typeName) => {
			this.schemaComponentsMap.createComponent(this.schemaComponentsMap.createRef([
				"components",
				componentName,
				typeName
			]), rawTypeData);
		}));
		this.schemaComponentsMap.discriminatorsFirst();
		this.schemaComponentsMap.enumsFirst();
		const parsedSchemas = this.schemaComponentsMap.filter(lodash.default.compact(["schemas", this.config.extractResponses && "responses"])).map((schemaComponent) => {
			const parsed = this.schemaParserFabric.parseSchema(schemaComponent.rawTypeData, schemaComponent.typeName);
			schemaComponent.typeData = parsed;
			return parsed;
		});
		this.schemaRoutes.attachSchema({
			usageSchema: swagger.usageSchema,
			parsedSchemas
		});
		const rawConfiguration = {
			apiConfig: this.createApiConfig(swagger.usageSchema),
			config: this.config,
			modelTypes: this.collectModelTypes(),
			hasSecurityRoutes: this.schemaRoutes.hasSecurityRoutes,
			hasQueryRoutes: this.schemaRoutes.hasQueryRoutes,
			hasFormDataRoutes: this.schemaRoutes.hasFormDataRoutes,
			generateResponses: this.config.generateResponses,
			routes: this.schemaRoutes.getGroupedRoutes(),
			extraTemplates: this.config.extraTemplates,
			fileName: this.config.fileName,
			translateToJavaScript: this.config.toJS,
			customTranslator: this.config.customTranslator ? new this.config.customTranslator() : null,
			utils: this.getRenderTemplateData().utils
		};
		const configuration = this.config.hooks.onPrepareConfig(rawConfiguration) || rawConfiguration;
		if (this.fileSystem.pathIsExist(this.config.output)) {
			if (this.config.cleanOutput) {
				consola.consola.debug("cleaning dir", this.config.output);
				this.fileSystem.cleanDir(this.config.output);
			}
		} else {
			consola.consola.debug(`path ${this.config.output} is not exist. creating dir by this path`);
			this.fileSystem.createDir(this.config.output);
		}
		const files = await this.generateOutputFiles({ configuration });
		if (this.fileSystem.pathIsDir(this.config.output)) for (const file of files) {
			this.fileSystem.createFile({
				path: this.config.output,
				fileName: `${file.fileName}${file.fileExtension}`,
				content: file.fileContent,
				withPrefix: true
			});
			consola.consola.success("api file", `"${file.fileName}${file.fileExtension}"`, `created in ${this.config.output}`);
		}
		return {
			files,
			configuration,
			getTemplate: this.templatesWorker.getTemplate,
			renderTemplate: this.templatesWorker.renderTemplate,
			createFile: this.fileSystem.createFile,
			formatTSContent: this.codeFormatter.formatCode
		};
	}
	getRenderTemplateData = () => {
		return {
			utils: {
				Ts: this.config.Ts,
				formatDescription: this.schemaParserFabric.schemaFormatters.formatDescription,
				internalCase,
				classNameCase: pascalCase,
				pascalCase,
				getInlineParseContent: this.schemaParserFabric.getInlineParseContent,
				getParseContent: this.schemaParserFabric.getParseContent,
				getComponentByRef: this.schemaComponentsMap.get,
				parseSchema: this.schemaParserFabric.parseSchema,
				checkAndAddNull: this.schemaParserFabric.schemaUtils.safeAddNullToType,
				safeAddNullToType: this.schemaParserFabric.schemaUtils.safeAddNullToType,
				isNeedToAddNull: this.schemaParserFabric.schemaUtils.isNullMissingInType,
				inlineExtraFormatters: this.schemaParserFabric.schemaFormatters.inline,
				formatters: this.schemaParserFabric.schemaFormatters.base,
				formatModelName: this.typeNameFormatter.format,
				fmtToJSDocLine: (line, { eol = true }) => {
					return ` * ${line}${eol ? "\n" : ""}`;
				},
				NameResolver,
				_: lodash.default,
				require: this.templatesWorker.requireFnFromTemplate
			},
			config: this.config
		};
	};
	collectModelTypes = () => {
		const components = this.schemaComponentsMap.getComponents();
		let modelTypes = [];
		const modelTypeComponents = lodash.default.compact(["schemas", this.config.extractResponses && "responses"]);
		const getSchemaComponentsCount = () => this.schemaComponentsMap.filter(...modelTypeComponents).length;
		let schemaComponentsCount = getSchemaComponentsCount();
		let processedCount = 0;
		while (processedCount < schemaComponentsCount) {
			modelTypes = [];
			processedCount = 0;
			for (const component of components) if (modelTypeComponents.includes(component.componentName)) {
				const modelType = this.prepareModelType(component);
				if (modelType) modelTypes.push(modelType);
				processedCount++;
			}
			schemaComponentsCount = getSchemaComponentsCount();
		}
		if (this.config.sortTypes) return modelTypes.sort(sortByProperty("name"));
		return modelTypes;
	};
	prepareModelType = (typeInfo) => {
		if (typeInfo.$prepared) return typeInfo.$prepared;
		if (!typeInfo.typeData) typeInfo.typeData = this.schemaParserFabric.parseSchema(typeInfo.rawTypeData, typeInfo.typeName);
		const rawTypeData = typeInfo.typeData;
		const typeData = this.schemaParserFabric.schemaFormatters.base[rawTypeData.type] ? this.schemaParserFabric.schemaFormatters.base[rawTypeData.type](rawTypeData) : rawTypeData;
		const { typeIdentifier, name: originalName, content, description: description$1 } = typeData;
		const name$1 = this.typeNameFormatter.format(originalName);
		if (name$1 === null) return null;
		const preparedModelType = {
			...typeData,
			typeIdentifier,
			name: name$1,
			description: description$1,
			$content: rawTypeData.content,
			rawContent: rawTypeData.content,
			content,
			typeData
		};
		typeInfo.$prepared = preparedModelType;
		return preparedModelType;
	};
	generateOutputFiles = async ({ configuration }) => {
		const { modular, templatesToRender } = this.config;
		const output = modular ? await this.createMultipleFileInfos(templatesToRender, configuration) : await this.createSingleFileInfo(templatesToRender, configuration);
		if (!lodash.default.isEmpty(configuration.extraTemplates)) for (const extraTemplate of configuration.extraTemplates) {
			const content = this.templatesWorker.renderTemplate(this.fileSystem.getFileContent(extraTemplate.path), configuration);
			output.push(...await this.createOutputFileInfo(configuration, extraTemplate.name, content));
		}
		return output.filter((fileInfo) => !!fileInfo && !!fileInfo.fileContent);
	};
	createMultipleFileInfos = async (templatesToRender, configuration) => {
		const { routes } = configuration;
		const { fileNames, generateRouteTypes, generateClient } = configuration.config;
		const modularApiFileInfos = [];
		if (routes.$outOfModule) {
			if (generateRouteTypes) {
				const outOfModuleRouteContent = this.templatesWorker.renderTemplate(templatesToRender.routeTypes, {
					...configuration,
					route: configuration.routes.$outOfModule
				});
				modularApiFileInfos.push(...await this.createOutputFileInfo(configuration, fileNames.outOfModuleApi, outOfModuleRouteContent));
			}
			if (generateClient) {
				const outOfModuleApiContent = this.templatesWorker.renderTemplate(templatesToRender.api, {
					...configuration,
					route: configuration.routes.$outOfModule
				});
				modularApiFileInfos.push(...await this.createOutputFileInfo(configuration, fileNames.outOfModuleApi, outOfModuleApiContent));
			}
		}
		if (routes.combined) for (const route of routes.combined) {
			if (generateRouteTypes) {
				const routeModuleContent = this.templatesWorker.renderTemplate(templatesToRender.routeTypes, {
					...configuration,
					route
				});
				modularApiFileInfos.push(...await this.createOutputFileInfo(configuration, pascalCase(`${route.moduleName}_Route`), routeModuleContent));
			}
			if (generateClient) {
				const apiModuleContent = this.templatesWorker.renderTemplate(templatesToRender.api, {
					...configuration,
					route
				});
				modularApiFileInfos.push(...await this.createOutputFileInfo(configuration, pascalCase(route.moduleName), apiModuleContent));
			}
		}
		return [
			...await this.createOutputFileInfo(configuration, fileNames.dataContracts, this.templatesWorker.renderTemplate(templatesToRender.dataContracts, configuration)),
			...generateClient ? await this.createOutputFileInfo(configuration, fileNames.httpClient, this.templatesWorker.renderTemplate(templatesToRender.httpClient, configuration)) : [],
			...modularApiFileInfos
		];
	};
	createSingleFileInfo = async (templatesToRender, configuration) => {
		const { generateRouteTypes, generateClient } = configuration.config;
		return await this.createOutputFileInfo(configuration, configuration.fileName, lodash.default.compact([
			this.templatesWorker.renderTemplate(templatesToRender.dataContracts, configuration),
			generateRouteTypes && this.templatesWorker.renderTemplate(templatesToRender.routeTypes, configuration),
			generateClient && this.templatesWorker.renderTemplate(templatesToRender.httpClient, configuration),
			generateClient && this.templatesWorker.renderTemplate(templatesToRender.api, configuration)
		]).join("\n"));
	};
	createOutputFileInfo = async (configuration, fileNameFull, content) => {
		const fileName = this.fileSystem.cropExtension(fileNameFull);
		const fileExtension = typescript.Extension.Ts;
		if (configuration.translateToJavaScript) {
			consola.consola.debug("using js translator for", fileName);
			return await this.javascriptTranslator.translate({
				fileName,
				fileExtension,
				fileContent: content
			});
		}
		if (configuration.customTranslator) {
			consola.consola.debug("using custom translator for", fileName);
			return await configuration.customTranslator.translate({
				fileName,
				fileExtension,
				fileContent: content
			});
		}
		consola.consola.debug("generating output for", `${fileName}${fileExtension}`);
		return [{
			fileName,
			fileExtension,
			fileContent: await this.codeFormatter.formatCode(content)
		}];
	};
	createApiConfig = (swaggerSchema) => {
		const { info, servers, host, basePath, externalDocs, tags } = swaggerSchema;
		const server = servers?.[0] || { url: "" };
		const { title = "No title", version: version$1 } = info || {};
		const { url: serverUrl } = server;
		return {
			info: info || {},
			servers: servers || [],
			basePath,
			host,
			externalDocs: lodash.default.merge({
				url: "",
				description: ""
			}, externalDocs),
			tags: lodash.default.compact(tags),
			baseUrl: serverUrl,
			title,
			version: version$1
		};
	};
	injectClassInstance = (key, value) => {
		this[key] = value;
		for (const instanceKey of PATCHABLE_INSTANCES) if (instanceKey !== key && key in this[instanceKey]) this[instanceKey][key] = value;
	};
};

//#endregion
//#region types/index.ts
let RequestContentKind = /* @__PURE__ */ function(RequestContentKind$1) {
	RequestContentKind$1["JSON"] = "JSON";
	RequestContentKind$1["URL_ENCODED"] = "URL_ENCODED";
	RequestContentKind$1["FORM_DATA"] = "FORM_DATA";
	RequestContentKind$1["IMAGE"] = "IMAGE";
	RequestContentKind$1["OTHER"] = "OTHER";
	RequestContentKind$1["TEXT"] = "TEXT";
	return RequestContentKind$1;
}({});
let SCHEMA_TYPES = /* @__PURE__ */ function(SCHEMA_TYPES$2) {
	SCHEMA_TYPES$2["ARRAY"] = "array";
	SCHEMA_TYPES$2["OBJECT"] = "object";
	SCHEMA_TYPES$2["ENUM"] = "enum";
	SCHEMA_TYPES$2["REF"] = "$ref";
	SCHEMA_TYPES$2["PRIMITIVE"] = "primitive";
	SCHEMA_TYPES$2["COMPLEX"] = "complex";
	SCHEMA_TYPES$2["COMPLEX_ONE_OF"] = "oneOf";
	SCHEMA_TYPES$2["COMPLEX_ANY_OF"] = "anyOf";
	SCHEMA_TYPES$2["COMPLEX_ALL_OF"] = "allOf";
	SCHEMA_TYPES$2["COMPLEX_NOT"] = "not";
	SCHEMA_TYPES$2["COMPLEX_UNKNOWN"] = "__unknown";
	return SCHEMA_TYPES$2;
}({});

//#endregion
//#region src/commands/generate-templates/configuration.ts
var TemplatesGenConfig = class {
	cleanOutput = false;
	debug = false;
	httpClientType = HTTP_CLIENT.FETCH;
	modular = false;
	output = void 0;
	rewrite = false;
	silent = false;
	version = PROJECT_VERSION;
	constructor(config) {
		this.update(config);
	}
	update = (update) => {
		objectAssign(this, update);
	};
};

//#endregion
//#region src/commands/generate-templates/templates-gen-process.ts
const __dirname$1 = node_path.default.dirname(node_url.default.fileURLToPath(require("url").pathToFileURL(__filename).href));
var TemplatesGenProcess = class {
	config;
	fileSystem;
	rootDir = node_path.default.resolve(__dirname$1, "..");
	paths = {
		baseTemplates: "templates/base",
		httpClientTemplates: "templates/base/http-clients",
		moduleApiTemplates: "templates/modular",
		defaultApiTemplates: "templates/default"
	};
	importTemplatePrefixes = [
		"@base",
		"@modular",
		"@default"
	];
	constructor(config) {
		this.config = new TemplatesGenConfig(config);
		this.fileSystem = new FileSystem();
	}
	async start() {
		consola.consola.info("start generating source templates \".ejs\" for code generator");
		const templates = this.getTemplates();
		if (this.config.output) {
			consola.consola.info("preparing output directory for source templates");
			const outputPath = node_path.default.resolve(process.cwd(), this.config.output);
			if (this.fileSystem.pathIsExist(outputPath)) {
				if (this.config.cleanOutput) this.fileSystem.cleanDir(outputPath);
			} else this.fileSystem.createDir(outputPath);
			for (const template of templates) {
				const templateName = this.fileSystem.cropExtension(template.name);
				const templateEjsPath = node_path.default.resolve(outputPath, `${templateName}.ejs`);
				const templateEtaPath = node_path.default.resolve(outputPath, `${templateName}.eta`);
				const templateEjsPathExist = this.fileSystem.pathIsExist(templateEjsPath);
				const templateEtaPathExist = this.fileSystem.pathIsExist(templateEtaPath);
				if (!templateEjsPathExist && !templateEtaPathExist) this.fileSystem.createFile({
					path: outputPath,
					fileName: template.name,
					content: template.content,
					withPrefix: false
				});
				else if (this.config.rewrite) {
					if (templateEjsPathExist) this.fileSystem.createFile({
						path: outputPath,
						fileName: `${templateName}.ejs`,
						content: template.content,
						withPrefix: false
					});
					else if (templateEtaPathExist) this.fileSystem.createFile({
						path: outputPath,
						fileName: `${templateName}.eta`,
						content: template.content,
						withPrefix: false
					});
				}
			}
			consola.consola.success(`source templates has been successfully created in "${outputPath}"`);
		}
		return {
			files: templates,
			configuration: this.config,
			createFile: this.fileSystem.createFile
		};
	}
	getTemplates = () => {
		const outputFiles = [];
		const baseTemplates = this.getTemplateNamesFromDir(this.paths.baseTemplates);
		const httpClientTemplates = this.getTemplateNamesFromDir(this.paths.httpClientTemplates);
		const apiTemplatesPath = this.config.modular ? this.paths.moduleApiTemplates : this.paths.defaultApiTemplates;
		const apiTemplates = this.getTemplateNamesFromDir(apiTemplatesPath);
		const usingHttpClientTemplate = httpClientTemplates.find((template) => template.startsWith(`${this.config.httpClientType}-`));
		let httpClientTemplateContent = "";
		if (usingHttpClientTemplate) httpClientTemplateContent = this.fixTemplateContent(this.getTemplateContent(`${this.paths.httpClientTemplates}/${usingHttpClientTemplate}`));
		for (const fileName of baseTemplates) {
			const templateContent = fileName === "http-client.ejs" && httpClientTemplateContent || this.fixTemplateContent(this.getTemplateContent(`${this.paths.baseTemplates}/${fileName}`));
			outputFiles.push({
				name: fileName,
				content: templateContent
			});
		}
		for (const fileName of apiTemplates) outputFiles.push({
			name: fileName,
			content: this.fixTemplateContent(this.getTemplateContent(`${apiTemplatesPath}/${fileName}`))
		});
		return outputFiles;
	};
	fixTemplateContent = (content) => {
		const importsRegExp1 = new RegExp(`includeFile\\("(${this.importTemplatePrefixes.map((v) => `(${v})`).join("|")})/`, "g");
		const importsRegExp2 = new RegExp(`includeFile\\(\`(${this.importTemplatePrefixes.map((v) => `(${v})`).join("|")})/`, "g");
		const importsRegExp3 = new RegExp(`includeFile\\('(${this.importTemplatePrefixes.map((v) => `(${v})`).join("|")})/`, "g");
		return content.replace(importsRegExp1, "includeFile(\"./").replace(importsRegExp2, "includeFile(`./").replace(importsRegExp3, "includeFile('./");
	};
	getTemplateNamesFromDir = (dir) => {
		return this.fileSystem.readDir(node_path.default.resolve(this.rootDir, dir)).filter((file) => file.endsWith(".ejs"));
	};
	getTemplateContent = (pathToFile) => {
		return this.fileSystem.getFileContent(node_path.default.resolve(this.rootDir, pathToFile));
	};
};

//#endregion
//#region src/commands/generate-templates/index.ts
async function generateTemplates(config) {
	if (config.debug) consola.consola.level = Number.MAX_SAFE_INTEGER;
	if (config.silent) consola.consola.level = 0;
	return await new TemplatesGenProcess(config).start();
}

//#endregion
//#region src/index.ts
async function generateApi(config) {
	if (config.debug) consola.consola.level = Number.MAX_SAFE_INTEGER;
	if (config.silent) consola.consola.level = 0;
	return await new CodeGenProcess(config).start();
}

//#endregion
Object.defineProperty(exports, 'CodeGenConfig', {
  enumerable: true,
  get: function () {
    return CodeGenConfig;
  }
});
Object.defineProperty(exports, 'HTTP_CLIENT', {
  enumerable: true,
  get: function () {
    return HTTP_CLIENT;
  }
});
Object.defineProperty(exports, 'RequestContentKind', {
  enumerable: true,
  get: function () {
    return RequestContentKind;
  }
});
Object.defineProperty(exports, 'SCHEMA_TYPES', {
  enumerable: true,
  get: function () {
    return SCHEMA_TYPES;
  }
});
Object.defineProperty(exports, 'TemplatesGenConfig', {
  enumerable: true,
  get: function () {
    return TemplatesGenConfig;
  }
});
Object.defineProperty(exports, '__toESM', {
  enumerable: true,
  get: function () {
    return __toESM;
  }
});
Object.defineProperty(exports, 'constants_exports', {
  enumerable: true,
  get: function () {
    return constants_exports;
  }
});
Object.defineProperty(exports, 'description', {
  enumerable: true,
  get: function () {
    return description;
  }
});
Object.defineProperty(exports, 'generateApi', {
  enumerable: true,
  get: function () {
    return generateApi;
  }
});
Object.defineProperty(exports, 'generateTemplates', {
  enumerable: true,
  get: function () {
    return generateTemplates;
  }
});
Object.defineProperty(exports, 'name', {
  enumerable: true,
  get: function () {
    return name;
  }
});
Object.defineProperty(exports, 'version', {
  enumerable: true,
  get: function () {
    return version;
  }
});
//# sourceMappingURL=src-DWf638kx.cjs.map